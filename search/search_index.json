{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Mechanics \u2013 Problem 1 Investigating the Range as a Function of the Angle of Projection \ud83d\udccc Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. \ud83e\udde0 1. Theoretical Foundation Derivation of Equations of Motion Starting from Newton\u2019s second law: Horizontal motion (no acceleration): [ x(t) = v_0 \\cos(\\theta) t ] Vertical motion (constant downward acceleration): [ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : angle of projection - \\( g \\) : gravitational acceleration - \\( x(t), y(t) \\) : position at time \\( t \\) Time of Flight The projectile hits the ground when \\( y(t) = 0 \\) (assuming launch and landing heights are equal): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin(\\theta)}{g} \\] Horizontal Range \\[ R = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Thus, the range depends on : - \\( v_0^2 \\) : quadratic in initial velocity - \\( \\sin(2\\theta) \\) : maximized at \\( \\theta = 45^\\circ \\) - Inversely proportional to \\( g \\) \ud83d\udcca 2. Analysis of the Range Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0 = 20 # m/s # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Range calculation R = (v0**2) * np.sin(2 * angles_rad) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.axvline(45, color='red', linestyle='--', label='Maximum Range at 45\u00b0') plt.legend() plt.show() \ud83d\udcc8 Observations: Maximum range occurs at \\( \\theta = 45^\\circ \\) Symmetry : The range at angle \\( \\theta \\) is the same as at \\( 90^\\circ - \\theta \\) Increasing \\( v_0 \\) increases the entire curve quadratically Increasing \\( g \\) (e.g., on different planets) compresses the range \ud83c\udf0d 3. Practical Applications Sports : Optimizing throw angles in javelin, soccer, basketball Engineering : Launching projectiles in defense or construction Astrophysics : Trajectories of space probes under planetary gravity Education : Classic introductory example of 2D motion \ud83d\udcbb 4. Implementation The included Python script simulates the range as a function of angle and allows for parameter variation: Change v0 to observe effects of initial speed Modify g to simulate other planets (e.g., Moon or Mars) Extend to 3D or add drag force for realism \u26a0\ufe0f 5. Limitations and Extensions Limitations: Neglects air resistance Assumes level ground Assumes constant gravitational field Ignores spin or shape of projectile Possible Extensions: Add quadratic drag : \\( F_{\\text{drag}} \\propto v^2 \\) Model variable terrain : \\( y(t) \\ne 0 \\) at impact Vary initial height : \\( y_0 > 0 \\) \ud83d\udcce Conclusion Projectile motion offers both analytical beauty and practical relevance . The range as a function of angle exhibits a clear, elegant dependence on \\( \\sin(2\\theta) \\) , and this can be extended in many ways to model real-world systems more closely.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1","text":"","title":"Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"\ud83e\udde0 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Starting from Newton\u2019s second law: Horizontal motion (no acceleration): [ x(t) = v_0 \\cos(\\theta) t ] Vertical motion (constant downward acceleration): [ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : angle of projection - \\( g \\) : gravitational acceleration - \\( x(t), y(t) \\) : position at time \\( t \\)","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile hits the ground when \\( y(t) = 0 \\) (assuming launch and landing heights are equal): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\[ R = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Thus, the range depends on : - \\( v_0^2 \\) : quadratic in initial velocity - \\( \\sin(2\\theta) \\) : maximized at \\( \\theta = 45^\\circ \\) - Inversely proportional to \\( g \\)","title":"Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"\ud83d\udcca 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0 = 20 # m/s # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Range calculation R = (v0**2) * np.sin(2 * angles_rad) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.axvline(45, color='red', linestyle='--', label='Maximum Range at 45\u00b0') plt.legend() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"Maximum range occurs at \\( \\theta = 45^\\circ \\) Symmetry : The range at angle \\( \\theta \\) is the same as at \\( 90^\\circ - \\theta \\) Increasing \\( v_0 \\) increases the entire curve quadratically Increasing \\( g \\) (e.g., on different planets) compresses the range","title":"\ud83d\udcc8 Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimizing throw angles in javelin, soccer, basketball Engineering : Launching projectiles in defense or construction Astrophysics : Trajectories of space probes under planetary gravity Education : Classic introductory example of 2D motion","title":"\ud83c\udf0d 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"The included Python script simulates the range as a function of angle and allows for parameter variation: Change v0 to observe effects of initial speed Modify g to simulate other planets (e.g., Moon or Mars) Extend to 3D or add drag force for realism","title":"\ud83d\udcbb 4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"\u26a0\ufe0f 5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Neglects air resistance Assumes level ground Assumes constant gravitational field Ignores spin or shape of projectile","title":"Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#possible-extensions","text":"Add quadratic drag : \\( F_{\\text{drag}} \\propto v^2 \\) Model variable terrain : \\( y(t) \\ne 0 \\) at impact Vary initial height : \\( y_0 > 0 \\)","title":"Possible Extensions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Projectile motion offers both analytical beauty and practical relevance . The range as a function of angle exhibits a clear, elegant dependence on \\( \\sin(2\\theta) \\) , and this can be extended in many ways to model real-world systems more closely.","title":"\ud83d\udcce Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a classic example of a nonlinear dynamical system exhibiting rich and complex behavior. The interplay between damping, restoring forces, and an external periodic driving force leads to phenomena such as resonance, periodic oscillations, quasiperiodicity, and chaos. This makes the forced damped pendulum a fundamental model for understanding real-world systems in physics and engineering, including driven oscillators, suspension bridges, and energy harvesting devices. Introducing forcing adds parameters such as the amplitude and frequency of the external force. By varying these parameters and the damping coefficient, we observe a wide range of behaviors from simple periodic motion to highly irregular, chaotic dynamics. 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency (with gravitational acceleration \\(g\\) and pendulum length \\(l\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega\\) is the driving frequency. For small angles ( \\(\\theta \\approx 0\\) ), the approximation \\(\\sin \\theta \\approx \\theta\\) linearizes the equation, allowing analytical insights into resonance conditions and steady-state solutions. However, the full nonlinear equation must be solved numerically to explore phenomena such as chaos and complex oscillations. 2. Analysis of Dynamics The behavior of the forced damped pendulum depends critically on the parameters: Damping coefficient \\(\\gamma\\) : Controls energy dissipation. Low damping can allow sustained oscillations; high damping suppresses motion. Driving amplitude \\(A\\) : Determines the strength of the external force. Higher amplitudes can induce complex behaviors. Driving frequency \\(\\omega\\) : Resonance occurs when \\(\\omega \\approx \\omega_0\\) , leading to large amplitude oscillations. By varying these parameters, the system transitions from regular periodic motion to quasiperiodic and chaotic dynamics. The pendulum can synchronize with the drive, oscillate erratically, or even settle into complex attractors. 3. Practical Applications The forced damped pendulum model applies to many real-world systems: Engineering: Design of suspension bridges, vibration absorbers, and mechanical oscillators. Energy harvesting: Devices that capture energy from mechanical vibrations often exploit forced oscillations. Electrical circuits: Analogous behavior occurs in driven RLC circuits. Biomechanics: Understanding human gait and oscillatory motion in biological systems. 4. Implementation: Numerical Simulation in Python The following Python script uses numerical integration to simulate the nonlinear forced damped pendulum. The scipy.integrate.solve_ivp function applies a Runge-Kutta method to solve the system of first-order ODEs: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) gamma = 0.5 # damping coefficient A = 1.2 # driving force amplitude omega_drive = 2/3 # driving frequency omega0 = np.sqrt(g / l) # natural frequency # Define the system of equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions: small displacement and zero initial velocity y0 = [0.2, 0.0] # Time span and points for evaluation t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(12, 6)) plt.plot(sol.t, sol.y[0], label='Angular displacement \u03b8 (rad)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() plt.show() 5. Visualization of Phase Space To better understand the system\u2019s behavior, we plot the phase portrait showing angular displacement \\( \\theta \\) versus angular velocity \\( \\omega = \\frac{d\\theta}{dt} \\) : plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], linewidth=0.5) plt.xlabel('\u03b8 (radians)') plt.ylabel('Angular velocity \u03c9 (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.grid(True) plt.show() Extensions and Further Analysis Poincar\u00e9 Sections: Sampling the system state at intervals equal to the driving period reveals discrete points that can classify motion types. Bifurcation Diagrams: Sweeping the driving amplitude or frequency and plotting long-term behavior illustrates transitions to chaos. Nonlinear damping: Including terms dependent on \\( \\omega^2 \\) or velocity cubed can better model real frictional forces. Non-periodic driving: Studying random or quasi-periodic forcing introduces further complexity relevant in natural systems. Limitations The small-angle approximation is insufficient for large oscillations. Real pendulums may experience non-ideal friction, air resistance, and structural flexibility. The model assumes a rigid rod and point mass bob. Numerical solutions may require fine time resolution and careful handling of chaotic sensitivity. Conclusion The forced damped pendulum offers profound insights into nonlinear dynamics, illustrating how simple systems can exhibit complex and unpredictable behavior. Numerical simulations combined with phase space analysis enable exploration beyond analytic solutions, providing a window into resonance, chaos, and real-world oscillatory phenomena.","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic example of a nonlinear dynamical system exhibiting rich and complex behavior. The interplay between damping, restoring forces, and an external periodic driving force leads to phenomena such as resonance, periodic oscillations, quasiperiodicity, and chaos. This makes the forced damped pendulum a fundamental model for understanding real-world systems in physics and engineering, including driven oscillators, suspension bridges, and energy harvesting devices. Introducing forcing adds parameters such as the amplitude and frequency of the external force. By varying these parameters and the damping coefficient, we observe a wide range of behaviors from simple periodic motion to highly irregular, chaotic dynamics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency (with gravitational acceleration \\(g\\) and pendulum length \\(l\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega\\) is the driving frequency. For small angles ( \\(\\theta \\approx 0\\) ), the approximation \\(\\sin \\theta \\approx \\theta\\) linearizes the equation, allowing analytical insights into resonance conditions and steady-state solutions. However, the full nonlinear equation must be solved numerically to explore phenomena such as chaos and complex oscillations.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The behavior of the forced damped pendulum depends critically on the parameters: Damping coefficient \\(\\gamma\\) : Controls energy dissipation. Low damping can allow sustained oscillations; high damping suppresses motion. Driving amplitude \\(A\\) : Determines the strength of the external force. Higher amplitudes can induce complex behaviors. Driving frequency \\(\\omega\\) : Resonance occurs when \\(\\omega \\approx \\omega_0\\) , leading to large amplitude oscillations. By varying these parameters, the system transitions from regular periodic motion to quasiperiodic and chaotic dynamics. The pendulum can synchronize with the drive, oscillate erratically, or even settle into complex attractors.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to many real-world systems: Engineering: Design of suspension bridges, vibration absorbers, and mechanical oscillators. Energy harvesting: Devices that capture energy from mechanical vibrations often exploit forced oscillations. Electrical circuits: Analogous behavior occurs in driven RLC circuits. Biomechanics: Understanding human gait and oscillatory motion in biological systems.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-numerical-simulation-in-python","text":"The following Python script uses numerical integration to simulate the nonlinear forced damped pendulum. The scipy.integrate.solve_ivp function applies a Runge-Kutta method to solve the system of first-order ODEs: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) gamma = 0.5 # damping coefficient A = 1.2 # driving force amplitude omega_drive = 2/3 # driving frequency omega0 = np.sqrt(g / l) # natural frequency # Define the system of equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions: small displacement and zero initial velocity y0 = [0.2, 0.0] # Time span and points for evaluation t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(12, 6)) plt.plot(sol.t, sol.y[0], label='Angular displacement \u03b8 (rad)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() plt.show()","title":"4. Implementation: Numerical Simulation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-visualization-of-phase-space","text":"To better understand the system\u2019s behavior, we plot the phase portrait showing angular displacement \\( \\theta \\) versus angular velocity \\( \\omega = \\frac{d\\theta}{dt} \\) : plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], linewidth=0.5) plt.xlabel('\u03b8 (radians)') plt.ylabel('Angular velocity \u03c9 (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.grid(True) plt.show() Extensions and Further Analysis Poincar\u00e9 Sections: Sampling the system state at intervals equal to the driving period reveals discrete points that can classify motion types. Bifurcation Diagrams: Sweeping the driving amplitude or frequency and plotting long-term behavior illustrates transitions to chaos. Nonlinear damping: Including terms dependent on \\( \\omega^2 \\) or velocity cubed can better model real frictional forces. Non-periodic driving: Studying random or quasi-periodic forcing introduces further complexity relevant in natural systems. Limitations The small-angle approximation is insufficient for large oscillations. Real pendulums may experience non-ideal friction, air resistance, and structural flexibility. The model assumes a rigid rod and point mass bob. Numerical solutions may require fine time resolution and careful handling of chaotic sensitivity. Conclusion The forced damped pendulum offers profound insights into nonlinear dynamics, illustrating how simple systems can exhibit complex and unpredictable behavior. Numerical simulations combined with phase space analysis enable exploration beyond analytic solutions, providing a window into resonance, chaos, and real-world oscillatory phenomena.","title":"5. Visualization of Phase Space"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Gravity Problem 1: Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental law enables the prediction of planetary motions and helps us understand gravitational interactions across the universe. By exploring this principle, we connect classical mechanics with observable astrophysical systems, such as satellite trajectories and planetary orbits. Task Theoretical Derivation Derive Kepler's Third Law for circular orbits: [ T^2 \\propto r^3 ] using Newton's Law of Gravitation and centripetal force. Astronomical Implications Discuss how this law is used to: Determine planetary masses Estimate distances between celestial bodies Understand orbital stability Real-World Examples Analyze orbits such as: The Moon orbiting Earth Planetary orbits in the Solar System Artificial satellites (e.g., GPS, ISS) Computational Simulation Implement a Python simulation to: Calculate orbital periods for various radii Visualize circular orbits Plot \\( T^2 \\) vs \\( r^3 \\) and verify linearity Deliverables \ud83d\udcc4 Markdown Report Includes derivation of Kepler\u2019s Third Law from Newtonian mechanics Discussion of astrophysical implications and extensions to elliptical orbits \ud83d\udc0d Python Script or Jupyter Notebook Simulates circular orbits using gravitational formulas Computes and plots the relationship between period and radius Validates \\( T^2 \\propto r^3 \\) \ud83d\udcca Visualizations Diagrams of orbital paths Log-log or linear plots of \\( T^2 \\) vs. \\( r^3 \\) Example comparisons using real astronomical data (e.g., Earth-Moon system) \ud83d\udd0d Discussion Section How Kepler's Law holds in elliptical orbits Generalization to systems beyond the Solar System Assumptions and limitations of circular orbit modeling Hints and Resources Use Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{r^2} ] and equate it with centripetal force: [ F = \\frac{m v^2}{r} ] Solve for \\( T \\) using: [ T = \\frac{2 \\pi r}{v} ] Plot using libraries like Matplotlib and compute with NumPy. Use SI units (mass in kg, radius in meters, time in seconds) for consistency. Optionally analyze deviations from linearity due to eccentricity or external forces.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity","text":"","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental law enables the prediction of planetary motions and helps us understand gravitational interactions across the universe. By exploring this principle, we connect classical mechanics with observable astrophysical systems, such as satellite trajectories and planetary orbits.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"Theoretical Derivation Derive Kepler's Third Law for circular orbits: [ T^2 \\propto r^3 ] using Newton's Law of Gravitation and centripetal force. Astronomical Implications Discuss how this law is used to: Determine planetary masses Estimate distances between celestial bodies Understand orbital stability Real-World Examples Analyze orbits such as: The Moon orbiting Earth Planetary orbits in the Solar System Artificial satellites (e.g., GPS, ISS) Computational Simulation Implement a Python simulation to: Calculate orbital periods for various radii Visualize circular orbits Plot \\( T^2 \\) vs \\( r^3 \\) and verify linearity","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"\ud83d\udcc4 Markdown Report Includes derivation of Kepler\u2019s Third Law from Newtonian mechanics Discussion of astrophysical implications and extensions to elliptical orbits \ud83d\udc0d Python Script or Jupyter Notebook Simulates circular orbits using gravitational formulas Computes and plots the relationship between period and radius Validates \\( T^2 \\propto r^3 \\) \ud83d\udcca Visualizations Diagrams of orbital paths Log-log or linear plots of \\( T^2 \\) vs. \\( r^3 \\) Example comparisons using real astronomical data (e.g., Earth-Moon system) \ud83d\udd0d Discussion Section How Kepler's Law holds in elliptical orbits Generalization to systems beyond the Solar System Assumptions and limitations of circular orbit modeling","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#hints-and-resources","text":"Use Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{r^2} ] and equate it with centripetal force: [ F = \\frac{m v^2}{r} ] Solve for \\( T \\) using: [ T = \\frac{2 \\pi r}{v} ] Plot using libraries like Matplotlib and compute with NumPy. Use SI units (mass in kg, radius in meters, time in seconds) for consistency. Optionally analyze deviations from linearity due to eccentricity or external forces.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2: Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task Define the first , second , and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth , Mars , and Jupiter . Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel. Deliverables A Markdown document with Python script or Jupyter notebook implementing the simulations. A detailed explanation of the subjects and their derivations. Graphical representations of escape velocities and cosmic velocities for various celestial bodies. Python Simulation Code \"\"\" `python code ` ```python import numpy as np Gravitational constant G = 6.67430e-11 # m^3/kg/s^2 Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"M\": 5.972e24, \"r\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"r\": 3.39e6}, \"Jupiter\": {\"M\": 1.898e27, \"r\": 6.9911e7} } print(\"Body\\t\\tv1 (km/s)\\tv2 (km/s)\") for body, data in bodies.items(): M = data[\"M\"] r = data[\"r\"] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) print(f\"{body:<10}\\t{v1/1000:.2f}\\t\\t{v2/1000:.2f}\") Body v1 (km/s) v2 (km/s) Earth 7.91 11.2 Mars 3.55 5.03 Jupiter 42.1 59.5 Discussion and Applications Real-World Uses First Cosmic Velocity: Launching satellites into Low Earth Orbit (LEO). Second Cosmic Velocity: Missions to the Moon, Mars, and outer planets. Third Cosmic Velocity: Required for interstellar probes like Voyager 1 and 2. Engineering Considerations Real launch speeds are higher due to atmospheric drag and non-vertical paths. Planetary rotation assists launch when launched from the equator. Missions often use gravity assists for interplanetary or interstellar speeds. Limitations and Extensions Ideal models ignore air resistance, non-spherical gravity, and planetary rotation. Relativistic corrections become important near massive objects or at high speeds. Interstellar travel requires propulsion beyond escape velocity (e.g., ion drives, solar sails). Conclusion Cosmic velocities define the energetic thresholds of space travel. From placing satellites into orbit to launching spacecraft beyond the Solar System, understanding these concepts is essential. Through theoretical analysis and computational simulations, we gain both practical and conceptual insight into the physics of gravitational escape.","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task","text":"Define the first , second , and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth , Mars , and Jupiter . Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"A Markdown document with Python script or Jupyter notebook implementing the simulations. A detailed explanation of the subjects and their derivations. Graphical representations of escape velocities and cosmic velocities for various celestial bodies.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-code","text":"\"\"\" `python code ` ```python import numpy as np","title":"Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-constant","text":"G = 6.67430e-11 # m^3/kg/s^2","title":"Gravitational constant"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-body-data-mass-in-kg-radius-in-meters","text":"bodies = { \"Earth\": {\"M\": 5.972e24, \"r\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"r\": 3.39e6}, \"Jupiter\": {\"M\": 1.898e27, \"r\": 6.9911e7} } print(\"Body\\t\\tv1 (km/s)\\tv2 (km/s)\") for body, data in bodies.items(): M = data[\"M\"] r = data[\"r\"] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) print(f\"{body:<10}\\t{v1/1000:.2f}\\t\\t{v2/1000:.2f}\") Body v1 (km/s) v2 (km/s) Earth 7.91 11.2 Mars 3.55 5.03 Jupiter 42.1 59.5 Discussion and Applications Real-World Uses First Cosmic Velocity: Launching satellites into Low Earth Orbit (LEO). Second Cosmic Velocity: Missions to the Moon, Mars, and outer planets. Third Cosmic Velocity: Required for interstellar probes like Voyager 1 and 2. Engineering Considerations Real launch speeds are higher due to atmospheric drag and non-vertical paths. Planetary rotation assists launch when launched from the equator. Missions often use gravity assists for interplanetary or interstellar speeds. Limitations and Extensions Ideal models ignore air resistance, non-spherical gravity, and planetary rotation. Relativistic corrections become important near massive objects or at high speeds. Interstellar travel requires propulsion beyond escape velocity (e.g., ion drives, solar sails). Conclusion Cosmic velocities define the energetic thresholds of space travel. From placing satellites into orbit to launching spacecraft beyond the Solar System, understanding these concepts is essential. Through theoretical analysis and computational simulations, we gain both practical and conceptual insight into the physics of gravitational escape.","title":"Celestial body data (mass in kg, radius in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario is critical for understanding orbital mechanics, with applications in space mission planning, satellite deployment, and reentry scenarios. Task Analyze possible trajectories (parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform numerical analysis to compute the payload's path based on initial conditions (position, velocity, altitude). Discuss how trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the payload's motion under Earth's gravity. Explanation of Subjects The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] where: - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) ), - \\( M \\) is Earth's mass ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), - \\( m \\) is the payload's mass, - \\( r \\) is the distance from Earth's center. The trajectory depends on the specific mechanical energy ( \\( \\epsilon \\) ): \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\( v \\) is the payload's velocity, - \\( \\mu = G M \\) is Earth's gravitational parameter ( \\( 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2} \\) ), - \\( r \\) is the radial distance. The trajectory type is determined by the eccentricity ( \\( e \\) ) of the orbit: - Elliptical ( \\( e < 1 \\) ): Closed orbit, e.g., satellite in low Earth orbit. - Parabolic ( \\( e = 1 \\) ): Escape trajectory with zero residual energy. - Hyperbolic ( \\( e > 1 \\) ): Escape trajectory with excess energy. Applications : - Orbital insertion : Achieving a stable elliptical orbit (e.g., for satellites). - Reentry : Elliptical or parabolic trajectories that intersect Earth's atmosphere. - Escape : Hyperbolic trajectories for interplanetary missions. Python Implementation The following Python script simulates the payload's motion using numerical integration (Runge-Kutta 4 method) and visualizes trajectories for different initial velocities. It assumes a 2D plane for simplicity and neglects atmospheric drag. ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth's mass (kg) mu = G * M # Gravitational parameter (m^3 s^-2) R_earth = 6.371e6 # Earth's radius (m) Equations of motion for 2D orbit def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -mu * x / r 3 ay = -mu * y / r 3 return [vx, vy, ax, ay] Compute specific energy and eccentricity def compute_orbit_params(r, v): r_mag = np.sqrt(r.dot(r)) v_mag = np.sqrt(v.dot(v)) energy = v_mag 2 / 2 - mu / r_mag h = np.cross(r, v) # Specific angular momentum (2D: scalar) e = np.sqrt(1 + (2 * energy * h 2) / mu**2) return energy, e Simulate trajectory def simulate_trajectory(initial_altitude, initial_velocity, angle_deg, t_span, t_eval): # Initial conditions r0 = [R_earth + initial_altitude, 0] # Start at (x, 0) angle = np.radians(angle_deg) v0 = [initial_velocity * np.cos(angle), initial_velocity * np.sin(angle)] # Compute initial orbit parameters energy, eccentricity = compute_orbit_params(np.array(r0), np.array(v0)) # Integrate equations of motion state0 = r0 + v0 sol = solve_ivp(equations_of_motion, t_span, state0, t_eval=t_eval, method='RK45') return sol, energy, eccentricity Plotting function def plot_trajectory(sol, energy, eccentricity, label): x, y = sol.y[0], sol.y[1] plt.plot(x / 1e6, y / 1e6, label=f'{label}, e={eccentricity:.2f}, \u03b5={energy:.2e} J/kg') # Plot Earth theta = np.linspace(0, 2 * np.pi, 100) x_earth = (R_earth / 1e6) * np.cos(theta) y_earth = (R_earth / 1e6) * np.sin(theta) plt.fill(x_earth, y_earth, 'b', alpha=0.3, label='Earth') Simulation parameters initial_altitude = 200e3 # 200 km altitude t_span = [0, 3600] # 1 hour simulation t_eval = np.linspace(0, 3600, 1000) Test different initial velocities for circular, elliptical, parabolic, and hyperbolic orbits v_circular = np.sqrt(mu / (R_earth + initial_altitude)) # Circular orbit velocity v_escape = np.sqrt(2 * mu / (R_earth + initial_altitude)) # Escape velocity velocities = [ (v_circular, 'Circular', 90), # Circular orbit (tangential) (v_circular * 0.9, 'Elliptical', 90), # Sub-circular (elliptical) (v_escape, 'Parabolic', 90), # Escape velocity (parabolic) (v_escape * 1.2, 'Hyperbolic', 90) # Above escape (hyperbolic) ] Plot setup plt.figure(figsize=(10, 8)) for v, label, angle in velocities: sol, energy, eccentricity = simulate_trajectory(initial_altitude, v, angle, t_span, t_eval) plot_trajectory(sol, energy, eccentricity, label) Finalize plot plt.xlabel('X (Mm)') plt.ylabel('Y (Mm)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.axis('equal') plt.show()","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario is critical for understanding orbital mechanics, with applications in space mission planning, satellite deployment, and reentry scenarios.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze possible trajectories (parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform numerical analysis to compute the payload's path based on initial conditions (position, velocity, altitude). Discuss how trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the payload's motion under Earth's gravity.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-subjects","text":"The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] where: - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) ), - \\( M \\) is Earth's mass ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), - \\( m \\) is the payload's mass, - \\( r \\) is the distance from Earth's center. The trajectory depends on the specific mechanical energy ( \\( \\epsilon \\) ): \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\( v \\) is the payload's velocity, - \\( \\mu = G M \\) is Earth's gravitational parameter ( \\( 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2} \\) ), - \\( r \\) is the radial distance. The trajectory type is determined by the eccentricity ( \\( e \\) ) of the orbit: - Elliptical ( \\( e < 1 \\) ): Closed orbit, e.g., satellite in low Earth orbit. - Parabolic ( \\( e = 1 \\) ): Escape trajectory with zero residual energy. - Hyperbolic ( \\( e > 1 \\) ): Escape trajectory with excess energy. Applications : - Orbital insertion : Achieving a stable elliptical orbit (e.g., for satellites). - Reentry : Elliptical or parabolic trajectories that intersect Earth's atmosphere. - Escape : Hyperbolic trajectories for interplanetary missions.","title":"Explanation of Subjects"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"The following Python script simulates the payload's motion using numerical integration (Runge-Kutta 4 method) and visualizes trajectories for different initial velocities. It assumes a 2D plane for simplicity and neglects atmospheric drag. ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth's mass (kg) mu = G * M # Gravitational parameter (m^3 s^-2) R_earth = 6.371e6 # Earth's radius (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-for-2d-orbit","text":"def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -mu * x / r 3 ay = -mu * y / r 3 return [vx, vy, ax, ay]","title":"Equations of motion for 2D orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#compute-specific-energy-and-eccentricity","text":"def compute_orbit_params(r, v): r_mag = np.sqrt(r.dot(r)) v_mag = np.sqrt(v.dot(v)) energy = v_mag 2 / 2 - mu / r_mag h = np.cross(r, v) # Specific angular momentum (2D: scalar) e = np.sqrt(1 + (2 * energy * h 2) / mu**2) return energy, e","title":"Compute specific energy and eccentricity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulate-trajectory","text":"def simulate_trajectory(initial_altitude, initial_velocity, angle_deg, t_span, t_eval): # Initial conditions r0 = [R_earth + initial_altitude, 0] # Start at (x, 0) angle = np.radians(angle_deg) v0 = [initial_velocity * np.cos(angle), initial_velocity * np.sin(angle)] # Compute initial orbit parameters energy, eccentricity = compute_orbit_params(np.array(r0), np.array(v0)) # Integrate equations of motion state0 = r0 + v0 sol = solve_ivp(equations_of_motion, t_span, state0, t_eval=t_eval, method='RK45') return sol, energy, eccentricity","title":"Simulate trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting-function","text":"def plot_trajectory(sol, energy, eccentricity, label): x, y = sol.y[0], sol.y[1] plt.plot(x / 1e6, y / 1e6, label=f'{label}, e={eccentricity:.2f}, \u03b5={energy:.2e} J/kg') # Plot Earth theta = np.linspace(0, 2 * np.pi, 100) x_earth = (R_earth / 1e6) * np.cos(theta) y_earth = (R_earth / 1e6) * np.sin(theta) plt.fill(x_earth, y_earth, 'b', alpha=0.3, label='Earth')","title":"Plotting function"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"initial_altitude = 200e3 # 200 km altitude t_span = [0, 3600] # 1 hour simulation t_eval = np.linspace(0, 3600, 1000)","title":"Simulation parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#test-different-initial-velocities-for-circular-elliptical-parabolic-and-hyperbolic-orbits","text":"v_circular = np.sqrt(mu / (R_earth + initial_altitude)) # Circular orbit velocity v_escape = np.sqrt(2 * mu / (R_earth + initial_altitude)) # Escape velocity velocities = [ (v_circular, 'Circular', 90), # Circular orbit (tangential) (v_circular * 0.9, 'Elliptical', 90), # Sub-circular (elliptical) (v_escape, 'Parabolic', 90), # Escape velocity (parabolic) (v_escape * 1.2, 'Hyperbolic', 90) # Above escape (hyperbolic) ]","title":"Test different initial velocities for circular, elliptical, parabolic, and hyperbolic orbits"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-setup","text":"plt.figure(figsize=(10, 8)) for v, label, angle in velocities: sol, energy, eccentricity = simulate_trajectory(initial_altitude, v, angle, t_span, t_eval) plot_trajectory(sol, energy, eccentricity, label)","title":"Plot setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#finalize-plot","text":"plt.xlabel('X (Mm)') plt.ylabel('Y (Mm)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.axis('equal') plt.show()","title":"Finalize plot"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Waves \u2014 Interference Patterns on a Water Surface \ud83d\udd0d Problem 1: Interference Patterns on a Water Surface \ud83e\udde0 Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is seen when ripples from different points meet, forming areas where waves reinforce or cancel each other out. This experiment helps us visually understand key concepts in wave physics, such as coherence, phase difference, and constructive/destructive interference. \ud83c\udfaf Task Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon . \ud83d\udee0\ufe0f Steps to Follow 1. Select a Regular Polygon We choose a square with 4 point sources at the vertices. 2. Position the Sources The sources are placed evenly on a circle (radius = 3 units), forming a square. 3. Wave Equation Each wave from a source \\((x_i, y_i)\\) is given by: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: - \\( A \\) : amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number - \\( \\omega = 2\\pi f \\) : angular frequency - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : distance from source to point - \\( \\phi \\) : initial phase (same for all sources) 4. Superposition of Waves \\[ \\psi_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\] 5. Analyze Interference We visualize the total wave field \\(\\psi_{\\text{total}}(x, y, t)\\) to identify constructive and destructive interference regions. \ud83d\udc0d Python Simulation Code import numpy as np import matplotlib.pyplot as plt Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength \u03bb frequency = 1.0 # Frequency f phi = 0 # Initial phase N = 4 # Number of sources (square) radius = 3 # Radius of the polygon Derived parameters k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency Define polygon vertices angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] Create grid x = np.linspace(-6, 6, 500) y = np.linspace(-6, 6, 500) X, Y = np.meshgrid(x, y) t = 0 # Snapshot at t=0 Superposition of waves Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0) 2 + (Y - y0) 2) Z += A * np.cos(k * r - omega * t + phi) Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.title('Interference Pattern from 4 Point Sources (Square)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"\ud83c\udf0a Waves \u2014 Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#waves-interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Waves \u2014 Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1-interference-patterns-on-a-water-surface","text":"","title":"\ud83d\udd0d Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is seen when ripples from different points meet, forming areas where waves reinforce or cancel each other out. This experiment helps us visually understand key concepts in wave physics, such as coherence, phase difference, and constructive/destructive interference.","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon .","title":"\ud83c\udfaf Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"","title":"\ud83d\udee0\ufe0f Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-select-a-regular-polygon","text":"We choose a square with 4 point sources at the vertices.","title":"1. Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-position-the-sources","text":"The sources are placed evenly on a circle (radius = 3 units), forming a square.","title":"2. Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-wave-equation","text":"Each wave from a source \\((x_i, y_i)\\) is given by: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: - \\( A \\) : amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number - \\( \\omega = 2\\pi f \\) : angular frequency - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : distance from source to point - \\( \\phi \\) : initial phase (same for all sources)","title":"3. Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-of-waves","text":"\\[ \\psi_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\]","title":"4. Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyze-interference","text":"We visualize the total wave field \\(\\psi_{\\text{total}}(x, y, t)\\) to identify constructive and destructive interference regions.","title":"5. Analyze Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udc0d Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-parameters","text":"A = 1.0 # Amplitude wavelength = 1.0 # Wavelength \u03bb frequency = 1.0 # Frequency f phi = 0 # Initial phase N = 4 # Number of sources (square) radius = 3 # Radius of the polygon","title":"Wave parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#derived-parameters","text":"k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency","title":"Derived parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#define-polygon-vertices","text":"angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles]","title":"Define polygon vertices"},{"location":"1%20Physics/3%20Waves/Problem_1/#create-grid","text":"x = np.linspace(-6, 6, 500) y = np.linspace(-6, 6, 500) X, Y = np.meshgrid(x, y) t = 0 # Snapshot at t=0","title":"Create grid"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0) 2 + (Y - y0) 2) Z += A * np.cos(k * r - omega * t + phi)","title":"Superposition of waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization","text":"plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.title('Interference Pattern from 4 Point Sources (Square)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \u26a1 Electromagnetism \u2014 Problem 1: Simulating the Effects of the Lorentz Force \ud83e\udde0 Motivation The Lorentz force , given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] is the fundamental law describing the motion of a charged particle in electric and magnetic fields. It plays a crucial role in many advanced technologies and physical systems, including: Particle Accelerators (e.g., cyclotrons, synchrotrons) Mass Spectrometers Plasma Confinement Devices (e.g., Tokamaks) Astrophysical Plasmas Through simulation, we can visualize how the Lorentz force influences particle trajectories and gain deeper insights into both theory and applications. \ud83d\udd0d 1. Exploration of Applications Systems where the Lorentz Force is Crucial: Particle Accelerators : Charged particles are bent into circular paths using magnetic fields; acceleration occurs via electric fields. Mass Spectrometers : The deflection of ions in a magnetic field depends on their mass-to-charge ratio. Fusion Reactors : Magnetic fields confine hot plasma, exploiting the Lorentz force to keep particles from hitting the reactor walls. Role of Fields: Electric Fields ( \\(\\vec{E}\\) ) accelerate or decelerate particles linearly. Magnetic Fields ( \\(\\vec{B}\\) ) bend the particle's path, causing circular or helical motion, but do not change speed. \ud83e\uddea 2. Simulating Particle Motion We simulate the particle's trajectory by solving Newton's Second Law: \\[ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This system is solved numerically using the Euler method for simplicity. \ud83d\udc0d Python Code for Simulating the Lorentz Force ```python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D Constants q = 1.6e-19 # charge (Coulombs) m = 9.11e-31 # mass (kg) E = np.array([0, 0, 0]) # electric field (V/m) B = np.array([0, 0, 1]) # magnetic field (T) Initial conditions v0 = np.array([1e6, 0, 1e6]) # initial velocity (m/s) r0 = np.array([0, 0, 0]) # initial position (m) Time parameters dt = 1e-11 # time step (s) T = 1e-7 # total time (s) steps = int(T / dt) Initialize arrays r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 Euler method for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt Plotting in 3D fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Particle Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Trajectory of a Charged Particle in a Magnetic Field') ax.legend() plt.tight_layout() plt.show() \u2699\ufe0f 3. Parameter Exploration To better understand how different variables affect the trajectory of a charged particle under the Lorentz force, we explore the effects of changing key parameters: \ud83d\udd27 Parameters to Vary: Magnetic Field Strength and Direction ( \\(\\vec{B}\\) ): Example: Vary from \\( \\vec{B} = [0, 0, 1] \\) to \\( \\vec{B} = [1, 0, 1] \\) Observe change in curvature and spiral tightness Electric Field ( \\(\\vec{E}\\) ): Add a uniform electric field to see drift motion Example: \\( \\vec{E} = [1 \\times 10^5, 0, 0] \\) Initial Velocity ( \\(\\vec{v}_0\\) ): Change magnitude and orientation Observe transition from circular to helical motion Charge ( \\(q\\) ) and Mass ( \\(m\\) ) : Switch from electron to proton (higher mass, same charge magnitude) Observe the effect on Larmor radius and acceleration \ud83e\uddea Observational Goals: How increasing magnetic field strength tightens circular motion. How introducing electric fields leads to E \u00d7 B drift . How heavier particles (e.g., protons) move slower under the same force. \ud83d\udcca 4. Visualization of Trajectories We generate 2D and 3D plots of the particle\u2019s motion using matplotlib . \u2705 Visual Cues: Color-coded or labeled axes Plotting time-dependent trajectories: XY view shows circular motion XZ or 3D view shows helical motion if initial velocity has a component parallel to \\(\\vec{B}\\) \ud83c\udf00 Physical Quantities to Highlight: Larmor Radius (gyroradius): \\[ r_L = \\frac{mv_{\\perp}}{qB} \\] Where \\(v_{\\perp}\\) is the velocity component perpendicular to \\(\\vec{B}\\) . Cyclotron Frequency: \\[ \\omega_c = \\frac{qB}{m} \\] This determines the angular frequency of circular motion in the magnetic field. Drift Velocity (for crossed fields): \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Visible as a net translation over time when both \\(\\vec{E}\\) and \\(\\vec{B}\\) are present and orthogonal. \ud83d\udcac Discussion of Results Key Observations: With only magnetic fields , charged particles move in circular or helical paths depending on velocity orientation. Adding an electric field parallel to velocity increases acceleration. When \\(\\vec{E}\\) and \\(\\vec{B}\\) are perpendicular , the particle exhibits a drift in a direction perpendicular to both fields. The radius of curvature increases with particle mass or decreasing magnetic field strength. Energy remains constant in magnetic-only scenarios since the magnetic field does no work. \ud83c\udf0d Real-World Applications \u2699\ufe0f Practical Systems: Application Role of Lorentz Force Cyclotrons Spiral acceleration using B fields Mass Spectrometers Measure mass/charge via deflection Plasma Traps Use magnetic confinement in fusion Earth\u2019s Magnetosphere Charged particle motion explains auroras In each case, control over \\(\\vec{E}\\) and \\(\\vec{B}\\) is essential for guiding particle motion. \ud83d\ude80 Suggestions for Extensions To expand the simulation: Use a Runge-Kutta (RK4) solver for better accuracy Add non-uniform fields (gradients, dipoles) Model particle collisions or radiation loss Simulate a plasma (many particles with charge interactions) Implement relativistic corrections at high speeds \ud83d\udce6 Deliverables Recap \u2705 Python script simulating Lorentz force dynamics \u2705 2D and 3D plots of trajectories under various field configurations \u2705 Parameter analysis and visualizations of motion types \u2705 Discussion of physical significance and real-world relevance \u2705 Suggestions for future improvements and added complexity","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"\u26a1 Electromagnetism \u2014 Problem 1: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force , given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] is the fundamental law describing the motion of a charged particle in electric and magnetic fields. It plays a crucial role in many advanced technologies and physical systems, including: Particle Accelerators (e.g., cyclotrons, synchrotrons) Mass Spectrometers Plasma Confinement Devices (e.g., Tokamaks) Astrophysical Plasmas Through simulation, we can visualize how the Lorentz force influences particle trajectories and gain deeper insights into both theory and applications.","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"","title":"\ud83d\udd0d 1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#systems-where-the-lorentz-force-is-crucial","text":"Particle Accelerators : Charged particles are bent into circular paths using magnetic fields; acceleration occurs via electric fields. Mass Spectrometers : The deflection of ions in a magnetic field depends on their mass-to-charge ratio. Fusion Reactors : Magnetic fields confine hot plasma, exploiting the Lorentz force to keep particles from hitting the reactor walls.","title":"Systems where the Lorentz Force is Crucial:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#role-of-fields","text":"Electric Fields ( \\(\\vec{E}\\) ) accelerate or decelerate particles linearly. Magnetic Fields ( \\(\\vec{B}\\) ) bend the particle's path, causing circular or helical motion, but do not change speed.","title":"Role of Fields:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We simulate the particle's trajectory by solving Newton's Second Law: \\[ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This system is solved numerically using the Euler method for simplicity.","title":"\ud83e\uddea 2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-for-simulating-the-lorentz-force","text":"```python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D","title":"\ud83d\udc0d Python Code for Simulating the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#constants","text":"q = 1.6e-19 # charge (Coulombs) m = 9.11e-31 # mass (kg) E = np.array([0, 0, 0]) # electric field (V/m) B = np.array([0, 0, 1]) # magnetic field (T)","title":"Constants"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#initial-conditions","text":"v0 = np.array([1e6, 0, 1e6]) # initial velocity (m/s) r0 = np.array([0, 0, 0]) # initial position (m)","title":"Initial conditions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#time-parameters","text":"dt = 1e-11 # time step (s) T = 1e-7 # total time (s) steps = int(T / dt)","title":"Time parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#initialize-arrays","text":"r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0","title":"Initialize arrays"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#euler-method","text":"for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt","title":"Euler method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plotting-in-3d","text":"fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Particle Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Trajectory of a Charged Particle in a Magnetic Field') ax.legend() plt.tight_layout() plt.show()","title":"Plotting in 3D"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"To better understand how different variables affect the trajectory of a charged particle under the Lorentz force, we explore the effects of changing key parameters:","title":"\u2699\ufe0f 3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters-to-vary","text":"Magnetic Field Strength and Direction ( \\(\\vec{B}\\) ): Example: Vary from \\( \\vec{B} = [0, 0, 1] \\) to \\( \\vec{B} = [1, 0, 1] \\) Observe change in curvature and spiral tightness Electric Field ( \\(\\vec{E}\\) ): Add a uniform electric field to see drift motion Example: \\( \\vec{E} = [1 \\times 10^5, 0, 0] \\) Initial Velocity ( \\(\\vec{v}_0\\) ): Change magnitude and orientation Observe transition from circular to helical motion Charge ( \\(q\\) ) and Mass ( \\(m\\) ) : Switch from electron to proton (higher mass, same charge magnitude) Observe the effect on Larmor radius and acceleration","title":"\ud83d\udd27 Parameters to Vary:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observational-goals","text":"How increasing magnetic field strength tightens circular motion. How introducing electric fields leads to E \u00d7 B drift . How heavier particles (e.g., protons) move slower under the same force.","title":"\ud83e\uddea Observational Goals:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization-of-trajectories","text":"We generate 2D and 3D plots of the particle\u2019s motion using matplotlib .","title":"\ud83d\udcca 4. Visualization of Trajectories"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visual-cues","text":"Color-coded or labeled axes Plotting time-dependent trajectories: XY view shows circular motion XZ or 3D view shows helical motion if initial velocity has a component parallel to \\(\\vec{B}\\)","title":"\u2705 Visual Cues:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-quantities-to-highlight","text":"Larmor Radius (gyroradius): \\[ r_L = \\frac{mv_{\\perp}}{qB} \\] Where \\(v_{\\perp}\\) is the velocity component perpendicular to \\(\\vec{B}\\) . Cyclotron Frequency: \\[ \\omega_c = \\frac{qB}{m} \\] This determines the angular frequency of circular motion in the magnetic field. Drift Velocity (for crossed fields): \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Visible as a net translation over time when both \\(\\vec{E}\\) and \\(\\vec{B}\\) are present and orthogonal.","title":"\ud83c\udf00 Physical Quantities to Highlight:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#discussion-of-results","text":"","title":"\ud83d\udcac Discussion of Results"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-observations","text":"With only magnetic fields , charged particles move in circular or helical paths depending on velocity orientation. Adding an electric field parallel to velocity increases acceleration. When \\(\\vec{E}\\) and \\(\\vec{B}\\) are perpendicular , the particle exhibits a drift in a direction perpendicular to both fields. The radius of curvature increases with particle mass or decreasing magnetic field strength. Energy remains constant in magnetic-only scenarios since the magnetic field does no work.","title":"Key Observations:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-applications","text":"","title":"\ud83c\udf0d Real-World Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#practical-systems","text":"Application Role of Lorentz Force Cyclotrons Spiral acceleration using B fields Mass Spectrometers Measure mass/charge via deflection Plasma Traps Use magnetic confinement in fusion Earth\u2019s Magnetosphere Charged particle motion explains auroras In each case, control over \\(\\vec{E}\\) and \\(\\vec{B}\\) is essential for guiding particle motion.","title":"\u2699\ufe0f Practical Systems:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#suggestions-for-extensions","text":"To expand the simulation: Use a Runge-Kutta (RK4) solver for better accuracy Add non-uniform fields (gradients, dipoles) Model particle collisions or radiation loss Simulate a plasma (many particles with charge interactions) Implement relativistic corrections at high speeds","title":"\ud83d\ude80 Suggestions for Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables-recap","text":"\u2705 Python script simulating Lorentz force dynamics \u2705 2D and 3D plots of trajectories under various field configurations \u2705 Parameter analysis and visualizations of motion types \u2705 Discussion of physical significance and real-world relevance \u2705 Suggestions for future improvements and added complexity","title":"\ud83d\udce6 Deliverables Recap"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}