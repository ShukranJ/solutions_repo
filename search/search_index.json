{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1: Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, provides a rich framework for exploring core principles of physics. Despite the apparent simplicity of launching an object into the air, the underlying physics involves various interacting parameters: Initial velocity : \\( v_0 \\) Gravitational acceleration : \\( g \\) Launch angle : \\( \\theta \\) These variables result in a wide variety of possible trajectories, modeling real-world phenomena from sports to spacecraft dynamics. Theoretical Background Assume an object is launched from flat ground with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) above the horizontal, and neglect air resistance. Equations of Motion Horizontal position : [ x(t) = v_0 \\cos(\\theta) \\cdot t ] Vertical position : [ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 ] Time of Flight The projectile returns to the ground when \\( y(t) = 0 \\) : \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range Equation Substitute time of flight into the horizontal equation to find range: \\[ R = v_0 \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This expression defines a family of solutions depending on: - \\( v_0 \\) : launch speed - \\( \\theta \\) : launch angle - \\( g \\) : local gravity Maximum range is achieved when \\( \\theta = 45^\\circ \\) , since \\( \\sin(2\\theta) \\) reaches its maximum of 1. Analysis of Range Behavior Parameter Influence Velocity : \\( R \\propto v_0^2 \\) \u2192 doubling speed quadruples the range. Gravity : \\( R \\propto \\frac{1}{g} \\) \u2192 lower gravity increases range. Symmetry The range is symmetric around \\( \\theta = 45^\\circ \\) . Angles \\( \\theta \\) and \\( 90^\\circ - \\theta \\) yield the same range. Practical Applications This model applies to real-world phenomena such as: Sports : Ball trajectories in football, basketball, etc. Engineering : Calculations in artillery or construction. Astrophysics : Trajectories of planetary probes and landers. Extensions Uneven launch and landing heights. Air resistance (drag). Wind and rotational effects (e.g., Coriolis force). Python Simulation ```python import numpy as np import matplotlib.pyplot as plt --- Constants --- g = 9.81 # Acceleration due to gravity (m/s\u00b2) v0 = 30 # Initial velocity (m/s) --- Angles from 0 to 90 degrees --- angles_deg = np.linspace(0, 90, 500) # 500 points from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) # Convert to radians for computation --- Range Calculation --- R = (v0**2) * np.sin(2 * angles_rad) / g # R = (v\u2080\u00b2 * sin(2\u03b8)) / g --- Plotting --- plt.figure(figsize=(10, 6)) plt.plot(angles_deg, R, color='navy', label=f'v\u2080 = {v0} m/s') plt.axvline(45, color='red', linestyle='--', label='Maximum at 45\u00b0') plt.title('Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show() \u2705 Explanation: np.linspace(0, 90, 500) : Generates 500 evenly spaced angles between 0\u00b0 and 90\u00b0. np.radians(...) : Converts degrees to radians since np.sin() expects radians. R = (v0**2) * np.sin(2 * \u03b8) / g : Formula for range of projectile on flat ground. plt.axvline(45, ...) : Highlights the theoretical maximum range at 45\u00b0.","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, provides a rich framework for exploring core principles of physics. Despite the apparent simplicity of launching an object into the air, the underlying physics involves various interacting parameters: Initial velocity : \\( v_0 \\) Gravitational acceleration : \\( g \\) Launch angle : \\( \\theta \\) These variables result in a wide variety of possible trajectories, modeling real-world phenomena from sports to spacecraft dynamics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-background","text":"Assume an object is launched from flat ground with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) above the horizontal, and neglect air resistance.","title":"Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal position : [ x(t) = v_0 \\cos(\\theta) \\cdot t ] Vertical position : [ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 ]","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile returns to the ground when \\( y(t) = 0 \\) : \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"Substitute time of flight into the horizontal equation to find range: \\[ R = v_0 \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This expression defines a family of solutions depending on: - \\( v_0 \\) : launch speed - \\( \\theta \\) : launch angle - \\( g \\) : local gravity Maximum range is achieved when \\( \\theta = 45^\\circ \\) , since \\( \\sin(2\\theta) \\) reaches its maximum of 1.","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-range-behavior","text":"","title":"Analysis of Range Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-influence","text":"Velocity : \\( R \\propto v_0^2 \\) \u2192 doubling speed quadruples the range. Gravity : \\( R \\propto \\frac{1}{g} \\) \u2192 lower gravity increases range.","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#symmetry","text":"The range is symmetric around \\( \\theta = 45^\\circ \\) . Angles \\( \\theta \\) and \\( 90^\\circ - \\theta \\) yield the same range.","title":"Symmetry"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"This model applies to real-world phenomena such as: Sports : Ball trajectories in football, basketball, etc. Engineering : Calculations in artillery or construction. Astrophysics : Trajectories of planetary probes and landers.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#extensions","text":"Uneven launch and landing heights. Air resistance (drag). Wind and rotational effects (e.g., Coriolis force).","title":"Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#-constants-","text":"g = 9.81 # Acceleration due to gravity (m/s\u00b2) v0 = 30 # Initial velocity (m/s)","title":"--- Constants ---"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#-angles-from-0-to-90-degrees-","text":"angles_deg = np.linspace(0, 90, 500) # 500 points from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) # Convert to radians for computation","title":"--- Angles from 0 to 90 degrees ---"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#-range-calculation-","text":"R = (v0**2) * np.sin(2 * angles_rad) / g # R = (v\u2080\u00b2 * sin(2\u03b8)) / g","title":"--- Range Calculation ---"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#-plotting-","text":"plt.figure(figsize=(10, 6)) plt.plot(angles_deg, R, color='navy', label=f'v\u2080 = {v0} m/s') plt.axvline(45, color='red', linestyle='--', label='Maximum at 45\u00b0') plt.title('Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"--- Plotting ---"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation","text":"np.linspace(0, 90, 500) : Generates 500 evenly spaced angles between 0\u00b0 and 90\u00b0. np.radians(...) : Converts degrees to radians since np.sin() expects radians. R = (v0**2) * np.sin(2 * \u03b8) / g : Formula for range of projectile on flat ground. plt.axvline(45, ...) : Highlights the theoretical maximum range at 45\u00b0.","title":"\u2705 Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena are foundational to understanding complex real-world systems such as: - Driven oscillators in engineering, - Mechanical structures under periodic stress, - Climate systems, - Electrical RLC circuits. By systematically varying parameters like the damping coefficient, driving amplitude, and frequency, the pendulum's behavior ranges from regular, synchronized oscillations to chaotic and unpredictable motion. This task aims to analyze and visualize these behaviors through theory and simulation. 1. Theoretical Foundation We begin with the governing differential equation of the forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega_0 \\) is the natural frequency, - \\( A \\) is the driving amplitude, - \\( \\omega \\) is the driving frequency. Small-Angle Approximation For small angles ( \\( \\theta \\ll 1 \\) ), we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized version: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This can be solved analytically to explore resonance behavior and energy dynamics. 2. Analysis of Dynamics Parameter Influence We examine how the following affect the system: - Damping coefficient \\( \\gamma \\) - Driving amplitude \\( A \\) - Driving frequency \\( \\omega \\) Regular vs. Chaotic Motion Identify ranges of parameters that result in periodic , quasiperiodic , and chaotic motion. Use phase space and Poincar\u00e9 sections to visualize transitions between behaviors. 3. Practical Applications The forced damped pendulum models real-world systems such as: - Energy harvesting devices (piezoelectric cantilevers), - Suspension bridges subjected to wind or traffic, - Driven RLC circuits in electronics, - Biomechanical systems like human gait under periodic external forces. 4. Implementation (Python Simulation) Simulation Plan Use numerical solvers (e.g., Runge-Kutta 4th order ) to simulate nonlinear motion. Vary initial conditions and parameters. Plot: Time series \\( \\theta(t) \\) , Phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ), Poincar\u00e9 sections, Bifurcation diagrams. Example Code Snippet ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Parameters gamma = 0.5 omega0 = 1.5 A = 1.2 omega = 2.0 def pendulum(t, y): theta, dtheta = y return [dtheta, -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] Initial condition and time span y0 = [0.1, 0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) Solve sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) Plot plt.plot(sol.t, sol.y[0]) plt.title('Forced Damped Pendulum: \u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.grid(True) plt.show()","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena are foundational to understanding complex real-world systems such as: - Driven oscillators in engineering, - Mechanical structures under periodic stress, - Climate systems, - Electrical RLC circuits. By systematically varying parameters like the damping coefficient, driving amplitude, and frequency, the pendulum's behavior ranges from regular, synchronized oscillations to chaotic and unpredictable motion. This task aims to analyze and visualize these behaviors through theory and simulation.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"We begin with the governing differential equation of the forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega_0 \\) is the natural frequency, - \\( A \\) is the driving amplitude, - \\( \\omega \\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\( \\theta \\ll 1 \\) ), we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized version: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This can be solved analytically to explore resonance behavior and energy dynamics.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influence","text":"We examine how the following affect the system: - Damping coefficient \\( \\gamma \\) - Driving amplitude \\( A \\) - Driving frequency \\( \\omega \\)","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"Identify ranges of parameters that result in periodic , quasiperiodic , and chaotic motion. Use phase space and Poincar\u00e9 sections to visualize transitions between behaviors.","title":"Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum models real-world systems such as: - Energy harvesting devices (piezoelectric cantilevers), - Suspension bridges subjected to wind or traffic, - Driven RLC circuits in electronics, - Biomechanical systems like human gait under periodic external forces.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"","title":"4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation-plan","text":"Use numerical solvers (e.g., Runge-Kutta 4th order ) to simulate nonlinear motion. Vary initial conditions and parameters. Plot: Time series \\( \\theta(t) \\) , Phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ), Poincar\u00e9 sections, Bifurcation diagrams.","title":"Simulation Plan"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example-code-snippet","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Example Code Snippet"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"gamma = 0.5 omega0 = 1.5 A = 1.2 omega = 2.0 def pendulum(t, y): theta, dtheta = y return [dtheta, -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)]","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#initial-condition-and-time-span","text":"y0 = [0.1, 0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000)","title":"Initial condition and time span"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solve","text":"sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval)","title":"Solve"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plot","text":"plt.plot(sol.t, sol.y[0]) plt.title('Forced Damped Pendulum: \u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.grid(True) plt.show()","title":"Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Gravity Problem 1: Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental law enables the prediction of planetary motions and helps us understand gravitational interactions across the universe. By exploring this principle, we connect classical mechanics with observable astrophysical systems, such as satellite trajectories and planetary orbits. Task Theoretical Derivation Derive Kepler's Third Law for circular orbits: [ T^2 \\propto r^3 ] using Newton's Law of Gravitation and centripetal force. Astronomical Implications Discuss how this law is used to: Determine planetary masses Estimate distances between celestial bodies Understand orbital stability Real-World Examples Analyze orbits such as: The Moon orbiting Earth Planetary orbits in the Solar System Artificial satellites (e.g., GPS, ISS) Computational Simulation Implement a Python simulation to: Calculate orbital periods for various radii Visualize circular orbits Plot \\( T^2 \\) vs \\( r^3 \\) and verify linearity Deliverables \ud83d\udcc4 Markdown Report Includes derivation of Kepler\u2019s Third Law from Newtonian mechanics Discussion of astrophysical implications and extensions to elliptical orbits \ud83d\udc0d Python Script or Jupyter Notebook Simulates circular orbits using gravitational formulas Computes and plots the relationship between period and radius Validates \\( T^2 \\propto r^3 \\) \ud83d\udcca Visualizations Diagrams of orbital paths Log-log or linear plots of \\( T^2 \\) vs. \\( r^3 \\) Example comparisons using real astronomical data (e.g., Earth-Moon system) \ud83d\udd0d Discussion Section How Kepler's Law holds in elliptical orbits Generalization to systems beyond the Solar System Assumptions and limitations of circular orbit modeling Hints and Resources Use Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{r^2} ] and equate it with centripetal force: [ F = \\frac{m v^2}{r} ] Solve for \\( T \\) using: [ T = \\frac{2 \\pi r}{v} ] Plot using libraries like Matplotlib and compute with NumPy. Use SI units (mass in kg, radius in meters, time in seconds) for consistency. Optionally analyze deviations from linearity due to eccentricity or external forces.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity","text":"","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental law enables the prediction of planetary motions and helps us understand gravitational interactions across the universe. By exploring this principle, we connect classical mechanics with observable astrophysical systems, such as satellite trajectories and planetary orbits.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"Theoretical Derivation Derive Kepler's Third Law for circular orbits: [ T^2 \\propto r^3 ] using Newton's Law of Gravitation and centripetal force. Astronomical Implications Discuss how this law is used to: Determine planetary masses Estimate distances between celestial bodies Understand orbital stability Real-World Examples Analyze orbits such as: The Moon orbiting Earth Planetary orbits in the Solar System Artificial satellites (e.g., GPS, ISS) Computational Simulation Implement a Python simulation to: Calculate orbital periods for various radii Visualize circular orbits Plot \\( T^2 \\) vs \\( r^3 \\) and verify linearity","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"\ud83d\udcc4 Markdown Report Includes derivation of Kepler\u2019s Third Law from Newtonian mechanics Discussion of astrophysical implications and extensions to elliptical orbits \ud83d\udc0d Python Script or Jupyter Notebook Simulates circular orbits using gravitational formulas Computes and plots the relationship between period and radius Validates \\( T^2 \\propto r^3 \\) \ud83d\udcca Visualizations Diagrams of orbital paths Log-log or linear plots of \\( T^2 \\) vs. \\( r^3 \\) Example comparisons using real astronomical data (e.g., Earth-Moon system) \ud83d\udd0d Discussion Section How Kepler's Law holds in elliptical orbits Generalization to systems beyond the Solar System Assumptions and limitations of circular orbit modeling","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#hints-and-resources","text":"Use Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{r^2} ] and equate it with centripetal force: [ F = \\frac{m v^2}{r} ] Solve for \\( T \\) using: [ T = \\frac{2 \\pi r}{v} ] Plot using libraries like Matplotlib and compute with NumPy. Use SI units (mass in kg, radius in meters, time in seconds) for consistency. Optionally analyze deviations from linearity due to eccentricity or external forces.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2: Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task Define the first , second , and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth , Mars , and Jupiter . Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel. Deliverables A Markdown document with Python script or Jupyter notebook implementing the simulations. A detailed explanation of the subjects and their derivations. Graphical representations of escape velocities and cosmic velocities for various celestial bodies. Python Simulation Code \"\"\" `python code ` ```python import numpy as np Gravitational constant G = 6.67430e-11 # m^3/kg/s^2 Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"M\": 5.972e24, \"r\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"r\": 3.39e6}, \"Jupiter\": {\"M\": 1.898e27, \"r\": 6.9911e7} } print(\"Body\\t\\tv1 (km/s)\\tv2 (km/s)\") for body, data in bodies.items(): M = data[\"M\"] r = data[\"r\"] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) print(f\"{body:<10}\\t{v1/1000:.2f}\\t\\t{v2/1000:.2f}\") Body v1 (km/s) v2 (km/s) Earth 7.91 11.2 Mars 3.55 5.03 Jupiter 42.1 59.5 Discussion and Applications Real-World Uses First Cosmic Velocity: Launching satellites into Low Earth Orbit (LEO). Second Cosmic Velocity: Missions to the Moon, Mars, and outer planets. Third Cosmic Velocity: Required for interstellar probes like Voyager 1 and 2. Engineering Considerations Real launch speeds are higher due to atmospheric drag and non-vertical paths. Planetary rotation assists launch when launched from the equator. Missions often use gravity assists for interplanetary or interstellar speeds. Limitations and Extensions Ideal models ignore air resistance, non-spherical gravity, and planetary rotation. Relativistic corrections become important near massive objects or at high speeds. Interstellar travel requires propulsion beyond escape velocity (e.g., ion drives, solar sails). Conclusion Cosmic velocities define the energetic thresholds of space travel. From placing satellites into orbit to launching spacecraft beyond the Solar System, understanding these concepts is essential. Through theoretical analysis and computational simulations, we gain both practical and conceptual insight into the physics of gravitational escape.","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task","text":"Define the first , second , and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth , Mars , and Jupiter . Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"A Markdown document with Python script or Jupyter notebook implementing the simulations. A detailed explanation of the subjects and their derivations. Graphical representations of escape velocities and cosmic velocities for various celestial bodies.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-code","text":"\"\"\" `python code ` ```python import numpy as np","title":"Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-constant","text":"G = 6.67430e-11 # m^3/kg/s^2","title":"Gravitational constant"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-body-data-mass-in-kg-radius-in-meters","text":"bodies = { \"Earth\": {\"M\": 5.972e24, \"r\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"r\": 3.39e6}, \"Jupiter\": {\"M\": 1.898e27, \"r\": 6.9911e7} } print(\"Body\\t\\tv1 (km/s)\\tv2 (km/s)\") for body, data in bodies.items(): M = data[\"M\"] r = data[\"r\"] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) print(f\"{body:<10}\\t{v1/1000:.2f}\\t\\t{v2/1000:.2f}\") Body v1 (km/s) v2 (km/s) Earth 7.91 11.2 Mars 3.55 5.03 Jupiter 42.1 59.5 Discussion and Applications Real-World Uses First Cosmic Velocity: Launching satellites into Low Earth Orbit (LEO). Second Cosmic Velocity: Missions to the Moon, Mars, and outer planets. Third Cosmic Velocity: Required for interstellar probes like Voyager 1 and 2. Engineering Considerations Real launch speeds are higher due to atmospheric drag and non-vertical paths. Planetary rotation assists launch when launched from the equator. Missions often use gravity assists for interplanetary or interstellar speeds. Limitations and Extensions Ideal models ignore air resistance, non-spherical gravity, and planetary rotation. Relativistic corrections become important near massive objects or at high speeds. Interstellar travel requires propulsion beyond escape velocity (e.g., ion drives, solar sails). Conclusion Cosmic velocities define the energetic thresholds of space travel. From placing satellites into orbit to launching spacecraft beyond the Solar System, understanding these concepts is essential. Through theoretical analysis and computational simulations, we gain both practical and conceptual insight into the physics of gravitational escape.","title":"Celestial body data (mass in kg, radius in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario is critical for understanding orbital mechanics, with applications in space mission planning, satellite deployment, and reentry scenarios. Task Analyze possible trajectories (parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform numerical analysis to compute the payload's path based on initial conditions (position, velocity, altitude). Discuss how trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the payload's motion under Earth's gravity. Explanation of Subjects The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] where: - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) ), - \\( M \\) is Earth's mass ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), - \\( m \\) is the payload's mass, - \\( r \\) is the distance from Earth's center. The trajectory depends on the specific mechanical energy ( \\( \\epsilon \\) ): \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\( v \\) is the payload's velocity, - \\( \\mu = G M \\) is Earth's gravitational parameter ( \\( 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2} \\) ), - \\( r \\) is the radial distance. The trajectory type is determined by the eccentricity ( \\( e \\) ) of the orbit: - Elliptical ( \\( e < 1 \\) ): Closed orbit, e.g., satellite in low Earth orbit. - Parabolic ( \\( e = 1 \\) ): Escape trajectory with zero residual energy. - Hyperbolic ( \\( e > 1 \\) ): Escape trajectory with excess energy. Applications : - Orbital insertion : Achieving a stable elliptical orbit (e.g., for satellites). - Reentry : Elliptical or parabolic trajectories that intersect Earth's atmosphere. - Escape : Hyperbolic trajectories for interplanetary missions. Python Implementation The following Python script simulates the payload's motion using numerical integration (Runge-Kutta 4 method) and visualizes trajectories for different initial velocities. It assumes a 2D plane for simplicity and neglects atmospheric drag. ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth's mass (kg) mu = G * M # Gravitational parameter (m^3 s^-2) R_earth = 6.371e6 # Earth's radius (m) Equations of motion for 2D orbit def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -mu * x / r 3 ay = -mu * y / r 3 return [vx, vy, ax, ay] Compute specific energy and eccentricity def compute_orbit_params(r, v): r_mag = np.sqrt(r.dot(r)) v_mag = np.sqrt(v.dot(v)) energy = v_mag 2 / 2 - mu / r_mag h = np.cross(r, v) # Specific angular momentum (2D: scalar) e = np.sqrt(1 + (2 * energy * h 2) / mu**2) return energy, e Simulate trajectory def simulate_trajectory(initial_altitude, initial_velocity, angle_deg, t_span, t_eval): # Initial conditions r0 = [R_earth + initial_altitude, 0] # Start at (x, 0) angle = np.radians(angle_deg) v0 = [initial_velocity * np.cos(angle), initial_velocity * np.sin(angle)] # Compute initial orbit parameters energy, eccentricity = compute_orbit_params(np.array(r0), np.array(v0)) # Integrate equations of motion state0 = r0 + v0 sol = solve_ivp(equations_of_motion, t_span, state0, t_eval=t_eval, method='RK45') return sol, energy, eccentricity Plotting function def plot_trajectory(sol, energy, eccentricity, label): x, y = sol.y[0], sol.y[1] plt.plot(x / 1e6, y / 1e6, label=f'{label}, e={eccentricity:.2f}, \u03b5={energy:.2e} J/kg') # Plot Earth theta = np.linspace(0, 2 * np.pi, 100) x_earth = (R_earth / 1e6) * np.cos(theta) y_earth = (R_earth / 1e6) * np.sin(theta) plt.fill(x_earth, y_earth, 'b', alpha=0.3, label='Earth') Simulation parameters initial_altitude = 200e3 # 200 km altitude t_span = [0, 3600] # 1 hour simulation t_eval = np.linspace(0, 3600, 1000) Test different initial velocities for circular, elliptical, parabolic, and hyperbolic orbits v_circular = np.sqrt(mu / (R_earth + initial_altitude)) # Circular orbit velocity v_escape = np.sqrt(2 * mu / (R_earth + initial_altitude)) # Escape velocity velocities = [ (v_circular, 'Circular', 90), # Circular orbit (tangential) (v_circular * 0.9, 'Elliptical', 90), # Sub-circular (elliptical) (v_escape, 'Parabolic', 90), # Escape velocity (parabolic) (v_escape * 1.2, 'Hyperbolic', 90) # Above escape (hyperbolic) ] Plot setup plt.figure(figsize=(10, 8)) for v, label, angle in velocities: sol, energy, eccentricity = simulate_trajectory(initial_altitude, v, angle, t_span, t_eval) plot_trajectory(sol, energy, eccentricity, label) Finalize plot plt.xlabel('X (Mm)') plt.ylabel('Y (Mm)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.axis('equal') plt.show() Explanation of the Python Implementation Equations of Motion : The equations_of_motion function implements Newton's Law of Gravitation in 2D, computing accelerations based on the inverse-square law. Orbit Parameters : The compute_orbit_params function calculates specific mechanical energy and eccentricity to classify the trajectory. Numerical Integration : The solve_ivp function from scipy.integrate uses the RK45 method to solve the differential equations of motion. Simulation : The simulate_trajectory function sets initial conditions (position at 200 km altitude, velocity, and angle) and computes the trajectory. Visualization : The plot_trajectory function plots the payload's path and Earth's surface, with labels for eccentricity and energy. Test Cases : Four initial velocities are tested: Circular orbit velocity ( \\( v = \\sqrt{\\mu / r} \\) ). Sub-circular velocity (elliptical orbit). Escape velocity ( \\( v = \\sqrt{2 \\mu / r} \\) ). Above escape velocity (hyperbolic orbit). Dependencies numpy : For numerical computations. matplotlib : For plotting. scipy : For numerical integration. Running the Code Ensure Python and the required libraries ( numpy , matplotlib , scipy ) are installed. Copy the Python code into a .py file or Jupyter notebook. Run the script to generate a plot showing the four trajectories. Extending the Code Add 3D motion by extending the state vector and equations. Include atmospheric drag for reentry scenarios. Allow user input for initial conditions (altitude, velocity, angle). Compute orbital elements (semi-major axis, perigee, apogee) for deeper analysis. This implementation fulfills the deliverables by providing a computational tool, detailed explanations, and graphical visualizations. Let me know if you need modifications, additional features, or further clarification!","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario is critical for understanding orbital mechanics, with applications in space mission planning, satellite deployment, and reentry scenarios.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze possible trajectories (parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform numerical analysis to compute the payload's path based on initial conditions (position, velocity, altitude). Discuss how trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the payload's motion under Earth's gravity.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-subjects","text":"The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] where: - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) ), - \\( M \\) is Earth's mass ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), - \\( m \\) is the payload's mass, - \\( r \\) is the distance from Earth's center. The trajectory depends on the specific mechanical energy ( \\( \\epsilon \\) ): \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\( v \\) is the payload's velocity, - \\( \\mu = G M \\) is Earth's gravitational parameter ( \\( 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2} \\) ), - \\( r \\) is the radial distance. The trajectory type is determined by the eccentricity ( \\( e \\) ) of the orbit: - Elliptical ( \\( e < 1 \\) ): Closed orbit, e.g., satellite in low Earth orbit. - Parabolic ( \\( e = 1 \\) ): Escape trajectory with zero residual energy. - Hyperbolic ( \\( e > 1 \\) ): Escape trajectory with excess energy. Applications : - Orbital insertion : Achieving a stable elliptical orbit (e.g., for satellites). - Reentry : Elliptical or parabolic trajectories that intersect Earth's atmosphere. - Escape : Hyperbolic trajectories for interplanetary missions.","title":"Explanation of Subjects"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"The following Python script simulates the payload's motion using numerical integration (Runge-Kutta 4 method) and visualizes trajectories for different initial velocities. It assumes a 2D plane for simplicity and neglects atmospheric drag. ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth's mass (kg) mu = G * M # Gravitational parameter (m^3 s^-2) R_earth = 6.371e6 # Earth's radius (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-for-2d-orbit","text":"def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -mu * x / r 3 ay = -mu * y / r 3 return [vx, vy, ax, ay]","title":"Equations of motion for 2D orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#compute-specific-energy-and-eccentricity","text":"def compute_orbit_params(r, v): r_mag = np.sqrt(r.dot(r)) v_mag = np.sqrt(v.dot(v)) energy = v_mag 2 / 2 - mu / r_mag h = np.cross(r, v) # Specific angular momentum (2D: scalar) e = np.sqrt(1 + (2 * energy * h 2) / mu**2) return energy, e","title":"Compute specific energy and eccentricity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulate-trajectory","text":"def simulate_trajectory(initial_altitude, initial_velocity, angle_deg, t_span, t_eval): # Initial conditions r0 = [R_earth + initial_altitude, 0] # Start at (x, 0) angle = np.radians(angle_deg) v0 = [initial_velocity * np.cos(angle), initial_velocity * np.sin(angle)] # Compute initial orbit parameters energy, eccentricity = compute_orbit_params(np.array(r0), np.array(v0)) # Integrate equations of motion state0 = r0 + v0 sol = solve_ivp(equations_of_motion, t_span, state0, t_eval=t_eval, method='RK45') return sol, energy, eccentricity","title":"Simulate trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting-function","text":"def plot_trajectory(sol, energy, eccentricity, label): x, y = sol.y[0], sol.y[1] plt.plot(x / 1e6, y / 1e6, label=f'{label}, e={eccentricity:.2f}, \u03b5={energy:.2e} J/kg') # Plot Earth theta = np.linspace(0, 2 * np.pi, 100) x_earth = (R_earth / 1e6) * np.cos(theta) y_earth = (R_earth / 1e6) * np.sin(theta) plt.fill(x_earth, y_earth, 'b', alpha=0.3, label='Earth')","title":"Plotting function"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"initial_altitude = 200e3 # 200 km altitude t_span = [0, 3600] # 1 hour simulation t_eval = np.linspace(0, 3600, 1000)","title":"Simulation parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#test-different-initial-velocities-for-circular-elliptical-parabolic-and-hyperbolic-orbits","text":"v_circular = np.sqrt(mu / (R_earth + initial_altitude)) # Circular orbit velocity v_escape = np.sqrt(2 * mu / (R_earth + initial_altitude)) # Escape velocity velocities = [ (v_circular, 'Circular', 90), # Circular orbit (tangential) (v_circular * 0.9, 'Elliptical', 90), # Sub-circular (elliptical) (v_escape, 'Parabolic', 90), # Escape velocity (parabolic) (v_escape * 1.2, 'Hyperbolic', 90) # Above escape (hyperbolic) ]","title":"Test different initial velocities for circular, elliptical, parabolic, and hyperbolic orbits"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-setup","text":"plt.figure(figsize=(10, 8)) for v, label, angle in velocities: sol, energy, eccentricity = simulate_trajectory(initial_altitude, v, angle, t_span, t_eval) plot_trajectory(sol, energy, eccentricity, label)","title":"Plot setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#finalize-plot","text":"plt.xlabel('X (Mm)') plt.ylabel('Y (Mm)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.axis('equal') plt.show()","title":"Finalize plot"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-the-python-implementation","text":"Equations of Motion : The equations_of_motion function implements Newton's Law of Gravitation in 2D, computing accelerations based on the inverse-square law. Orbit Parameters : The compute_orbit_params function calculates specific mechanical energy and eccentricity to classify the trajectory. Numerical Integration : The solve_ivp function from scipy.integrate uses the RK45 method to solve the differential equations of motion. Simulation : The simulate_trajectory function sets initial conditions (position at 200 km altitude, velocity, and angle) and computes the trajectory. Visualization : The plot_trajectory function plots the payload's path and Earth's surface, with labels for eccentricity and energy. Test Cases : Four initial velocities are tested: Circular orbit velocity ( \\( v = \\sqrt{\\mu / r} \\) ). Sub-circular velocity (elliptical orbit). Escape velocity ( \\( v = \\sqrt{2 \\mu / r} \\) ). Above escape velocity (hyperbolic orbit).","title":"Explanation of the Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#dependencies","text":"numpy : For numerical computations. matplotlib : For plotting. scipy : For numerical integration.","title":"Dependencies"},{"location":"1%20Physics/2%20Gravity/Problem_3/#running-the-code","text":"Ensure Python and the required libraries ( numpy , matplotlib , scipy ) are installed. Copy the Python code into a .py file or Jupyter notebook. Run the script to generate a plot showing the four trajectories.","title":"Running the Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#extending-the-code","text":"Add 3D motion by extending the state vector and equations. Include atmospheric drag for reentry scenarios. Allow user input for initial conditions (altitude, velocity, angle). Compute orbital elements (semi-major axis, perigee, apogee) for deeper analysis. This implementation fulfills the deliverables by providing a computational tool, detailed explanations, and graphical visualizations. Let me know if you need modifications, additional features, or further clarification!","title":"Extending the Code"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}