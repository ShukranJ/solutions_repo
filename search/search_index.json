{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation 1.1 Deriving the Equations of Motion Consider a projectile launched from the origin at an initial speed \\( v_0 \\) and angle \\( \\theta \\) above the horizontal. The acceleration due to gravity is \\( g \\) downward. Horizontal motion: \\[ x(t) = v_0 \\cos\\theta \\cdot t \\] Vertical motion: \\[ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] These come from integrating the acceleration \\( \\vec{a} = (0, -g) \\) twice, with initial velocity components \\( v_0 \\cos\\theta \\) and \\( v_0 \\sin\\theta \\) . 1.2 Family of Solutions The time of flight \\( T \\) is found by setting \\( y(T) = 0 \\) (returns to launch height): \\[ v_0 \\sin\\theta \\cdot T - \\frac{1}{2} g T^2 = 0 \\quad \\Rightarrow \\quad T = \\frac{2 v_0 \\sin\\theta}{g} \\] The horizontal range \\( R \\) is: \\[ R = x(T) = v_0 \\cos\\theta \\cdot T = \\frac{v_0^2}{g} \\sin 2\\theta \\] The family of solutions depends on \\( v_0 \\) , \\( g \\) , and \\( \\theta \\) . Changing these parameters alters the shape and extent of the projectile\u2019s trajectory. 2. Analysis of the Range The range \\( R \\) is maximal when: \\[ \\sin 2\\theta = 1 \\quad \\Rightarrow \\quad 2\\theta = 90^\\circ \\quad \\Rightarrow \\quad \\theta = 45^\\circ \\] Influence of parameters: Increasing \\( v_0 \\) increases \\( R \\) quadratically. Increasing \\( g \\) decreases \\( R \\) inversely. The angle \\( \\theta \\) controls the shape of the sine function, shifting the range. 3. Practical Applications and Limitations Real-world adjustments: Launch height different from zero modifies the time of flight and range. Air resistance reduces range and alters trajectory shape. Uneven terrain complicates impact points. Extensions: Include drag force proportional to velocity. Model wind as horizontal acceleration. Use numerical integration for non-constant acceleration. 4. Implementation: Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants g = 9.81 # gravity (m/s^2) v0 = 20.0 # initial velocity (m/s) Range calculation function def projectile_range(v0, theta_deg, g=9.81): theta = np.radians(theta_deg) return (v0**2 / g) * np.sin(2 * theta) Generate angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) ranges = projectile_range(v0, angles) Plot range vs angle plt.figure(figsize=(8,5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range as a Function of Angle') plt.legend() plt.grid(True) plt.show()","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-deriving-the-equations-of-motion","text":"Consider a projectile launched from the origin at an initial speed \\( v_0 \\) and angle \\( \\theta \\) above the horizontal. The acceleration due to gravity is \\( g \\) downward. Horizontal motion: \\[ x(t) = v_0 \\cos\\theta \\cdot t \\] Vertical motion: \\[ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] These come from integrating the acceleration \\( \\vec{a} = (0, -g) \\) twice, with initial velocity components \\( v_0 \\cos\\theta \\) and \\( v_0 \\sin\\theta \\) .","title":"1.1 Deriving the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-family-of-solutions","text":"The time of flight \\( T \\) is found by setting \\( y(T) = 0 \\) (returns to launch height): \\[ v_0 \\sin\\theta \\cdot T - \\frac{1}{2} g T^2 = 0 \\quad \\Rightarrow \\quad T = \\frac{2 v_0 \\sin\\theta}{g} \\] The horizontal range \\( R \\) is: \\[ R = x(T) = v_0 \\cos\\theta \\cdot T = \\frac{v_0^2}{g} \\sin 2\\theta \\] The family of solutions depends on \\( v_0 \\) , \\( g \\) , and \\( \\theta \\) . Changing these parameters alters the shape and extent of the projectile\u2019s trajectory.","title":"1.2 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\( R \\) is maximal when: \\[ \\sin 2\\theta = 1 \\quad \\Rightarrow \\quad 2\\theta = 90^\\circ \\quad \\Rightarrow \\quad \\theta = 45^\\circ \\] Influence of parameters: Increasing \\( v_0 \\) increases \\( R \\) quadratically. Increasing \\( g \\) decreases \\( R \\) inversely. The angle \\( \\theta \\) controls the shape of the sine function, shifting the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications-and-limitations","text":"","title":"3. Practical Applications and Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-adjustments","text":"Launch height different from zero modifies the time of flight and range. Air resistance reduces range and alters trajectory shape. Uneven terrain complicates impact points.","title":"Real-world adjustments:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#extensions","text":"Include drag force proportional to velocity. Model wind as horizontal acceleration. Use numerical integration for non-constant acceleration.","title":"Extensions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"g = 9.81 # gravity (m/s^2) v0 = 20.0 # initial velocity (m/s)","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-calculation-function","text":"def projectile_range(v0, theta_deg, g=9.81): theta = np.radians(theta_deg) return (v0**2 / g) * np.sin(2 * theta)","title":"Range calculation function"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#generate-angles-from-0-to-90-degrees","text":"angles = np.linspace(0, 90, 500) ranges = projectile_range(v0, angles)","title":"Generate angles from 0 to 90 degrees"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-range-vs-angle","text":"plt.figure(figsize=(8,5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range as a Function of Angle') plt.legend() plt.grid(True) plt.show()","title":"Plot range vs angle"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena are foundational to understanding complex real-world systems such as: - Driven oscillators in engineering, - Mechanical structures under periodic stress, - Climate systems, - Electrical RLC circuits. By systematically varying parameters like the damping coefficient, driving amplitude, and frequency, the pendulum's behavior ranges from regular, synchronized oscillations to chaotic and unpredictable motion. This task aims to analyze and visualize these behaviors through theory and simulation. 1. Theoretical Foundation We begin with the governing differential equation of the forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega_0 \\) is the natural frequency, - \\( A \\) is the driving amplitude, - \\( \\omega \\) is the driving frequency. Small-Angle Approximation For small angles ( \\( \\theta \\ll 1 \\) ), we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized version: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This can be solved analytically to explore resonance behavior and energy dynamics. 2. Analysis of Dynamics Parameter Influence We examine how the following affect the system: - Damping coefficient \\( \\gamma \\) - Driving amplitude \\( A \\) - Driving frequency \\( \\omega \\) Regular vs. Chaotic Motion Identify ranges of parameters that result in periodic , quasiperiodic , and chaotic motion. Use phase space and Poincar\u00e9 sections to visualize transitions between behaviors. 3. Practical Applications The forced damped pendulum models real-world systems such as: - Energy harvesting devices (piezoelectric cantilevers), - Suspension bridges subjected to wind or traffic, - Driven RLC circuits in electronics, - Biomechanical systems like human gait under periodic external forces. 4. Implementation (Python Simulation) Simulation Plan Use numerical solvers (e.g., Runge-Kutta 4th order ) to simulate nonlinear motion. Vary initial conditions and parameters. Plot: Time series \\( \\theta(t) \\) , Phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ), Poincar\u00e9 sections, Bifurcation diagrams. Example Code Snippet ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Parameters gamma = 0.5 omega0 = 1.5 A = 1.2 omega = 2.0 def pendulum(t, y): theta, dtheta = y return [dtheta, -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] Initial condition and time span y0 = [0.1, 0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) Solve sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) Plot plt.plot(sol.t, sol.y[0]) plt.title('Forced Damped Pendulum: \u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.grid(True) plt.show()","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena are foundational to understanding complex real-world systems such as: - Driven oscillators in engineering, - Mechanical structures under periodic stress, - Climate systems, - Electrical RLC circuits. By systematically varying parameters like the damping coefficient, driving amplitude, and frequency, the pendulum's behavior ranges from regular, synchronized oscillations to chaotic and unpredictable motion. This task aims to analyze and visualize these behaviors through theory and simulation.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"We begin with the governing differential equation of the forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega_0 \\) is the natural frequency, - \\( A \\) is the driving amplitude, - \\( \\omega \\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\( \\theta \\ll 1 \\) ), we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized version: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This can be solved analytically to explore resonance behavior and energy dynamics.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influence","text":"We examine how the following affect the system: - Damping coefficient \\( \\gamma \\) - Driving amplitude \\( A \\) - Driving frequency \\( \\omega \\)","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"Identify ranges of parameters that result in periodic , quasiperiodic , and chaotic motion. Use phase space and Poincar\u00e9 sections to visualize transitions between behaviors.","title":"Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum models real-world systems such as: - Energy harvesting devices (piezoelectric cantilevers), - Suspension bridges subjected to wind or traffic, - Driven RLC circuits in electronics, - Biomechanical systems like human gait under periodic external forces.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"","title":"4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation-plan","text":"Use numerical solvers (e.g., Runge-Kutta 4th order ) to simulate nonlinear motion. Vary initial conditions and parameters. Plot: Time series \\( \\theta(t) \\) , Phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ), Poincar\u00e9 sections, Bifurcation diagrams.","title":"Simulation Plan"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example-code-snippet","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Example Code Snippet"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"gamma = 0.5 omega0 = 1.5 A = 1.2 omega = 2.0 def pendulum(t, y): theta, dtheta = y return [dtheta, -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)]","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#initial-condition-and-time-span","text":"y0 = [0.1, 0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000)","title":"Initial condition and time span"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solve","text":"sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval)","title":"Solve"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plot","text":"plt.plot(sol.t, sol.y[0]) plt.title('Forced Damped Pendulum: \u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.grid(True) plt.show()","title":"Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Gravity Problem 1: Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental law enables the prediction of planetary motions and helps us understand gravitational interactions across the universe. By exploring this principle, we connect classical mechanics with observable astrophysical systems, such as satellite trajectories and planetary orbits. Task Theoretical Derivation Derive Kepler's Third Law for circular orbits: [ T^2 \\propto r^3 ] using Newton's Law of Gravitation and centripetal force. Astronomical Implications Discuss how this law is used to: Determine planetary masses Estimate distances between celestial bodies Understand orbital stability Real-World Examples Analyze orbits such as: The Moon orbiting Earth Planetary orbits in the Solar System Artificial satellites (e.g., GPS, ISS) Computational Simulation Implement a Python simulation to: Calculate orbital periods for various radii Visualize circular orbits Plot \\( T^2 \\) vs \\( r^3 \\) and verify linearity Deliverables \ud83d\udcc4 Markdown Report Includes derivation of Kepler\u2019s Third Law from Newtonian mechanics Discussion of astrophysical implications and extensions to elliptical orbits \ud83d\udc0d Python Script or Jupyter Notebook Simulates circular orbits using gravitational formulas Computes and plots the relationship between period and radius Validates \\( T^2 \\propto r^3 \\) \ud83d\udcca Visualizations Diagrams of orbital paths Log-log or linear plots of \\( T^2 \\) vs. \\( r^3 \\) Example comparisons using real astronomical data (e.g., Earth-Moon system) \ud83d\udd0d Discussion Section How Kepler's Law holds in elliptical orbits Generalization to systems beyond the Solar System Assumptions and limitations of circular orbit modeling Hints and Resources Use Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{r^2} ] and equate it with centripetal force: [ F = \\frac{m v^2}{r} ] Solve for \\( T \\) using: [ T = \\frac{2 \\pi r}{v} ] Plot using libraries like Matplotlib and compute with NumPy. Use SI units (mass in kg, radius in meters, time in seconds) for consistency. Optionally analyze deviations from linearity due to eccentricity or external forces.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity","text":"","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental law enables the prediction of planetary motions and helps us understand gravitational interactions across the universe. By exploring this principle, we connect classical mechanics with observable astrophysical systems, such as satellite trajectories and planetary orbits.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"Theoretical Derivation Derive Kepler's Third Law for circular orbits: [ T^2 \\propto r^3 ] using Newton's Law of Gravitation and centripetal force. Astronomical Implications Discuss how this law is used to: Determine planetary masses Estimate distances between celestial bodies Understand orbital stability Real-World Examples Analyze orbits such as: The Moon orbiting Earth Planetary orbits in the Solar System Artificial satellites (e.g., GPS, ISS) Computational Simulation Implement a Python simulation to: Calculate orbital periods for various radii Visualize circular orbits Plot \\( T^2 \\) vs \\( r^3 \\) and verify linearity","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"\ud83d\udcc4 Markdown Report Includes derivation of Kepler\u2019s Third Law from Newtonian mechanics Discussion of astrophysical implications and extensions to elliptical orbits \ud83d\udc0d Python Script or Jupyter Notebook Simulates circular orbits using gravitational formulas Computes and plots the relationship between period and radius Validates \\( T^2 \\propto r^3 \\) \ud83d\udcca Visualizations Diagrams of orbital paths Log-log or linear plots of \\( T^2 \\) vs. \\( r^3 \\) Example comparisons using real astronomical data (e.g., Earth-Moon system) \ud83d\udd0d Discussion Section How Kepler's Law holds in elliptical orbits Generalization to systems beyond the Solar System Assumptions and limitations of circular orbit modeling","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#hints-and-resources","text":"Use Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{r^2} ] and equate it with centripetal force: [ F = \\frac{m v^2}{r} ] Solve for \\( T \\) using: [ T = \\frac{2 \\pi r}{v} ] Plot using libraries like Matplotlib and compute with NumPy. Use SI units (mass in kg, radius in meters, time in seconds) for consistency. Optionally analyze deviations from linearity due to eccentricity or external forces.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2: Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task Define the first , second , and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth , Mars , and Jupiter . Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel. Deliverables A Markdown document with Python script or Jupyter notebook implementing the simulations. A detailed explanation of the subjects and their derivations. Graphical representations of escape velocities and cosmic velocities for various celestial bodies. Python Simulation Code \"\"\" `python code ` ```python import numpy as np Gravitational constant G = 6.67430e-11 # m^3/kg/s^2 Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"M\": 5.972e24, \"r\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"r\": 3.39e6}, \"Jupiter\": {\"M\": 1.898e27, \"r\": 6.9911e7} } print(\"Body\\t\\tv1 (km/s)\\tv2 (km/s)\") for body, data in bodies.items(): M = data[\"M\"] r = data[\"r\"] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) print(f\"{body:<10}\\t{v1/1000:.2f}\\t\\t{v2/1000:.2f}\") Body v1 (km/s) v2 (km/s) Earth 7.91 11.2 Mars 3.55 5.03 Jupiter 42.1 59.5 Discussion and Applications Real-World Uses First Cosmic Velocity: Launching satellites into Low Earth Orbit (LEO). Second Cosmic Velocity: Missions to the Moon, Mars, and outer planets. Third Cosmic Velocity: Required for interstellar probes like Voyager 1 and 2. Engineering Considerations Real launch speeds are higher due to atmospheric drag and non-vertical paths. Planetary rotation assists launch when launched from the equator. Missions often use gravity assists for interplanetary or interstellar speeds. Limitations and Extensions Ideal models ignore air resistance, non-spherical gravity, and planetary rotation. Relativistic corrections become important near massive objects or at high speeds. Interstellar travel requires propulsion beyond escape velocity (e.g., ion drives, solar sails). Conclusion Cosmic velocities define the energetic thresholds of space travel. From placing satellites into orbit to launching spacecraft beyond the Solar System, understanding these concepts is essential. Through theoretical analysis and computational simulations, we gain both practical and conceptual insight into the physics of gravitational escape.","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task","text":"Define the first , second , and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth , Mars , and Jupiter . Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"A Markdown document with Python script or Jupyter notebook implementing the simulations. A detailed explanation of the subjects and their derivations. Graphical representations of escape velocities and cosmic velocities for various celestial bodies.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-code","text":"\"\"\" `python code ` ```python import numpy as np","title":"Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-constant","text":"G = 6.67430e-11 # m^3/kg/s^2","title":"Gravitational constant"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-body-data-mass-in-kg-radius-in-meters","text":"bodies = { \"Earth\": {\"M\": 5.972e24, \"r\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"r\": 3.39e6}, \"Jupiter\": {\"M\": 1.898e27, \"r\": 6.9911e7} } print(\"Body\\t\\tv1 (km/s)\\tv2 (km/s)\") for body, data in bodies.items(): M = data[\"M\"] r = data[\"r\"] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) print(f\"{body:<10}\\t{v1/1000:.2f}\\t\\t{v2/1000:.2f}\") Body v1 (km/s) v2 (km/s) Earth 7.91 11.2 Mars 3.55 5.03 Jupiter 42.1 59.5 Discussion and Applications Real-World Uses First Cosmic Velocity: Launching satellites into Low Earth Orbit (LEO). Second Cosmic Velocity: Missions to the Moon, Mars, and outer planets. Third Cosmic Velocity: Required for interstellar probes like Voyager 1 and 2. Engineering Considerations Real launch speeds are higher due to atmospheric drag and non-vertical paths. Planetary rotation assists launch when launched from the equator. Missions often use gravity assists for interplanetary or interstellar speeds. Limitations and Extensions Ideal models ignore air resistance, non-spherical gravity, and planetary rotation. Relativistic corrections become important near massive objects or at high speeds. Interstellar travel requires propulsion beyond escape velocity (e.g., ion drives, solar sails). Conclusion Cosmic velocities define the energetic thresholds of space travel. From placing satellites into orbit to launching spacecraft beyond the Solar System, understanding these concepts is essential. Through theoretical analysis and computational simulations, we gain both practical and conceptual insight into the physics of gravitational escape.","title":"Celestial body data (mass in kg, radius in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario is critical for understanding orbital mechanics, with applications in space mission planning, satellite deployment, and reentry scenarios. Task Analyze possible trajectories (parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform numerical analysis to compute the payload's path based on initial conditions (position, velocity, altitude). Discuss how trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the payload's motion under Earth's gravity. Explanation of Subjects The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] where: - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) ), - \\( M \\) is Earth's mass ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), - \\( m \\) is the payload's mass, - \\( r \\) is the distance from Earth's center. The trajectory depends on the specific mechanical energy ( \\( \\epsilon \\) ): \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\( v \\) is the payload's velocity, - \\( \\mu = G M \\) is Earth's gravitational parameter ( \\( 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2} \\) ), - \\( r \\) is the radial distance. The trajectory type is determined by the eccentricity ( \\( e \\) ) of the orbit: - Elliptical ( \\( e < 1 \\) ): Closed orbit, e.g., satellite in low Earth orbit. - Parabolic ( \\( e = 1 \\) ): Escape trajectory with zero residual energy. - Hyperbolic ( \\( e > 1 \\) ): Escape trajectory with excess energy. Applications : - Orbital insertion : Achieving a stable elliptical orbit (e.g., for satellites). - Reentry : Elliptical or parabolic trajectories that intersect Earth's atmosphere. - Escape : Hyperbolic trajectories for interplanetary missions. Python Implementation The following Python script simulates the payload's motion using numerical integration (Runge-Kutta 4 method) and visualizes trajectories for different initial velocities. It assumes a 2D plane for simplicity and neglects atmospheric drag. ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth's mass (kg) mu = G * M # Gravitational parameter (m^3 s^-2) R_earth = 6.371e6 # Earth's radius (m) Equations of motion for 2D orbit def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -mu * x / r 3 ay = -mu * y / r 3 return [vx, vy, ax, ay] Compute specific energy and eccentricity def compute_orbit_params(r, v): r_mag = np.sqrt(r.dot(r)) v_mag = np.sqrt(v.dot(v)) energy = v_mag 2 / 2 - mu / r_mag h = np.cross(r, v) # Specific angular momentum (2D: scalar) e = np.sqrt(1 + (2 * energy * h 2) / mu**2) return energy, e Simulate trajectory def simulate_trajectory(initial_altitude, initial_velocity, angle_deg, t_span, t_eval): # Initial conditions r0 = [R_earth + initial_altitude, 0] # Start at (x, 0) angle = np.radians(angle_deg) v0 = [initial_velocity * np.cos(angle), initial_velocity * np.sin(angle)] # Compute initial orbit parameters energy, eccentricity = compute_orbit_params(np.array(r0), np.array(v0)) # Integrate equations of motion state0 = r0 + v0 sol = solve_ivp(equations_of_motion, t_span, state0, t_eval=t_eval, method='RK45') return sol, energy, eccentricity Plotting function def plot_trajectory(sol, energy, eccentricity, label): x, y = sol.y[0], sol.y[1] plt.plot(x / 1e6, y / 1e6, label=f'{label}, e={eccentricity:.2f}, \u03b5={energy:.2e} J/kg') # Plot Earth theta = np.linspace(0, 2 * np.pi, 100) x_earth = (R_earth / 1e6) * np.cos(theta) y_earth = (R_earth / 1e6) * np.sin(theta) plt.fill(x_earth, y_earth, 'b', alpha=0.3, label='Earth') Simulation parameters initial_altitude = 200e3 # 200 km altitude t_span = [0, 3600] # 1 hour simulation t_eval = np.linspace(0, 3600, 1000) Test different initial velocities for circular, elliptical, parabolic, and hyperbolic orbits v_circular = np.sqrt(mu / (R_earth + initial_altitude)) # Circular orbit velocity v_escape = np.sqrt(2 * mu / (R_earth + initial_altitude)) # Escape velocity velocities = [ (v_circular, 'Circular', 90), # Circular orbit (tangential) (v_circular * 0.9, 'Elliptical', 90), # Sub-circular (elliptical) (v_escape, 'Parabolic', 90), # Escape velocity (parabolic) (v_escape * 1.2, 'Hyperbolic', 90) # Above escape (hyperbolic) ] Plot setup plt.figure(figsize=(10, 8)) for v, label, angle in velocities: sol, energy, eccentricity = simulate_trajectory(initial_altitude, v, angle, t_span, t_eval) plot_trajectory(sol, energy, eccentricity, label) Finalize plot plt.xlabel('X (Mm)') plt.ylabel('Y (Mm)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.axis('equal') plt.show()","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario is critical for understanding orbital mechanics, with applications in space mission planning, satellite deployment, and reentry scenarios.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze possible trajectories (parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform numerical analysis to compute the payload's path based on initial conditions (position, velocity, altitude). Discuss how trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the payload's motion under Earth's gravity.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-subjects","text":"The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] where: - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) ), - \\( M \\) is Earth's mass ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), - \\( m \\) is the payload's mass, - \\( r \\) is the distance from Earth's center. The trajectory depends on the specific mechanical energy ( \\( \\epsilon \\) ): \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r} \\] where: - \\( v \\) is the payload's velocity, - \\( \\mu = G M \\) is Earth's gravitational parameter ( \\( 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2} \\) ), - \\( r \\) is the radial distance. The trajectory type is determined by the eccentricity ( \\( e \\) ) of the orbit: - Elliptical ( \\( e < 1 \\) ): Closed orbit, e.g., satellite in low Earth orbit. - Parabolic ( \\( e = 1 \\) ): Escape trajectory with zero residual energy. - Hyperbolic ( \\( e > 1 \\) ): Escape trajectory with excess energy. Applications : - Orbital insertion : Achieving a stable elliptical orbit (e.g., for satellites). - Reentry : Elliptical or parabolic trajectories that intersect Earth's atmosphere. - Escape : Hyperbolic trajectories for interplanetary missions.","title":"Explanation of Subjects"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"The following Python script simulates the payload's motion using numerical integration (Runge-Kutta 4 method) and visualizes trajectories for different initial velocities. It assumes a 2D plane for simplicity and neglects atmospheric drag. ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Earth's mass (kg) mu = G * M # Gravitational parameter (m^3 s^-2) R_earth = 6.371e6 # Earth's radius (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-for-2d-orbit","text":"def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -mu * x / r 3 ay = -mu * y / r 3 return [vx, vy, ax, ay]","title":"Equations of motion for 2D orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#compute-specific-energy-and-eccentricity","text":"def compute_orbit_params(r, v): r_mag = np.sqrt(r.dot(r)) v_mag = np.sqrt(v.dot(v)) energy = v_mag 2 / 2 - mu / r_mag h = np.cross(r, v) # Specific angular momentum (2D: scalar) e = np.sqrt(1 + (2 * energy * h 2) / mu**2) return energy, e","title":"Compute specific energy and eccentricity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulate-trajectory","text":"def simulate_trajectory(initial_altitude, initial_velocity, angle_deg, t_span, t_eval): # Initial conditions r0 = [R_earth + initial_altitude, 0] # Start at (x, 0) angle = np.radians(angle_deg) v0 = [initial_velocity * np.cos(angle), initial_velocity * np.sin(angle)] # Compute initial orbit parameters energy, eccentricity = compute_orbit_params(np.array(r0), np.array(v0)) # Integrate equations of motion state0 = r0 + v0 sol = solve_ivp(equations_of_motion, t_span, state0, t_eval=t_eval, method='RK45') return sol, energy, eccentricity","title":"Simulate trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting-function","text":"def plot_trajectory(sol, energy, eccentricity, label): x, y = sol.y[0], sol.y[1] plt.plot(x / 1e6, y / 1e6, label=f'{label}, e={eccentricity:.2f}, \u03b5={energy:.2e} J/kg') # Plot Earth theta = np.linspace(0, 2 * np.pi, 100) x_earth = (R_earth / 1e6) * np.cos(theta) y_earth = (R_earth / 1e6) * np.sin(theta) plt.fill(x_earth, y_earth, 'b', alpha=0.3, label='Earth')","title":"Plotting function"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"initial_altitude = 200e3 # 200 km altitude t_span = [0, 3600] # 1 hour simulation t_eval = np.linspace(0, 3600, 1000)","title":"Simulation parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#test-different-initial-velocities-for-circular-elliptical-parabolic-and-hyperbolic-orbits","text":"v_circular = np.sqrt(mu / (R_earth + initial_altitude)) # Circular orbit velocity v_escape = np.sqrt(2 * mu / (R_earth + initial_altitude)) # Escape velocity velocities = [ (v_circular, 'Circular', 90), # Circular orbit (tangential) (v_circular * 0.9, 'Elliptical', 90), # Sub-circular (elliptical) (v_escape, 'Parabolic', 90), # Escape velocity (parabolic) (v_escape * 1.2, 'Hyperbolic', 90) # Above escape (hyperbolic) ]","title":"Test different initial velocities for circular, elliptical, parabolic, and hyperbolic orbits"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-setup","text":"plt.figure(figsize=(10, 8)) for v, label, angle in velocities: sol, energy, eccentricity = simulate_trajectory(initial_altitude, v, angle, t_span, t_eval) plot_trajectory(sol, energy, eccentricity, label)","title":"Plot setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#finalize-plot","text":"plt.xlabel('X (Mm)') plt.ylabel('Y (Mm)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.axis('equal') plt.show()","title":"Finalize plot"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}