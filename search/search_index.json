{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1: Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, provides a rich framework for exploring core principles of physics. Despite the apparent simplicity of launching an object into the air, the underlying physics involves various interacting parameters: Initial velocity : \\( v_0 \\) Gravitational acceleration : \\( g \\) Launch angle : \\( \\theta \\) These variables result in a wide variety of possible trajectories, modeling real-world phenomena from sports to spacecraft dynamics. Theoretical Background Assume an object is launched from flat ground with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) above the horizontal, and neglect air resistance. Equations of Motion Horizontal position : [ x(t) = v_0 \\cos(\\theta) \\cdot t ] Vertical position : [ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 ] Time of Flight The projectile returns to the ground when \\( y(t) = 0 \\) : \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range Equation Substitute time of flight into the horizontal equation to find range: \\[ R = v_0 \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This expression defines a family of solutions depending on: - \\( v_0 \\) : launch speed - \\( \\theta \\) : launch angle - \\( g \\) : local gravity Maximum range is achieved when \\( \\theta = 45^\\circ \\) , since \\( \\sin(2\\theta) \\) reaches its maximum of 1. Analysis of Range Behavior Parameter Influence Velocity : \\( R \\propto v_0^2 \\) \u2192 doubling speed quadruples the range. Gravity : \\( R \\propto \\frac{1}{g} \\) \u2192 lower gravity increases range. Symmetry The range is symmetric around \\( \\theta = 45^\\circ \\) . Angles \\( \\theta \\) and \\( 90^\\circ - \\theta \\) yield the same range. Practical Applications This model applies to real-world phenomena such as: Sports : Ball trajectories in football, basketball, etc. Engineering : Calculations in artillery or construction. Astrophysics : Trajectories of planetary probes and landers. Extensions Uneven launch and landing heights. Air resistance (drag). Wind and rotational effects (e.g., Coriolis force). Python Simulation ```python import numpy as np import matplotlib.pyplot as plt --- Constants --- g = 9.81 # Acceleration due to gravity (m/s\u00b2) v0 = 30 # Initial velocity (m/s) --- Angles from 0 to 90 degrees --- angles_deg = np.linspace(0, 90, 500) # 500 points from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) # Convert to radians for computation --- Range Calculation --- R = (v0**2) * np.sin(2 * angles_rad) / g # R = (v\u2080\u00b2 * sin(2\u03b8)) / g --- Plotting --- plt.figure(figsize=(10, 6)) plt.plot(angles_deg, R, color='navy', label=f'v\u2080 = {v0} m/s') plt.axvline(45, color='red', linestyle='--', label='Maximum at 45\u00b0') plt.title('Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show() \u2705 Explanation: np.linspace(0, 90, 500) : Generates 500 evenly spaced angles between 0\u00b0 and 90\u00b0. np.radians(...) : Converts degrees to radians since np.sin() expects radians. R = (v0**2) * np.sin(2 * \u03b8) / g : Formula for range of projectile on flat ground. plt.axvline(45, ...) : Highlights the theoretical maximum range at 45\u00b0.","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, provides a rich framework for exploring core principles of physics. Despite the apparent simplicity of launching an object into the air, the underlying physics involves various interacting parameters: Initial velocity : \\( v_0 \\) Gravitational acceleration : \\( g \\) Launch angle : \\( \\theta \\) These variables result in a wide variety of possible trajectories, modeling real-world phenomena from sports to spacecraft dynamics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-background","text":"Assume an object is launched from flat ground with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) above the horizontal, and neglect air resistance.","title":"Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal position : [ x(t) = v_0 \\cos(\\theta) \\cdot t ] Vertical position : [ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 ]","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile returns to the ground when \\( y(t) = 0 \\) : \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"Substitute time of flight into the horizontal equation to find range: \\[ R = v_0 \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This expression defines a family of solutions depending on: - \\( v_0 \\) : launch speed - \\( \\theta \\) : launch angle - \\( g \\) : local gravity Maximum range is achieved when \\( \\theta = 45^\\circ \\) , since \\( \\sin(2\\theta) \\) reaches its maximum of 1.","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-range-behavior","text":"","title":"Analysis of Range Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-influence","text":"Velocity : \\( R \\propto v_0^2 \\) \u2192 doubling speed quadruples the range. Gravity : \\( R \\propto \\frac{1}{g} \\) \u2192 lower gravity increases range.","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#symmetry","text":"The range is symmetric around \\( \\theta = 45^\\circ \\) . Angles \\( \\theta \\) and \\( 90^\\circ - \\theta \\) yield the same range.","title":"Symmetry"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"This model applies to real-world phenomena such as: Sports : Ball trajectories in football, basketball, etc. Engineering : Calculations in artillery or construction. Astrophysics : Trajectories of planetary probes and landers.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#extensions","text":"Uneven launch and landing heights. Air resistance (drag). Wind and rotational effects (e.g., Coriolis force).","title":"Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#-constants-","text":"g = 9.81 # Acceleration due to gravity (m/s\u00b2) v0 = 30 # Initial velocity (m/s)","title":"--- Constants ---"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#-angles-from-0-to-90-degrees-","text":"angles_deg = np.linspace(0, 90, 500) # 500 points from 0\u00b0 to 90\u00b0 angles_rad = np.radians(angles_deg) # Convert to radians for computation","title":"--- Angles from 0 to 90 degrees ---"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#-range-calculation-","text":"R = (v0**2) * np.sin(2 * angles_rad) / g # R = (v\u2080\u00b2 * sin(2\u03b8)) / g","title":"--- Range Calculation ---"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#-plotting-","text":"plt.figure(figsize=(10, 6)) plt.plot(angles_deg, R, color='navy', label=f'v\u2080 = {v0} m/s') plt.axvline(45, color='red', linestyle='--', label='Maximum at 45\u00b0') plt.title('Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"--- Plotting ---"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation","text":"np.linspace(0, 90, 500) : Generates 500 evenly spaced angles between 0\u00b0 and 90\u00b0. np.radians(...) : Converts degrees to radians since np.sin() expects radians. R = (v0**2) * np.sin(2 * \u03b8) / g : Formula for range of projectile on flat ground. plt.axvline(45, ...) : Highlights the theoretical maximum range at 45\u00b0.","title":"\u2705 Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena are foundational to understanding complex real-world systems such as: - Driven oscillators in engineering, - Mechanical structures under periodic stress, - Climate systems, - Electrical RLC circuits. By systematically varying parameters like the damping coefficient, driving amplitude, and frequency, the pendulum's behavior ranges from regular, synchronized oscillations to chaotic and unpredictable motion. This task aims to analyze and visualize these behaviors through theory and simulation. 1. Theoretical Foundation We begin with the governing differential equation of the forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega_0 \\) is the natural frequency, - \\( A \\) is the driving amplitude, - \\( \\omega \\) is the driving frequency. Small-Angle Approximation For small angles ( \\( \\theta \\ll 1 \\) ), we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized version: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This can be solved analytically to explore resonance behavior and energy dynamics. 2. Analysis of Dynamics Parameter Influence We examine how the following affect the system: - Damping coefficient \\( \\gamma \\) - Driving amplitude \\( A \\) - Driving frequency \\( \\omega \\) Regular vs. Chaotic Motion Identify ranges of parameters that result in periodic , quasiperiodic , and chaotic motion. Use phase space and Poincar\u00e9 sections to visualize transitions between behaviors. 3. Practical Applications The forced damped pendulum models real-world systems such as: - Energy harvesting devices (piezoelectric cantilevers), - Suspension bridges subjected to wind or traffic, - Driven RLC circuits in electronics, - Biomechanical systems like human gait under periodic external forces. 4. Implementation (Python Simulation) Simulation Plan Use numerical solvers (e.g., Runge-Kutta 4th order ) to simulate nonlinear motion. Vary initial conditions and parameters. Plot: Time series \\( \\theta(t) \\) , Phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ), Poincar\u00e9 sections, Bifurcation diagrams. Example Code Snippet ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Parameters gamma = 0.5 omega0 = 1.5 A = 1.2 omega = 2.0 def pendulum(t, y): theta, dtheta = y return [dtheta, -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] Initial condition and time span y0 = [0.1, 0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) Solve sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) Plot plt.plot(sol.t, sol.y[0]) plt.title('Forced Damped Pendulum: \u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.grid(True) plt.show()","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena are foundational to understanding complex real-world systems such as: - Driven oscillators in engineering, - Mechanical structures under periodic stress, - Climate systems, - Electrical RLC circuits. By systematically varying parameters like the damping coefficient, driving amplitude, and frequency, the pendulum's behavior ranges from regular, synchronized oscillations to chaotic and unpredictable motion. This task aims to analyze and visualize these behaviors through theory and simulation.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"We begin with the governing differential equation of the forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega_0 \\) is the natural frequency, - \\( A \\) is the driving amplitude, - \\( \\omega \\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\( \\theta \\ll 1 \\) ), we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized version: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This can be solved analytically to explore resonance behavior and energy dynamics.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influence","text":"We examine how the following affect the system: - Damping coefficient \\( \\gamma \\) - Driving amplitude \\( A \\) - Driving frequency \\( \\omega \\)","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"Identify ranges of parameters that result in periodic , quasiperiodic , and chaotic motion. Use phase space and Poincar\u00e9 sections to visualize transitions between behaviors.","title":"Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum models real-world systems such as: - Energy harvesting devices (piezoelectric cantilevers), - Suspension bridges subjected to wind or traffic, - Driven RLC circuits in electronics, - Biomechanical systems like human gait under periodic external forces.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"","title":"4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation-plan","text":"Use numerical solvers (e.g., Runge-Kutta 4th order ) to simulate nonlinear motion. Vary initial conditions and parameters. Plot: Time series \\( \\theta(t) \\) , Phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ), Poincar\u00e9 sections, Bifurcation diagrams.","title":"Simulation Plan"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example-code-snippet","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Example Code Snippet"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"gamma = 0.5 omega0 = 1.5 A = 1.2 omega = 2.0 def pendulum(t, y): theta, dtheta = y return [dtheta, -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)]","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#initial-condition-and-time-span","text":"y0 = [0.1, 0] t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000)","title":"Initial condition and time span"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solve","text":"sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval)","title":"Solve"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plot","text":"plt.plot(sol.t, sol.y[0]) plt.title('Forced Damped Pendulum: \u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.grid(True) plt.show()","title":"Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Gravity Problem 1: Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental law enables the prediction of planetary motions and helps us understand gravitational interactions across the universe. By exploring this principle, we connect classical mechanics with observable astrophysical systems, such as satellite trajectories and planetary orbits. Task Theoretical Derivation Derive Kepler's Third Law for circular orbits: [ T^2 \\propto r^3 ] using Newton's Law of Gravitation and centripetal force. Astronomical Implications Discuss how this law is used to: Determine planetary masses Estimate distances between celestial bodies Understand orbital stability Real-World Examples Analyze orbits such as: The Moon orbiting Earth Planetary orbits in the Solar System Artificial satellites (e.g., GPS, ISS) Computational Simulation Implement a Python simulation to: Calculate orbital periods for various radii Visualize circular orbits Plot \\( T^2 \\) vs \\( r^3 \\) and verify linearity Deliverables \ud83d\udcc4 Markdown Report Includes derivation of Kepler\u2019s Third Law from Newtonian mechanics Discussion of astrophysical implications and extensions to elliptical orbits \ud83d\udc0d Python Script or Jupyter Notebook Simulates circular orbits using gravitational formulas Computes and plots the relationship between period and radius Validates \\( T^2 \\propto r^3 \\) \ud83d\udcca Visualizations Diagrams of orbital paths Log-log or linear plots of \\( T^2 \\) vs. \\( r^3 \\) Example comparisons using real astronomical data (e.g., Earth-Moon system) \ud83d\udd0d Discussion Section How Kepler's Law holds in elliptical orbits Generalization to systems beyond the Solar System Assumptions and limitations of circular orbit modeling Hints and Resources Use Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{r^2} ] and equate it with centripetal force: [ F = \\frac{m v^2}{r} ] Solve for \\( T \\) using: [ T = \\frac{2 \\pi r}{v} ] Plot using libraries like Matplotlib and compute with NumPy. Use SI units (mass in kg, radius in meters, time in seconds) for consistency. Optionally analyze deviations from linearity due to eccentricity or external forces.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity","text":"","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental law enables the prediction of planetary motions and helps us understand gravitational interactions across the universe. By exploring this principle, we connect classical mechanics with observable astrophysical systems, such as satellite trajectories and planetary orbits.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"Theoretical Derivation Derive Kepler's Third Law for circular orbits: [ T^2 \\propto r^3 ] using Newton's Law of Gravitation and centripetal force. Astronomical Implications Discuss how this law is used to: Determine planetary masses Estimate distances between celestial bodies Understand orbital stability Real-World Examples Analyze orbits such as: The Moon orbiting Earth Planetary orbits in the Solar System Artificial satellites (e.g., GPS, ISS) Computational Simulation Implement a Python simulation to: Calculate orbital periods for various radii Visualize circular orbits Plot \\( T^2 \\) vs \\( r^3 \\) and verify linearity","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"\ud83d\udcc4 Markdown Report Includes derivation of Kepler\u2019s Third Law from Newtonian mechanics Discussion of astrophysical implications and extensions to elliptical orbits \ud83d\udc0d Python Script or Jupyter Notebook Simulates circular orbits using gravitational formulas Computes and plots the relationship between period and radius Validates \\( T^2 \\propto r^3 \\) \ud83d\udcca Visualizations Diagrams of orbital paths Log-log or linear plots of \\( T^2 \\) vs. \\( r^3 \\) Example comparisons using real astronomical data (e.g., Earth-Moon system) \ud83d\udd0d Discussion Section How Kepler's Law holds in elliptical orbits Generalization to systems beyond the Solar System Assumptions and limitations of circular orbit modeling","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#hints-and-resources","text":"Use Newton\u2019s Law of Gravitation: [ F = \\frac{G M m}{r^2} ] and equate it with centripetal force: [ F = \\frac{m v^2}{r} ] Solve for \\( T \\) using: [ T = \\frac{2 \\pi r}{v} ] Plot using libraries like Matplotlib and compute with NumPy. Use SI units (mass in kg, radius in meters, time in seconds) for consistency. Optionally analyze deviations from linearity due to eccentricity or external forces.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2: Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task Define the first , second , and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth , Mars , and Jupiter . Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel. Deliverables A Markdown document with Python script or Jupyter notebook implementing the simulations. A detailed explanation of the subjects and their derivations. Graphical representations of escape velocities and cosmic velocities for various celestial bodies. Python Simulation Code \"\"\" `python code ` ```python import numpy as np Gravitational constant G = 6.67430e-11 # m^3/kg/s^2 Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"M\": 5.972e24, \"r\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"r\": 3.39e6}, \"Jupiter\": {\"M\": 1.898e27, \"r\": 6.9911e7} } print(\"Body\\t\\tv1 (km/s)\\tv2 (km/s)\") for body, data in bodies.items(): M = data[\"M\"] r = data[\"r\"] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) print(f\"{body:<10}\\t{v1/1000:.2f}\\t\\t{v2/1000:.2f}\") Body v1 (km/s) v2 (km/s) Earth 7.91 11.2 Mars 3.55 5.03 Jupiter 42.1 59.5 Discussion and Applications Real-World Uses First Cosmic Velocity: Launching satellites into Low Earth Orbit (LEO). Second Cosmic Velocity: Missions to the Moon, Mars, and outer planets. Third Cosmic Velocity: Required for interstellar probes like Voyager 1 and 2. Engineering Considerations Real launch speeds are higher due to atmospheric drag and non-vertical paths. Planetary rotation assists launch when launched from the equator. Missions often use gravity assists for interplanetary or interstellar speeds. Limitations and Extensions Ideal models ignore air resistance, non-spherical gravity, and planetary rotation. Relativistic corrections become important near massive objects or at high speeds. Interstellar travel requires propulsion beyond escape velocity (e.g., ion drives, solar sails). Conclusion Cosmic velocities define the energetic thresholds of space travel. From placing satellites into orbit to launching spacecraft beyond the Solar System, understanding these concepts is essential. Through theoretical analysis and computational simulations, we gain both practical and conceptual insight into the physics of gravitational escape.","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task","text":"Define the first , second , and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth , Mars , and Jupiter . Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"A Markdown document with Python script or Jupyter notebook implementing the simulations. A detailed explanation of the subjects and their derivations. Graphical representations of escape velocities and cosmic velocities for various celestial bodies.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-code","text":"\"\"\" `python code ` ```python import numpy as np","title":"Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-constant","text":"G = 6.67430e-11 # m^3/kg/s^2","title":"Gravitational constant"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-body-data-mass-in-kg-radius-in-meters","text":"bodies = { \"Earth\": {\"M\": 5.972e24, \"r\": 6.371e6}, \"Mars\": {\"M\": 6.39e23, \"r\": 3.39e6}, \"Jupiter\": {\"M\": 1.898e27, \"r\": 6.9911e7} } print(\"Body\\t\\tv1 (km/s)\\tv2 (km/s)\") for body, data in bodies.items(): M = data[\"M\"] r = data[\"r\"] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) print(f\"{body:<10}\\t{v1/1000:.2f}\\t\\t{v2/1000:.2f}\") Body v1 (km/s) v2 (km/s) Earth 7.91 11.2 Mars 3.55 5.03 Jupiter 42.1 59.5 Discussion and Applications Real-World Uses First Cosmic Velocity: Launching satellites into Low Earth Orbit (LEO). Second Cosmic Velocity: Missions to the Moon, Mars, and outer planets. Third Cosmic Velocity: Required for interstellar probes like Voyager 1 and 2. Engineering Considerations Real launch speeds are higher due to atmospheric drag and non-vertical paths. Planetary rotation assists launch when launched from the equator. Missions often use gravity assists for interplanetary or interstellar speeds. Limitations and Extensions Ideal models ignore air resistance, non-spherical gravity, and planetary rotation. Relativistic corrections become important near massive objects or at high speeds. Interstellar travel requires propulsion beyond escape velocity (e.g., ion drives, solar sails). Conclusion Cosmic velocities define the energetic thresholds of space travel. From placing satellites into orbit to launching spacecraft beyond the Solar System, understanding these concepts is essential. Through theoretical analysis and computational simulations, we gain both practical and conceptual insight into the physics of gravitational escape.","title":"Celestial body data (mass in kg, radius in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth 1. Background & Physics Principles Newton's Law of Gravitation The gravitational force acting on the payload near Earth is: \\[ \\mathbf{F} = - \\frac{GMm}{r^2} \\hat{r} \\] where \\(G = 6.67430 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2}\\) is the gravitational constant, \\(M = 5.972 \\times 10^{24} \\, kg\\) is Earth's mass, \\(m\\) is the payload mass, \\(r\\) is the distance from Earth's center, \\(\\hat{r}\\) is the unit vector from Earth\u2019s center to the payload. The acceleration due to Earth's gravity is: \\[ \\mathbf{a} = - \\frac{GM}{r^3} \\mathbf{r} \\] Equations of Motion The motion of the payload under gravity satisfies: \\[ \\frac{d^2 \\mathbf{r}}{dt^2} = - \\frac{GM}{r^3} \\mathbf{r} \\] Given initial conditions \\(\\mathbf{r}_0\\) and \\(\\mathbf{v}_0\\) , the trajectory is computed numerically. 2. Types of Trajectories The shape of the trajectory depends on the total specific mechanical energy \\(E\\) : \\[ E = \\frac{v^2}{2} - \\frac{GM}{r} \\] Elliptical orbit: \\(E < 0\\) (bound orbit), Parabolic trajectory: \\(E = 0\\) (escape velocity), Hyperbolic trajectory: \\(E > 0\\) (unbound, escape path). 3. Numerical Simulation Method We solve the second-order ODE using numerical integration (e.g., RK4): Initial conditions: \\(\\mathbf{r}_0\\) , \\(\\mathbf{v}_0\\) , Update position and velocity at each timestep \\(\\Delta t\\) , Continue until simulation time ends or payload hits Earth. import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6371e3 # Earth radius in meters Simulation parameters dt = 1.0 # time step in seconds t_max = 20000 # max simulation time in seconds Initial conditions altitude = 500e3 # 500 km above Earth surface r0 = np.array([R_earth + altitude, 0.0]) # initial position (x,y) v_circular = np.sqrt(G * M / np.linalg.norm(r0)) # circular orbit velocity Set initial velocity: 10% faster than circular velocity (example) v0 = np.array([0.0, 1.1 * v_circular]) Initialize state variables r = r0.copy() v = v0.copy() positions = [] velocities = [] times = [] def acceleration(r): r_norm = np.linalg.norm(r) return -G * M * r / r_norm**3 t = 0 while t < t_max: # Record data positions.append(r.copy()) velocities.append(v.copy()) times.append(t) # RK4 integration steps a1 = acceleration(r) k1v = a1 * dt k1r = v * dt a2 = acceleration(r + 0.5 * k1r) k2v = a2 * dt k2r = (v + 0.5 * k1v) * dt a3 = acceleration(r + 0.5 * k2r) k3v = a3 * dt k3r = (v + 0.5 * k2v) * dt a4 = acceleration(r + k3r) k4v = a4 * dt k4r = (v + k3v) * dt # Update velocity and position v += (k1v + 2*k2v + 2*k3v + k4v) / 6 r += (k1r + 2*k2r + 2*k3r + k4r) / 6 # Stop if payload hits Earth's surface if np.linalg.norm(r) <= R_earth: print(f\"Payload hit Earth surface at t={t:.2f} seconds\") break t += dt positions = np.array(positions) velocities = np.array(velocities) times = np.array(times) Plot trajectory plt.figure(figsize=(8,8)) earth = plt.Circle((0,0), R_earth, color='b', alpha=0.3) plt.gca().add_patch(earth) plt.plot(positions[:,0], positions[:,1], label=\"Payload Trajectory\") plt.scatter([r0[0]], [r0[1]], color='green', label='Initial Position') plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectory Near Earth') plt.legend() plt.grid() plt.show() Plot energy over time speeds = np.linalg.norm(velocities, axis=1) radii = np.linalg.norm(positions, axis=1) energy = 0.5 * speeds**2 - G * M / radii plt.figure() plt.plot(times, energy) plt.xlabel('Time (s)') plt.ylabel('Specific Mechanical Energy (J/kg)') plt.title('Energy vs Time (should be roughly constant)') plt.grid() plt.show()","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-background-physics-principles","text":"","title":"1. Background &amp; Physics Principles"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The gravitational force acting on the payload near Earth is: \\[ \\mathbf{F} = - \\frac{GMm}{r^2} \\hat{r} \\] where \\(G = 6.67430 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2}\\) is the gravitational constant, \\(M = 5.972 \\times 10^{24} \\, kg\\) is Earth's mass, \\(m\\) is the payload mass, \\(r\\) is the distance from Earth's center, \\(\\hat{r}\\) is the unit vector from Earth\u2019s center to the payload. The acceleration due to Earth's gravity is: \\[ \\mathbf{a} = - \\frac{GM}{r^3} \\mathbf{r} \\]","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"The motion of the payload under gravity satisfies: \\[ \\frac{d^2 \\mathbf{r}}{dt^2} = - \\frac{GM}{r^3} \\mathbf{r} \\] Given initial conditions \\(\\mathbf{r}_0\\) and \\(\\mathbf{v}_0\\) , the trajectory is computed numerically.","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-types-of-trajectories","text":"The shape of the trajectory depends on the total specific mechanical energy \\(E\\) : \\[ E = \\frac{v^2}{2} - \\frac{GM}{r} \\] Elliptical orbit: \\(E < 0\\) (bound orbit), Parabolic trajectory: \\(E = 0\\) (escape velocity), Hyperbolic trajectory: \\(E > 0\\) (unbound, escape path).","title":"2. Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-numerical-simulation-method","text":"We solve the second-order ODE using numerical integration (e.g., RK4): Initial conditions: \\(\\mathbf{r}_0\\) , \\(\\mathbf{v}_0\\) , Update position and velocity at each timestep \\(\\Delta t\\) , Continue until simulation time ends or payload hits Earth. import numpy as np import matplotlib.pyplot as plt","title":"3. Numerical Simulation Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_earth = 6371e3 # Earth radius in meters","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"dt = 1.0 # time step in seconds t_max = 20000 # max simulation time in seconds","title":"Simulation parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"altitude = 500e3 # 500 km above Earth surface r0 = np.array([R_earth + altitude, 0.0]) # initial position (x,y) v_circular = np.sqrt(G * M / np.linalg.norm(r0)) # circular orbit velocity","title":"Initial conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#set-initial-velocity-10-faster-than-circular-velocity-example","text":"v0 = np.array([0.0, 1.1 * v_circular])","title":"Set initial velocity: 10% faster than circular velocity (example)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initialize-state-variables","text":"r = r0.copy() v = v0.copy() positions = [] velocities = [] times = [] def acceleration(r): r_norm = np.linalg.norm(r) return -G * M * r / r_norm**3 t = 0 while t < t_max: # Record data positions.append(r.copy()) velocities.append(v.copy()) times.append(t) # RK4 integration steps a1 = acceleration(r) k1v = a1 * dt k1r = v * dt a2 = acceleration(r + 0.5 * k1r) k2v = a2 * dt k2r = (v + 0.5 * k1v) * dt a3 = acceleration(r + 0.5 * k2r) k3v = a3 * dt k3r = (v + 0.5 * k2v) * dt a4 = acceleration(r + k3r) k4v = a4 * dt k4r = (v + k3v) * dt # Update velocity and position v += (k1v + 2*k2v + 2*k3v + k4v) / 6 r += (k1r + 2*k2r + 2*k3r + k4r) / 6 # Stop if payload hits Earth's surface if np.linalg.norm(r) <= R_earth: print(f\"Payload hit Earth surface at t={t:.2f} seconds\") break t += dt positions = np.array(positions) velocities = np.array(velocities) times = np.array(times)","title":"Initialize state variables"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-trajectory","text":"plt.figure(figsize=(8,8)) earth = plt.Circle((0,0), R_earth, color='b', alpha=0.3) plt.gca().add_patch(earth) plt.plot(positions[:,0], positions[:,1], label=\"Payload Trajectory\") plt.scatter([r0[0]], [r0[1]], color='green', label='Initial Position') plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectory Near Earth') plt.legend() plt.grid() plt.show()","title":"Plot trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-energy-over-time","text":"speeds = np.linalg.norm(velocities, axis=1) radii = np.linalg.norm(positions, axis=1) energy = 0.5 * speeds**2 - G * M / radii plt.figure() plt.plot(times, energy) plt.xlabel('Time (s)') plt.ylabel('Specific Mechanical Energy (J/kg)') plt.title('Energy vs Time (should be roughly constant)') plt.grid() plt.show()","title":"Plot energy over time"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}