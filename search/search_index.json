{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Mechanics \u2013 Problem 1 Investigating the Range as a Function of the Angle of Projection \ud83d\udccc Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. \ud83e\udde0 1. Theoretical Foundation Derivation of Equations of Motion Starting from Newton\u2019s second law: Horizontal motion (no acceleration): [ x(t) = v_0 \\cos(\\theta) t ] Vertical motion (constant downward acceleration): [ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : angle of projection - \\( g \\) : gravitational acceleration - \\( x(t), y(t) \\) : position at time \\( t \\) Time of Flight The projectile hits the ground when \\( y(t) = 0 \\) (assuming launch and landing heights are equal): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin(\\theta)}{g} \\] Horizontal Range \\[ R = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Thus, the range depends on : - \\( v_0^2 \\) : quadratic in initial velocity - \\( \\sin(2\\theta) \\) : maximized at \\( \\theta = 45^\\circ \\) - Inversely proportional to \\( g \\) \ud83d\udcca 2. Analysis of the Range Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0 = 20 # m/s # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Range calculation R = (v0**2) * np.sin(2 * angles_rad) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.axvline(45, color='red', linestyle='--', label='Maximum Range at 45\u00b0') plt.legend() plt.show() \ud83d\udcc8 Observations: Maximum range occurs at \\( \\theta = 45^\\circ \\) Symmetry : The range at angle \\( \\theta \\) is the same as at \\( 90^\\circ - \\theta \\) Increasing \\( v_0 \\) increases the entire curve quadratically Increasing \\( g \\) (e.g., on different planets) compresses the range \ud83c\udf0d 3. Practical Applications Sports : Optimizing throw angles in javelin, soccer, basketball Engineering : Launching projectiles in defense or construction Astrophysics : Trajectories of space probes under planetary gravity Education : Classic introductory example of 2D motion \ud83d\udcbb 4. Implementation The included Python script simulates the range as a function of angle and allows for parameter variation: Change v0 to observe effects of initial speed Modify g to simulate other planets (e.g., Moon or Mars) Extend to 3D or add drag force for realism \u26a0\ufe0f 5. Limitations and Extensions Limitations: Neglects air resistance Assumes level ground Assumes constant gravitational field Ignores spin or shape of projectile Possible Extensions: Add quadratic drag : \\( F_{\\text{drag}} \\propto v^2 \\) Model variable terrain : \\( y(t) \\ne 0 \\) at impact Vary initial height : \\( y_0 > 0 \\) \ud83d\udcce Conclusion Projectile motion offers both analytical beauty and practical relevance . The range as a function of angle exhibits a clear, elegant dependence on \\( \\sin(2\\theta) \\) , and this can be extended in many ways to model real-world systems more closely.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1","text":"","title":"Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"\ud83e\udde0 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Starting from Newton\u2019s second law: Horizontal motion (no acceleration): [ x(t) = v_0 \\cos(\\theta) t ] Vertical motion (constant downward acceleration): [ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : angle of projection - \\( g \\) : gravitational acceleration - \\( x(t), y(t) \\) : position at time \\( t \\)","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile hits the ground when \\( y(t) = 0 \\) (assuming launch and landing heights are equal): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\[ R = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Thus, the range depends on : - \\( v_0^2 \\) : quadratic in initial velocity - \\( \\sin(2\\theta) \\) : maximized at \\( \\theta = 45^\\circ \\) - Inversely proportional to \\( g \\)","title":"Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"\ud83d\udcca 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0 = 20 # m/s # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Range calculation R = (v0**2) * np.sin(2 * angles_rad) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.axvline(45, color='red', linestyle='--', label='Maximum Range at 45\u00b0') plt.legend() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"Maximum range occurs at \\( \\theta = 45^\\circ \\) Symmetry : The range at angle \\( \\theta \\) is the same as at \\( 90^\\circ - \\theta \\) Increasing \\( v_0 \\) increases the entire curve quadratically Increasing \\( g \\) (e.g., on different planets) compresses the range","title":"\ud83d\udcc8 Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimizing throw angles in javelin, soccer, basketball Engineering : Launching projectiles in defense or construction Astrophysics : Trajectories of space probes under planetary gravity Education : Classic introductory example of 2D motion","title":"\ud83c\udf0d 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"The included Python script simulates the range as a function of angle and allows for parameter variation: Change v0 to observe effects of initial speed Modify g to simulate other planets (e.g., Moon or Mars) Extend to 3D or add drag force for realism","title":"\ud83d\udcbb 4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"\u26a0\ufe0f 5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Neglects air resistance Assumes level ground Assumes constant gravitational field Ignores spin or shape of projectile","title":"Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#possible-extensions","text":"Add quadratic drag : \\( F_{\\text{drag}} \\propto v^2 \\) Model variable terrain : \\( y(t) \\ne 0 \\) at impact Vary initial height : \\( y_0 > 0 \\)","title":"Possible Extensions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Projectile motion offers both analytical beauty and practical relevance . The range as a function of angle exhibits a clear, elegant dependence on \\( \\sin(2\\theta) \\) , and this can be extended in many ways to model real-world systems more closely.","title":"\ud83d\udcce Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a classic example of a nonlinear dynamical system exhibiting rich and complex behavior. The interplay between damping, restoring forces, and an external periodic driving force leads to phenomena such as resonance, periodic oscillations, quasiperiodicity, and chaos. This makes the forced damped pendulum a fundamental model for understanding real-world systems in physics and engineering, including driven oscillators, suspension bridges, and energy harvesting devices. Introducing forcing adds parameters such as the amplitude and frequency of the external force. By varying these parameters and the damping coefficient, we observe a wide range of behaviors from simple periodic motion to highly irregular, chaotic dynamics. 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency (with gravitational acceleration \\(g\\) and pendulum length \\(l\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega\\) is the driving frequency. For small angles ( \\(\\theta \\approx 0\\) ), the approximation \\(\\sin \\theta \\approx \\theta\\) linearizes the equation, allowing analytical insights into resonance conditions and steady-state solutions. However, the full nonlinear equation must be solved numerically to explore phenomena such as chaos and complex oscillations. 2. Analysis of Dynamics The behavior of the forced damped pendulum depends critically on the parameters: Damping coefficient \\(\\gamma\\) : Controls energy dissipation. Low damping can allow sustained oscillations; high damping suppresses motion. Driving amplitude \\(A\\) : Determines the strength of the external force. Higher amplitudes can induce complex behaviors. Driving frequency \\(\\omega\\) : Resonance occurs when \\(\\omega \\approx \\omega_0\\) , leading to large amplitude oscillations. By varying these parameters, the system transitions from regular periodic motion to quasiperiodic and chaotic dynamics. The pendulum can synchronize with the drive, oscillate erratically, or even settle into complex attractors. 3. Practical Applications The forced damped pendulum model applies to many real-world systems: Engineering: Design of suspension bridges, vibration absorbers, and mechanical oscillators. Energy harvesting: Devices that capture energy from mechanical vibrations often exploit forced oscillations. Electrical circuits: Analogous behavior occurs in driven RLC circuits. Biomechanics: Understanding human gait and oscillatory motion in biological systems. 4. Implementation: Numerical Simulation in Python The following Python script uses numerical integration to simulate the nonlinear forced damped pendulum. The scipy.integrate.solve_ivp function applies a Runge-Kutta method to solve the system of first-order ODEs: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) gamma = 0.5 # damping coefficient A = 1.2 # driving force amplitude omega_drive = 2/3 # driving frequency omega0 = np.sqrt(g / l) # natural frequency # Define the system of equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions: small displacement and zero initial velocity y0 = [0.2, 0.0] # Time span and points for evaluation t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(12, 6)) plt.plot(sol.t, sol.y[0], label='Angular displacement \u03b8 (rad)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() plt.show() 5. Visualization of Phase Space To better understand the system\u2019s behavior, we plot the phase portrait showing angular displacement \\( \\theta \\) versus angular velocity \\( \\omega = \\frac{d\\theta}{dt} \\) : plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], linewidth=0.5) plt.xlabel('\u03b8 (radians)') plt.ylabel('Angular velocity \u03c9 (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.grid(True) plt.show() Extensions and Further Analysis Poincar\u00e9 Sections: Sampling the system state at intervals equal to the driving period reveals discrete points that can classify motion types. Bifurcation Diagrams: Sweeping the driving amplitude or frequency and plotting long-term behavior illustrates transitions to chaos. Nonlinear damping: Including terms dependent on \\( \\omega^2 \\) or velocity cubed can better model real frictional forces. Non-periodic driving: Studying random or quasi-periodic forcing introduces further complexity relevant in natural systems. Limitations The small-angle approximation is insufficient for large oscillations. Real pendulums may experience non-ideal friction, air resistance, and structural flexibility. The model assumes a rigid rod and point mass bob. Numerical solutions may require fine time resolution and careful handling of chaotic sensitivity. Conclusion The forced damped pendulum offers profound insights into nonlinear dynamics, illustrating how simple systems can exhibit complex and unpredictable behavior. Numerical simulations combined with phase space analysis enable exploration beyond analytic solutions, providing a window into resonance, chaos, and real-world oscillatory phenomena.","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic example of a nonlinear dynamical system exhibiting rich and complex behavior. The interplay between damping, restoring forces, and an external periodic driving force leads to phenomena such as resonance, periodic oscillations, quasiperiodicity, and chaos. This makes the forced damped pendulum a fundamental model for understanding real-world systems in physics and engineering, including driven oscillators, suspension bridges, and energy harvesting devices. Introducing forcing adds parameters such as the amplitude and frequency of the external force. By varying these parameters and the damping coefficient, we observe a wide range of behaviors from simple periodic motion to highly irregular, chaotic dynamics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency (with gravitational acceleration \\(g\\) and pendulum length \\(l\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega\\) is the driving frequency. For small angles ( \\(\\theta \\approx 0\\) ), the approximation \\(\\sin \\theta \\approx \\theta\\) linearizes the equation, allowing analytical insights into resonance conditions and steady-state solutions. However, the full nonlinear equation must be solved numerically to explore phenomena such as chaos and complex oscillations.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The behavior of the forced damped pendulum depends critically on the parameters: Damping coefficient \\(\\gamma\\) : Controls energy dissipation. Low damping can allow sustained oscillations; high damping suppresses motion. Driving amplitude \\(A\\) : Determines the strength of the external force. Higher amplitudes can induce complex behaviors. Driving frequency \\(\\omega\\) : Resonance occurs when \\(\\omega \\approx \\omega_0\\) , leading to large amplitude oscillations. By varying these parameters, the system transitions from regular periodic motion to quasiperiodic and chaotic dynamics. The pendulum can synchronize with the drive, oscillate erratically, or even settle into complex attractors.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to many real-world systems: Engineering: Design of suspension bridges, vibration absorbers, and mechanical oscillators. Energy harvesting: Devices that capture energy from mechanical vibrations often exploit forced oscillations. Electrical circuits: Analogous behavior occurs in driven RLC circuits. Biomechanics: Understanding human gait and oscillatory motion in biological systems.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-numerical-simulation-in-python","text":"The following Python script uses numerical integration to simulate the nonlinear forced damped pendulum. The scipy.integrate.solve_ivp function applies a Runge-Kutta method to solve the system of first-order ODEs: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) gamma = 0.5 # damping coefficient A = 1.2 # driving force amplitude omega_drive = 2/3 # driving frequency omega0 = np.sqrt(g / l) # natural frequency # Define the system of equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions: small displacement and zero initial velocity y0 = [0.2, 0.0] # Time span and points for evaluation t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(12, 6)) plt.plot(sol.t, sol.y[0], label='Angular displacement \u03b8 (rad)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() plt.show()","title":"4. Implementation: Numerical Simulation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-visualization-of-phase-space","text":"To better understand the system\u2019s behavior, we plot the phase portrait showing angular displacement \\( \\theta \\) versus angular velocity \\( \\omega = \\frac{d\\theta}{dt} \\) : plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], linewidth=0.5) plt.xlabel('\u03b8 (radians)') plt.ylabel('Angular velocity \u03c9 (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.grid(True) plt.show() Extensions and Further Analysis Poincar\u00e9 Sections: Sampling the system state at intervals equal to the driving period reveals discrete points that can classify motion types. Bifurcation Diagrams: Sweeping the driving amplitude or frequency and plotting long-term behavior illustrates transitions to chaos. Nonlinear damping: Including terms dependent on \\( \\omega^2 \\) or velocity cubed can better model real frictional forces. Non-periodic driving: Studying random or quasi-periodic forcing introduces further complexity relevant in natural systems. Limitations The small-angle approximation is insufficient for large oscillations. Real pendulums may experience non-ideal friction, air resistance, and structural flexibility. The model assumes a rigid rod and point mass bob. Numerical solutions may require fine time resolution and careful handling of chaotic sensitivity. Conclusion The forced damped pendulum offers profound insights into nonlinear dynamics, illustrating how simple systems can exhibit complex and unpredictable behavior. Numerical simulations combined with phase space analysis enable exploration beyond analytic solutions, providing a window into resonance, chaos, and real-world oscillatory phenomena.","title":"5. Visualization of Phase Space"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1: Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law reveals a profound connection between the time it takes a celestial object to complete an orbit and its distance from the object it orbits. It\u2019s a cornerstone in celestial mechanics, useful for estimating distances, predicting motion, and determining masses of astronomical objects. This relationship, when derived from Newtonian gravitation, also helps bridge classical and modern physics. 1. Theoretical Derivation Consider a small object of mass \\( m \\) orbiting a large central mass \\( M \\) in a circular orbit of radius \\( r \\) and period \\( T \\) . Gravitational Force Provides Centripetal Force \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and rearranging: \\[ v^2 = \\frac{G M}{r} \\] Substitute \\( v = \\frac{2\\pi r}{T} \\) : \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 Kepler\u2019s Third Law for Circular Orbits : $$ T^2 \\propto r^3 $$ This shows the square of the orbital period is proportional to the cube of the orbital radius. 2. Astronomical Implications Used to calculate planetary distances when the period is known (and vice versa). Allows estimation of the mass of central objects (e.g., planets, stars). Critical in satellite deployment , planet hunting , and galactic dynamics . 3. Real-World Examples Example 1: The Moon Orbiting Earth Given: - Orbital radius: \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) - Mass of Earth: \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - Gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} \\) Using the orbital period formula: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\approx 2.36 \\times 10^6 \\, \\text{s} \\approx 27.3 \\, \\text{days} \\] This matches the observed sidereal period of the Moon. Example 2: Planetary Orbits in the Solar System When using astronomical units (AU) for distance and years for time, Kepler\u2019s Third Law simplifies to: T\u00b2 = r\u00b3 where - T is the orbital period in years - r is the orbital radius in AU For example: Earth : r = 1 AU \u21d2 T = 1 year Mars : r = 1.52 AU \u21d2 T\u00b2 = (1.52)\u00b3 = 3.51 \u21d2 T = \u221a3.51 \u2248 1.87 years This matches well with the actual orbital period of Mars. 4. Python Simulation and Visualization import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 1.989e30 # Mass of the Sun in kg # Orbital radii (in meters) radii = np.linspace(5e10, 3e12, 100) # From 0.33 AU to ~20 AU # Calculate periods using Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to show the linear relationship plt.figure(figsize=(8, 6)) plt.plot(radii**3, periods**2) plt.xlabel('Orbital Radius Cubed (r\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Kepler\u2019s Third Law: T\u00b2 vs r\u00b3') plt.grid(True) plt.show() 5. Extension: Elliptical Orbits For elliptical orbits, Kepler\u2019s Third Law generalizes to: \\[ T^2 = \\frac{4 \\pi^2}{G M} a^3 \\] where - \\( T \\) is the orbital period, - \\( a \\) is the semi-major axis of the ellipse, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. The relationship still holds true, making Kepler\u2019s Third Law a powerful tool even beyond circular orbit approximations. 6. Conclusion Kepler\u2019s Third Law, derived from Newtonian mechanics, elegantly explains the orbital dynamics of planets and satellites. It allows astronomers to deduce distances and masses from simple observations and remains foundational in both theoretical and applied astrophysics.","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law reveals a profound connection between the time it takes a celestial object to complete an orbit and its distance from the object it orbits. It\u2019s a cornerstone in celestial mechanics, useful for estimating distances, predicting motion, and determining masses of astronomical objects. This relationship, when derived from Newtonian gravitation, also helps bridge classical and modern physics.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"Consider a small object of mass \\( m \\) orbiting a large central mass \\( M \\) in a circular orbit of radius \\( r \\) and period \\( T \\) .","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravitational-force-provides-centripetal-force","text":"\\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and rearranging: \\[ v^2 = \\frac{G M}{r} \\] Substitute \\( v = \\frac{2\\pi r}{T} \\) : \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 Kepler\u2019s Third Law for Circular Orbits : $$ T^2 \\propto r^3 $$ This shows the square of the orbital period is proportional to the cube of the orbital radius.","title":"Gravitational Force Provides Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"Used to calculate planetary distances when the period is known (and vice versa). Allows estimation of the mass of central objects (e.g., planets, stars). Critical in satellite deployment , planet hunting , and galactic dynamics .","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moon-orbiting-earth","text":"Given: - Orbital radius: \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) - Mass of Earth: \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - Gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} \\) Using the orbital period formula: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\approx 2.36 \\times 10^6 \\, \\text{s} \\approx 27.3 \\, \\text{days} \\] This matches the observed sidereal period of the Moon.","title":"Example 1: The Moon Orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planetary-orbits-in-the-solar-system","text":"When using astronomical units (AU) for distance and years for time, Kepler\u2019s Third Law simplifies to: T\u00b2 = r\u00b3 where - T is the orbital period in years - r is the orbital radius in AU For example: Earth : r = 1 AU \u21d2 T = 1 year Mars : r = 1.52 AU \u21d2 T\u00b2 = (1.52)\u00b3 = 3.51 \u21d2 T = \u221a3.51 \u2248 1.87 years This matches well with the actual orbital period of Mars.","title":"Example 2: Planetary Orbits in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 1.989e30 # Mass of the Sun in kg # Orbital radii (in meters) radii = np.linspace(5e10, 3e12, 100) # From 0.33 AU to ~20 AU # Calculate periods using Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to show the linear relationship plt.figure(figsize=(8, 6)) plt.plot(radii**3, periods**2) plt.xlabel('Orbital Radius Cubed (r\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Kepler\u2019s Third Law: T\u00b2 vs r\u00b3') plt.grid(True) plt.show()","title":"4. Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-elliptical-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law generalizes to: \\[ T^2 = \\frac{4 \\pi^2}{G M} a^3 \\] where - \\( T \\) is the orbital period, - \\( a \\) is the semi-major axis of the ellipse, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. The relationship still holds true, making Kepler\u2019s Third Law a powerful tool even beyond circular orbit approximations.","title":"5. Extension: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-conclusion","text":"Kepler\u2019s Third Law, derived from Newtonian mechanics, elegantly explains the orbital dynamics of planets and satellites. It allows astronomers to deduce distances and masses from simple observations and remains foundational in both theoretical and applied astrophysics.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation Understanding escape velocity is fundamental to grasping how spacecraft leave a celestial body's gravitational influence. Beyond escape velocity, the first, second, and third cosmic velocities set thresholds for orbiting a planet, escaping it, and even leaving the star system. These concepts are the foundation of launching satellites, planning interplanetary missions, and envisioning future interstellar travel. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) The minimum velocity an object must have to stay in a stable low circular orbit around a celestial body without falling back to the surface. Physically: It balances gravitational pull with centripetal force to maintain orbit. Second Cosmic Velocity (Escape Velocity) The minimum velocity needed to escape the gravitational field of the celestial body completely without further propulsion. Physically: It allows an object to reach infinite distance with zero kinetic energy left. Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape the gravitational influence of the star system (e.g., the Sun), assuming the object starts from the planet's surface. Physically: It combines escape from the planet plus the additional velocity to overcome the star's gravity. Mathematical Derivations 1. First Cosmic Velocity \\( v_1 \\) For a circular orbit of radius \\( r \\) (usually the planet\u2019s radius plus altitude, but here surface orbit is approximated as radius \\( R \\) ): $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where: \\( G \\) is the universal gravitational constant, approximately $$ G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $$ \\( M \\) is the mass of the celestial body (kg). \\( R \\) is the radius of the celestial body (m). 2. Second Cosmic Velocity \\( v_2 \\) (Escape velocity from the planet) The escape velocity is derived from energy conservation, where the kinetic energy equals the gravitational potential energy required to escape the gravitational field of the planet. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\, v_1 \\] 3. Third Cosmic Velocity \\( v_3 \\) (Escape velocity from the star system) This velocity corresponds to the minimum speed needed to escape the gravitational influence of the star system (e.g., the Sun), assuming the spacecraft is launched from the surface of the planet. The spacecraft must overcome the gravitational potentials of both the planet and the star at the planet\u2019s orbital radius. Let: \\( r_s \\) be the orbital radius of the planet around the star (distance from the star to the planet). \\( M_s \\) be the mass of the star. Then, \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{esc,star}}^2} \\] where \\[ v_{\\text{esc,star}} = \\sqrt{\\frac{2GM_s}{r_s}} \\] and \\( v_2 \\) is the escape velocity from the planet as above. Parameters for Earth, Mars, and Jupiter Body Mass (kg) Radius (m) Orbital Radius from Sun (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^{6}\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.39 \\times 10^{23}\\) \\(3.3895 \\times 10^{6}\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^{7}\\) \\(7.785 \\times 10^{11}\\) Sun mass: \\[ M_s = 1.989 \\times 10^{30} \\, \\text{kg} \\] Python Code to Calculate and Visualize Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Celestial bodies data bodies = { \"Earth\": { \"mass\": 5.972e24, \"radius\": 6.371e6, \"orbit_radius\": 1.496e11 }, \"Mars\": { \"mass\": 6.39e23, \"radius\": 3.3895e6, \"orbit_radius\": 2.279e11 }, \"Jupiter\": { \"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbit_radius\": 7.785e11 } } # Compute velocities results = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] r_s = data[\"orbit_radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity (orbit) v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity (escape planet) v_esc_star = np.sqrt(2 * G * M_sun / r_s) # Escape velocity from Sun at planet orbit v3 = np.sqrt(v2**2 + v_esc_star**2) # Third cosmic velocity (escape star system) results[body] = { \"First Cosmic Velocity (km/s)\": v1 / 1000, \"Second Cosmic Velocity (km/s)\": v2 / 1000, \"Third Cosmic Velocity (km/s)\": v3 / 1000 } # Display results for body, velocities in results.items(): print(f\"{body}:\") for desc, val in velocities.items(): print(f\" {desc}: {val:.2f} km/s\") print() # Visualization labels = list(results.keys()) v1_vals = [results[b][\"First Cosmic Velocity (km/s)\"] for b in labels] v2_vals = [results[b][\"Second Cosmic Velocity (km/s)\"] for b in labels] v3_vals = [results[b][\"Third Cosmic Velocity (km/s)\"] for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True, axis='y') plt.show() Discussion and Importance in Space Exploration The First Cosmic Velocity is essential for satellites. Any satellite must reach at least this velocity to maintain a stable orbit, preventing it from falling back to the planet. For Earth, this velocity is about 7.9 km/s. The Second Cosmic Velocity (Escape Velocity) is critical for spacecraft leaving a planet's gravity without continuous propulsion. Rockets must accelerate beyond this velocity to enter interplanetary trajectories. The Third Cosmic Velocity relates to leaving the star system entirely, enabling potential interstellar missions. It requires combining escape from the planet plus enough velocity to overcome the star's gravity. For Earth, this is around 16.7 km/s. These velocities guide mission planning, fuel requirements, and the design of propulsion systems. Understanding and achieving them are the backbone of satellite launches, interplanetary probes (e.g., Mars rovers), and future interstellar exploration concepts. Summary First cosmic velocity \u2014 orbital velocity around a planet. Second cosmic velocity \u2014 escape velocity from the planet. Third cosmic velocity \u2014 escape velocity from the star system (e.g., the Sun). These velocities vary by celestial body due to differences in mass, radius, and distance from the star, reflecting their unique gravitational environments.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding escape velocity is fundamental to grasping how spacecraft leave a celestial body's gravitational influence. Beyond escape velocity, the first, second, and third cosmic velocities set thresholds for orbiting a planet, escaping it, and even leaving the star system. These concepts are the foundation of launching satellites, planning interplanetary missions, and envisioning future interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity) The minimum velocity an object must have to stay in a stable low circular orbit around a celestial body without falling back to the surface. Physically: It balances gravitational pull with centripetal force to maintain orbit. Second Cosmic Velocity (Escape Velocity) The minimum velocity needed to escape the gravitational field of the celestial body completely without further propulsion. Physically: It allows an object to reach infinite distance with zero kinetic energy left. Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape the gravitational influence of the star system (e.g., the Sun), assuming the object starts from the planet's surface. Physically: It combines escape from the planet plus the additional velocity to overcome the star's gravity.","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"For a circular orbit of radius \\( r \\) (usually the planet\u2019s radius plus altitude, but here surface orbit is approximated as radius \\( R \\) ): $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where: \\( G \\) is the universal gravitational constant, approximately $$ G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $$ \\( M \\) is the mass of the celestial body (kg). \\( R \\) is the radius of the celestial body (m).","title":"1. First Cosmic Velocity \\( v_1 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2-escape-velocity-from-the-planet","text":"The escape velocity is derived from energy conservation, where the kinetic energy equals the gravitational potential energy required to escape the gravitational field of the planet. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\, v_1 \\]","title":"2. Second Cosmic Velocity \\( v_2 \\) (Escape velocity from the planet)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3-escape-velocity-from-the-star-system","text":"This velocity corresponds to the minimum speed needed to escape the gravitational influence of the star system (e.g., the Sun), assuming the spacecraft is launched from the surface of the planet. The spacecraft must overcome the gravitational potentials of both the planet and the star at the planet\u2019s orbital radius. Let: \\( r_s \\) be the orbital radius of the planet around the star (distance from the star to the planet). \\( M_s \\) be the mass of the star. Then, \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{esc,star}}^2} \\] where \\[ v_{\\text{esc,star}} = \\sqrt{\\frac{2GM_s}{r_s}} \\] and \\( v_2 \\) is the escape velocity from the planet as above.","title":"3. Third Cosmic Velocity \\( v_3 \\) (Escape velocity from the star system)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-for-earth-mars-and-jupiter","text":"Body Mass (kg) Radius (m) Orbital Radius from Sun (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^{6}\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.39 \\times 10^{23}\\) \\(3.3895 \\times 10^{6}\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^{7}\\) \\(7.785 \\times 10^{11}\\) Sun mass: \\[ M_s = 1.989 \\times 10^{30} \\, \\text{kg} \\]","title":"Parameters for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-to-calculate-and-visualize-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Celestial bodies data bodies = { \"Earth\": { \"mass\": 5.972e24, \"radius\": 6.371e6, \"orbit_radius\": 1.496e11 }, \"Mars\": { \"mass\": 6.39e23, \"radius\": 3.3895e6, \"orbit_radius\": 2.279e11 }, \"Jupiter\": { \"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbit_radius\": 7.785e11 } } # Compute velocities results = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] r_s = data[\"orbit_radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity (orbit) v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity (escape planet) v_esc_star = np.sqrt(2 * G * M_sun / r_s) # Escape velocity from Sun at planet orbit v3 = np.sqrt(v2**2 + v_esc_star**2) # Third cosmic velocity (escape star system) results[body] = { \"First Cosmic Velocity (km/s)\": v1 / 1000, \"Second Cosmic Velocity (km/s)\": v2 / 1000, \"Third Cosmic Velocity (km/s)\": v3 / 1000 } # Display results for body, velocities in results.items(): print(f\"{body}:\") for desc, val in velocities.items(): print(f\" {desc}: {val:.2f} km/s\") print() # Visualization labels = list(results.keys()) v1_vals = [results[b][\"First Cosmic Velocity (km/s)\"] for b in labels] v2_vals = [results[b][\"Second Cosmic Velocity (km/s)\"] for b in labels] v3_vals = [results[b][\"Third Cosmic Velocity (km/s)\"] for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True, axis='y') plt.show()","title":"Python Code to Calculate and Visualize Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#discussion-and-importance-in-space-exploration","text":"The First Cosmic Velocity is essential for satellites. Any satellite must reach at least this velocity to maintain a stable orbit, preventing it from falling back to the planet. For Earth, this velocity is about 7.9 km/s. The Second Cosmic Velocity (Escape Velocity) is critical for spacecraft leaving a planet's gravity without continuous propulsion. Rockets must accelerate beyond this velocity to enter interplanetary trajectories. The Third Cosmic Velocity relates to leaving the star system entirely, enabling potential interstellar missions. It requires combining escape from the planet plus enough velocity to overcome the star's gravity. For Earth, this is around 16.7 km/s. These velocities guide mission planning, fuel requirements, and the design of propulsion systems. Understanding and achieving them are the backbone of satellite launches, interplanetary probes (e.g., Mars rovers), and future interstellar exploration concepts.","title":"Discussion and Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"First cosmic velocity \u2014 orbital velocity around a planet. Second cosmic velocity \u2014 escape velocity from the planet. Third cosmic velocity \u2014 escape velocity from the star system (e.g., the Sun). These velocities vary by celestial body due to differences in mass, radius, and distance from the star, reflecting their unique gravitational environments.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth 1. Introduction and Theory When a payload is released from a moving rocket near Earth, its motion is influenced primarily by Earth's gravity. The trajectory depends on the initial velocity, position, and altitude. Based on these initial conditions, the path can be one of the following: Elliptical orbit (closed orbit around Earth), Parabolic trajectory (the borderline between bound and unbound orbits), Hyperbolic trajectory (escape trajectory). Governing Physics The gravitational force acting on the payload is described by Newton's Law of Gravitation : \\[ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} \\] where: \\( G \\) is the gravitational constant, \\(6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\mathrm{kg}^{-1} \\mathrm{s}^{-2} \\) , \\( M \\) is the mass of Earth, \\(5.972 \\times 10^{24} \\, \\mathrm{kg} \\) , \\( m \\) is the payload mass (which cancels out in the acceleration), \\( r \\) is the distance from Earth's center to the payload, \\( \\hat{r} \\) is the unit vector pointing from Earth to the payload. The equation of motion under Earth's gravity is: \\[ \\mathbf{\\ddot{r}} = -\\frac{GM}{r^3} \\mathbf{r} \\] where \\(\\mathbf{r}\\) is the position vector of the payload relative to Earth's center. Escape Velocity The escape velocity at distance \\(r\\) from Earth's center is: \\[ v_{\\mathrm{esc}} = \\sqrt{\\frac{2GM}{r}} \\] If the payload's velocity \\(v < v_{\\mathrm{esc}}\\) , it follows an elliptical orbit. If \\(v = v_{\\mathrm{esc}}\\) , it follows a parabolic trajectory. If \\(v > v_{\\mathrm{esc}}\\) , it follows a hyperbolic trajectory and escapes Earth. 2. Numerical Method and Simulation Setup To analyze the trajectory numerically, we solve the second-order differential equation of motion by converting it into a system of first-order ordinary differential equations (ODEs): Define the state vector: \\[ \\mathbf{y} = (x, y, v_x, v_y) \\] where \\((x,y)\\) is the payload position and \\((v_x, v_y)\\) are the velocity components in a 2D plane. The equations become: \\[ \\begin{cases} \\dot{x} = v_x \\\\ \\dot{y} = v_y \\\\ \\dot{v_x} = -\\frac{GM}{r^3} x \\\\ \\dot{v_y} = -\\frac{GM}{r^3} y \\end{cases} \\] with \\[ r = \\sqrt{x^2 + y^2} \\] We use numerical ODE solvers such as Python's scipy.integrate.solve_ivp to simulate the motion over time, given initial conditions for position and velocity. 3. Python Implementation for Trajectory Simulation The following Python script numerically simulates the payload's trajectory under Earth's gravity using the scipy.integrate.solve_ivp solver. It models the 2D motion by solving the system of ordinary differential equations derived in the previous section. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth, kg R_earth = 6371e3 # radius of Earth, meters def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(initial_pos, initial_vel, t_span=[0, 5000], max_step=1): y0 = [initial_pos[0], initial_pos[1], initial_vel[0], initial_vel[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8) return sol def plot_trajectory(sol, title='Payload Trajectory'): x = sol.y[0] / 1e3 # convert meters to kilometers y = sol.y[1] / 1e3 plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') earth = plt.Circle((0, 0), R_earth / 1e3, color='b', alpha=0.3, label='Earth') plt.gca().add_patch(earth) plt.xlabel('X (km)') plt.ylabel('Y (km)') plt.title(title) plt.axis('equal') plt.legend() plt.grid(True) plt.show() # Example initial conditions: altitude = 400e3 # 400 km above Earth's surface r0 = R_earth + altitude # Initial position at (r0, 0) initial_pos = np.array([r0, 0]) # Circular orbital velocity at altitude v_circular = np.sqrt(G * M / r0) # Initial velocities for different trajectories initial_vel_circular = np.array([0, v_circular]) # Circular orbit initial_vel_elliptical = np.array([0, 0.9 * np.sqrt(2) * v_circular]) # Elliptical orbit initial_vel_parabolic = np.array([0, np.sqrt(2) * v_circular]) # Parabolic escape initial_vel_hyperbolic = np.array([0, 1.1 * np.sqrt(2) * v_circular]) # Hyperbolic escape # Run simulations sol_circular = simulate_trajectory(initial_pos, initial_vel_circular) sol_elliptical = simulate_trajectory(initial_pos, initial_vel_elliptical) sol_parabolic = simulate_trajectory(initial_pos, initial_vel_parabolic, t_span=[0, 10000]) sol_hyperbolic = simulate_trajectory(initial_pos, initial_vel_hyperbolic, t_span=[0, 10000]) # Plot the results plot_trajectory(sol_circular, 'Circular Orbit') plot_trajectory(sol_elliptical, 'Elliptical Orbit') plot_trajectory(sol_parabolic, 'Parabolic Escape Trajectory') plot_trajectory(sol_hyperbolic, 'Hyperbolic Escape Trajectory') 4. Discussion Elliptical orbit: Initial velocity is less than the escape velocity; the payload remains gravitationally bound, orbiting Earth. Parabolic trajectory: Payload escapes Earth but with zero excess velocity at infinity \u2014 representing a delicate boundary case between bound and unbound orbits. Hyperbolic trajectory: Payload escapes Earth with positive excess velocity, meaning it will not return. Circular orbit: A special case of an elliptical orbit where the velocity is exactly the circular orbital velocity at the given altitude. 5. Real-World Applications Orbital insertion: Adjusting the payload\u2019s velocity to achieve elliptical or circular orbits around Earth. Reentry scenarios: Payload velocity decreases so the trajectory intersects Earth's atmosphere, enabling controlled return. Escape trajectories: Missions designed to leave Earth orbit entirely (e.g., interplanetary probes and deep space missions).","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction-and-theory","text":"When a payload is released from a moving rocket near Earth, its motion is influenced primarily by Earth's gravity. The trajectory depends on the initial velocity, position, and altitude. Based on these initial conditions, the path can be one of the following: Elliptical orbit (closed orbit around Earth), Parabolic trajectory (the borderline between bound and unbound orbits), Hyperbolic trajectory (escape trajectory).","title":"1. Introduction and Theory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-physics","text":"The gravitational force acting on the payload is described by Newton's Law of Gravitation : \\[ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} \\] where: \\( G \\) is the gravitational constant, \\(6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\mathrm{kg}^{-1} \\mathrm{s}^{-2} \\) , \\( M \\) is the mass of Earth, \\(5.972 \\times 10^{24} \\, \\mathrm{kg} \\) , \\( m \\) is the payload mass (which cancels out in the acceleration), \\( r \\) is the distance from Earth's center to the payload, \\( \\hat{r} \\) is the unit vector pointing from Earth to the payload. The equation of motion under Earth's gravity is: \\[ \\mathbf{\\ddot{r}} = -\\frac{GM}{r^3} \\mathbf{r} \\] where \\(\\mathbf{r}\\) is the position vector of the payload relative to Earth's center.","title":"Governing Physics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity at distance \\(r\\) from Earth's center is: \\[ v_{\\mathrm{esc}} = \\sqrt{\\frac{2GM}{r}} \\] If the payload's velocity \\(v < v_{\\mathrm{esc}}\\) , it follows an elliptical orbit. If \\(v = v_{\\mathrm{esc}}\\) , it follows a parabolic trajectory. If \\(v > v_{\\mathrm{esc}}\\) , it follows a hyperbolic trajectory and escapes Earth.","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-method-and-simulation-setup","text":"To analyze the trajectory numerically, we solve the second-order differential equation of motion by converting it into a system of first-order ordinary differential equations (ODEs): Define the state vector: \\[ \\mathbf{y} = (x, y, v_x, v_y) \\] where \\((x,y)\\) is the payload position and \\((v_x, v_y)\\) are the velocity components in a 2D plane. The equations become: \\[ \\begin{cases} \\dot{x} = v_x \\\\ \\dot{y} = v_y \\\\ \\dot{v_x} = -\\frac{GM}{r^3} x \\\\ \\dot{v_y} = -\\frac{GM}{r^3} y \\end{cases} \\] with \\[ r = \\sqrt{x^2 + y^2} \\] We use numerical ODE solvers such as Python's scipy.integrate.solve_ivp to simulate the motion over time, given initial conditions for position and velocity.","title":"2. Numerical Method and Simulation Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-implementation-for-trajectory-simulation","text":"The following Python script numerically simulates the payload's trajectory under Earth's gravity using the scipy.integrate.solve_ivp solver. It models the 2D motion by solving the system of ordinary differential equations derived in the previous section. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth, kg R_earth = 6371e3 # radius of Earth, meters def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(initial_pos, initial_vel, t_span=[0, 5000], max_step=1): y0 = [initial_pos[0], initial_pos[1], initial_vel[0], initial_vel[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8) return sol def plot_trajectory(sol, title='Payload Trajectory'): x = sol.y[0] / 1e3 # convert meters to kilometers y = sol.y[1] / 1e3 plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') earth = plt.Circle((0, 0), R_earth / 1e3, color='b', alpha=0.3, label='Earth') plt.gca().add_patch(earth) plt.xlabel('X (km)') plt.ylabel('Y (km)') plt.title(title) plt.axis('equal') plt.legend() plt.grid(True) plt.show() # Example initial conditions: altitude = 400e3 # 400 km above Earth's surface r0 = R_earth + altitude # Initial position at (r0, 0) initial_pos = np.array([r0, 0]) # Circular orbital velocity at altitude v_circular = np.sqrt(G * M / r0) # Initial velocities for different trajectories initial_vel_circular = np.array([0, v_circular]) # Circular orbit initial_vel_elliptical = np.array([0, 0.9 * np.sqrt(2) * v_circular]) # Elliptical orbit initial_vel_parabolic = np.array([0, np.sqrt(2) * v_circular]) # Parabolic escape initial_vel_hyperbolic = np.array([0, 1.1 * np.sqrt(2) * v_circular]) # Hyperbolic escape # Run simulations sol_circular = simulate_trajectory(initial_pos, initial_vel_circular) sol_elliptical = simulate_trajectory(initial_pos, initial_vel_elliptical) sol_parabolic = simulate_trajectory(initial_pos, initial_vel_parabolic, t_span=[0, 10000]) sol_hyperbolic = simulate_trajectory(initial_pos, initial_vel_hyperbolic, t_span=[0, 10000]) # Plot the results plot_trajectory(sol_circular, 'Circular Orbit') plot_trajectory(sol_elliptical, 'Elliptical Orbit') plot_trajectory(sol_parabolic, 'Parabolic Escape Trajectory') plot_trajectory(sol_hyperbolic, 'Hyperbolic Escape Trajectory')","title":"3. Python Implementation for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-discussion","text":"Elliptical orbit: Initial velocity is less than the escape velocity; the payload remains gravitationally bound, orbiting Earth. Parabolic trajectory: Payload escapes Earth but with zero excess velocity at infinity \u2014 representing a delicate boundary case between bound and unbound orbits. Hyperbolic trajectory: Payload escapes Earth with positive excess velocity, meaning it will not return. Circular orbit: A special case of an elliptical orbit where the velocity is exactly the circular orbital velocity at the given altitude.","title":"4. Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-real-world-applications","text":"Orbital insertion: Adjusting the payload\u2019s velocity to achieve elliptical or circular orbits around Earth. Reentry scenarios: Payload velocity decreases so the trajectory intersects Earth's atmosphere, enabling controlled return. Escape trajectories: Missions designed to leave Earth orbit entirely (e.g., interplanetary probes and deep space missions).","title":"5. Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1: Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this phenomenon can be observed as ripples from different points meet, forming distinctive interference patterns. These patterns visually demonstrate how waves combine\u2014either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns deepens understanding of wave behavior and phase relationships in a simple, intuitive way. This hands-on approach is useful for exploring wave physics and real-world applications such as acoustics, optics, and fluid dynamics. Problem Statement A circular wave on a water surface, emanating from a point source located at \\(\\mathbf{r}_i\\) , can be described by the Single Disturbance equation : \\[ \\eta(\\mathbf{r}, t) = A \\cos(k r - \\omega t + \\phi) \\] where: - \\(\\eta(\\mathbf{r}, t)\\) is the displacement of the water surface at position \\(\\mathbf{r}\\) and time \\(t\\) , - \\(A\\) is the amplitude of the wave, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, with \\(\\lambda\\) the wavelength, - \\(\\omega = 2 \\pi f\\) is the angular frequency, with \\(f\\) the frequency, - \\(r = |\\mathbf{r} - \\mathbf{r}_i|\\) is the distance from the source at \\(\\mathbf{r}_i\\) to the point \\(\\mathbf{r}\\) , - \\(\\phi\\) is the initial phase. Steps to Follow Select a Regular Polygon Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources Place point wave sources at the vertices of the selected polygon, each at position \\(\\mathbf{r}_i\\) . Wave Equations Write the wave equation emitted from each source \\(i\\) : $$ \\eta_i(\\mathbf{r}, t) = A \\cos(k |\\mathbf{r} - \\mathbf{r}_i| - \\omega t + \\phi_i) $$ Assuming all sources have the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , and phase \\(\\phi_i = 0\\) for coherence. Superposition of Waves Apply the principle of superposition by summing the displacements from all \\(N\\) sources: $$ \\eta_{\\mathrm{total}}(\\mathbf{r}, t) = \\sum_{i=1}^N \\eta_i(\\mathbf{r}, t) = \\sum_{i=1}^N A \\cos(k |\\mathbf{r} - \\mathbf{r}_i| - \\omega t) $$ Analyze Interference Patterns Analyze \\(\\eta_{\\mathrm{total}}(\\mathbf{r}, t)\\) as a function of position \\(\\mathbf{r}\\) and time \\(t\\) to identify regions of: Constructive interference: where waves reinforce ( \\(\\eta\\) maxima), Destructive interference: where waves cancel out ( \\(\\eta\\) minima). Visualization Create graphical representations of the interference patterns on the water surface for the chosen polygon. 3. Python Simulation Implementation Below is a Python script that simulates the interference pattern on the water surface due to wave sources placed at the vertices of a regular polygon. It calculates the total displacement of the water surface over a 2D grid at a fixed time, illustrating the constructive and destructive interference regions. import numpy as np import matplotlib.pyplot as plt def polygon_vertices(radius, n_sides): \"\"\" Compute vertices of a regular polygon centered at origin. radius: distance from center to each vertex (meters) n_sides: number of vertices (polygon sides) \"\"\" angles = np.linspace(0, 2 * np.pi, n_sides, endpoint=False) x = radius * np.cos(angles) y = radius * np.sin(angles) return np.vstack((x, y)).T # shape (n_sides, 2) def wave_displacement(points, sources, k, omega, t, A=1.0): \"\"\" Calculate total displacement at grid points due to all sources at time t. points: array of shape (num_points, 2) with (x, y) positions sources: array of shape (num_sources, 2) with (x, y) source positions k: wave number (2pi / wavelength) omega: angular frequency (2pi * frequency) t: time (seconds) A: amplitude \"\"\" displacement = np.zeros(points.shape[0]) for source in sources: r = np.linalg.norm(points - source, axis=1) r[r == 0] = 1e-10 # prevent division by zero displacement += A * np.cos(k * r - omega * t) return displacement # Simulation parameters n_sides = 5 # number of polygon sides, e.g. pentagon radius = 1.0 # distance from center to vertices (meters) wavelength = 0.5 # meters frequency = 1.0 # Hz k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency amplitude = 1.0 time = 0.0 # time instant for snapshot # Generate polygon vertices (sources) sources = polygon_vertices(radius, n_sides) # Create grid points for simulation x = np.linspace(-2, 2, 400) y = np.linspace(-2, 2, 400) X, Y = np.meshgrid(x, y) points = np.vstack([X.ravel(), Y.ravel()]).T # Calculate total wave displacement at each grid point displacement = wave_displacement(points, sources, k, omega, time, amplitude) Z = displacement.reshape(X.shape) # Plotting the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Displacement') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.title(f'Interference Pattern - {n_sides}-sided Polygon Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.axis('equal') plt.show() Considerations All sources emit waves with identical amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . The waves are coherent, maintaining constant phase relationships. Numerical simulation tools such as Python (with NumPy and Matplotlib) are used for modeling and visualization. Deliverables A Markdown document including the Python script or notebook implementing the simulation. A detailed explanation of the interference patterns observed, related to the polygon shape and wave parameters. Graphical representations showing regions of constructive and destructive interference on the water surface.","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1-interference-patterns-on-a-water-surface","text":"","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this phenomenon can be observed as ripples from different points meet, forming distinctive interference patterns. These patterns visually demonstrate how waves combine\u2014either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns deepens understanding of wave behavior and phase relationships in a simple, intuitive way. This hands-on approach is useful for exploring wave physics and real-world applications such as acoustics, optics, and fluid dynamics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"A circular wave on a water surface, emanating from a point source located at \\(\\mathbf{r}_i\\) , can be described by the Single Disturbance equation : \\[ \\eta(\\mathbf{r}, t) = A \\cos(k r - \\omega t + \\phi) \\] where: - \\(\\eta(\\mathbf{r}, t)\\) is the displacement of the water surface at position \\(\\mathbf{r}\\) and time \\(t\\) , - \\(A\\) is the amplitude of the wave, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, with \\(\\lambda\\) the wavelength, - \\(\\omega = 2 \\pi f\\) is the angular frequency, with \\(f\\) the frequency, - \\(r = |\\mathbf{r} - \\mathbf{r}_i|\\) is the distance from the source at \\(\\mathbf{r}_i\\) to the point \\(\\mathbf{r}\\) , - \\(\\phi\\) is the initial phase.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Select a Regular Polygon Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources Place point wave sources at the vertices of the selected polygon, each at position \\(\\mathbf{r}_i\\) . Wave Equations Write the wave equation emitted from each source \\(i\\) : $$ \\eta_i(\\mathbf{r}, t) = A \\cos(k |\\mathbf{r} - \\mathbf{r}_i| - \\omega t + \\phi_i) $$ Assuming all sources have the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , and phase \\(\\phi_i = 0\\) for coherence. Superposition of Waves Apply the principle of superposition by summing the displacements from all \\(N\\) sources: $$ \\eta_{\\mathrm{total}}(\\mathbf{r}, t) = \\sum_{i=1}^N \\eta_i(\\mathbf{r}, t) = \\sum_{i=1}^N A \\cos(k |\\mathbf{r} - \\mathbf{r}_i| - \\omega t) $$ Analyze Interference Patterns Analyze \\(\\eta_{\\mathrm{total}}(\\mathbf{r}, t)\\) as a function of position \\(\\mathbf{r}\\) and time \\(t\\) to identify regions of: Constructive interference: where waves reinforce ( \\(\\eta\\) maxima), Destructive interference: where waves cancel out ( \\(\\eta\\) minima). Visualization Create graphical representations of the interference patterns on the water surface for the chosen polygon.","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-python-simulation-implementation","text":"Below is a Python script that simulates the interference pattern on the water surface due to wave sources placed at the vertices of a regular polygon. It calculates the total displacement of the water surface over a 2D grid at a fixed time, illustrating the constructive and destructive interference regions. import numpy as np import matplotlib.pyplot as plt def polygon_vertices(radius, n_sides): \"\"\" Compute vertices of a regular polygon centered at origin. radius: distance from center to each vertex (meters) n_sides: number of vertices (polygon sides) \"\"\" angles = np.linspace(0, 2 * np.pi, n_sides, endpoint=False) x = radius * np.cos(angles) y = radius * np.sin(angles) return np.vstack((x, y)).T # shape (n_sides, 2) def wave_displacement(points, sources, k, omega, t, A=1.0): \"\"\" Calculate total displacement at grid points due to all sources at time t. points: array of shape (num_points, 2) with (x, y) positions sources: array of shape (num_sources, 2) with (x, y) source positions k: wave number (2pi / wavelength) omega: angular frequency (2pi * frequency) t: time (seconds) A: amplitude \"\"\" displacement = np.zeros(points.shape[0]) for source in sources: r = np.linalg.norm(points - source, axis=1) r[r == 0] = 1e-10 # prevent division by zero displacement += A * np.cos(k * r - omega * t) return displacement # Simulation parameters n_sides = 5 # number of polygon sides, e.g. pentagon radius = 1.0 # distance from center to vertices (meters) wavelength = 0.5 # meters frequency = 1.0 # Hz k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency amplitude = 1.0 time = 0.0 # time instant for snapshot # Generate polygon vertices (sources) sources = polygon_vertices(radius, n_sides) # Create grid points for simulation x = np.linspace(-2, 2, 400) y = np.linspace(-2, 2, 400) X, Y = np.meshgrid(x, y) points = np.vstack([X.ravel(), Y.ravel()]).T # Calculate total wave displacement at each grid point displacement = wave_displacement(points, sources, k, omega, time, amplitude) Z = displacement.reshape(X.shape) # Plotting the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Displacement') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.title(f'Interference Pattern - {n_sides}-sided Polygon Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.axis('equal') plt.show()","title":"3. Python Simulation Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#considerations","text":"All sources emit waves with identical amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . The waves are coherent, maintaining constant phase relationships. Numerical simulation tools such as Python (with NumPy and Matplotlib) are used for modeling and visualization.","title":"Considerations"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"A Markdown document including the Python script or notebook implementing the simulation. A detailed explanation of the interference patterns observed, related to the polygon shape and wave parameters. Graphical representations showing regions of constructive and destructive interference on the water surface.","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Electromagnetism Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force, expressed as $$ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) $$ governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories that arise due to this force. Task Exploration of Applications: Identify systems where the Lorentz force plays a key role (e.g., particle accelerators, mass spectrometers, plasma confinement). Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling the motion of charged particles. Simulating Particle Motion: Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate the particle\u2019s circular, helical, or drift motion based on initial conditions and field configurations. Parameter Exploration: Allow variations in: Field strengths ( \\(\\mathbf{E}\\) , \\(\\mathbf{B}\\) ). Initial particle velocity ( \\(\\mathbf{v}_0\\) ). Charge and mass of the particle ( \\(q\\) , \\(m\\) ). Observe how these parameters influence the trajectory. Visualization: Create clear, labeled plots showing the particle\u2019s path in 2D and 3D for different scenarios. Highlight physical phenomena such as the Larmor radius and drift velocity. Deliverables A Markdown document with Python script or notebook implementing the simulations. Visualizations of particle trajectories for the specified field configurations. A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps. Suggestions for extending the simulation to more complex scenarios, such as non-uniform fields. Hints and Resources Use numerical methods like the Euler or Runge-Kutta method to solve the equations of motion. Employ Python libraries such as NumPy for calculations and Matplotlib for visualizations. Start with simple cases (e.g., uniform magnetic field) and gradually add complexity (e.g., crossed fields). Python Implementation: Lorentz Force Simulation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # charge (C) m = 9.11e-31 # mass (kg) # Fields (can modify) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) # initial position (m) v0 = np.array([1e5, 0.0, 0.0]) # initial velocity (m/s) # Time parameters dt = 1e-11 # time step (s) t_max = 5e-7 # total time (s) steps = int(t_max / dt) def lorentz_acceleration(v, E, B, q, m): \"\"\"Calculate acceleration due to Lorentz force.\"\"\" return (q / m) * (E + np.cross(v, B)) def rk4_step(r, v, dt, E, B, q, m): \"\"\"Perform one RK4 step for position and velocity.\"\"\" # k1 a1 = lorentz_acceleration(v, E, B, q, m) k1v = a1 * dt k1r = v * dt # k2 a2 = lorentz_acceleration(v + 0.5 * k1v, E, B, q, m) k2v = a2 * dt k2r = (v + 0.5 * k1v) * dt # k3 a3 = lorentz_acceleration(v + 0.5 * k2v, E, B, q, m) k3v = a3 * dt k3r = (v + 0.5 * k2v) * dt # k4 a4 = lorentz_acceleration(v + k3v, E, B, q, m) k4v = a4 * dt k4r = (v + k3v) * dt # Update velocity and position v_next = v + (k1v + 2*k2v + 2*k3v + k4v) / 6 r_next = r + (k1r + 2*k2r + 2*k3r + k4r) / 6 return r_next, v_next # Initialize arrays to store trajectory positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Time evolution for i in range(1, steps): r_new, v_new = rk4_step(positions[i-1], velocities[i-1], dt, E, B, q, m) positions[i] = r_new velocities[i] = v_new # Plotting 3D trajectory fig = plt.figure(figsize=(10,7)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2], lw=1.5) ax.set_title(\"Charged Particle Trajectory under Lorentz Force\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") ax.grid(True) plt.show() Deliverables A Markdown document with Python script or notebook implementing the simulations. Visualizations of particle trajectories for the specified field configurations. A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps. Suggestions for extending the simulation to more complex scenarios, such as non-uniform fields. Hints and Resources Use numerical methods like the Euler or Runge-Kutta method to solve the equations of motion. Employ Python libraries such as NumPy for calculations and Matplotlib for visualizations. Start with simple cases (e.g., uniform magnetic field) and gradually add complexity (e.g., crossed fields).","title":"Electromagnetism"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism","text":"","title":"Electromagnetism"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as $$ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) $$ governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories that arise due to this force.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task","text":"Exploration of Applications: Identify systems where the Lorentz force plays a key role (e.g., particle accelerators, mass spectrometers, plasma confinement). Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling the motion of charged particles. Simulating Particle Motion: Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate the particle\u2019s circular, helical, or drift motion based on initial conditions and field configurations. Parameter Exploration: Allow variations in: Field strengths ( \\(\\mathbf{E}\\) , \\(\\mathbf{B}\\) ). Initial particle velocity ( \\(\\mathbf{v}_0\\) ). Charge and mass of the particle ( \\(q\\) , \\(m\\) ). Observe how these parameters influence the trajectory. Visualization: Create clear, labeled plots showing the particle\u2019s path in 2D and 3D for different scenarios. Highlight physical phenomena such as the Larmor radius and drift velocity.","title":"Task"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. Visualizations of particle trajectories for the specified field configurations. A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps. Suggestions for extending the simulation to more complex scenarios, such as non-uniform fields.","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#hints-and-resources","text":"Use numerical methods like the Euler or Runge-Kutta method to solve the equations of motion. Employ Python libraries such as NumPy for calculations and Matplotlib for visualizations. Start with simple cases (e.g., uniform magnetic field) and gradually add complexity (e.g., crossed fields).","title":"Hints and Resources"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-implementation-lorentz-force-simulation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # charge (C) m = 9.11e-31 # mass (kg) # Fields (can modify) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) # initial position (m) v0 = np.array([1e5, 0.0, 0.0]) # initial velocity (m/s) # Time parameters dt = 1e-11 # time step (s) t_max = 5e-7 # total time (s) steps = int(t_max / dt) def lorentz_acceleration(v, E, B, q, m): \"\"\"Calculate acceleration due to Lorentz force.\"\"\" return (q / m) * (E + np.cross(v, B)) def rk4_step(r, v, dt, E, B, q, m): \"\"\"Perform one RK4 step for position and velocity.\"\"\" # k1 a1 = lorentz_acceleration(v, E, B, q, m) k1v = a1 * dt k1r = v * dt # k2 a2 = lorentz_acceleration(v + 0.5 * k1v, E, B, q, m) k2v = a2 * dt k2r = (v + 0.5 * k1v) * dt # k3 a3 = lorentz_acceleration(v + 0.5 * k2v, E, B, q, m) k3v = a3 * dt k3r = (v + 0.5 * k2v) * dt # k4 a4 = lorentz_acceleration(v + k3v, E, B, q, m) k4v = a4 * dt k4r = (v + k3v) * dt # Update velocity and position v_next = v + (k1v + 2*k2v + 2*k3v + k4v) / 6 r_next = r + (k1r + 2*k2r + 2*k3r + k4r) / 6 return r_next, v_next # Initialize arrays to store trajectory positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Time evolution for i in range(1, steps): r_new, v_new = rk4_step(positions[i-1], velocities[i-1], dt, E, B, q, m) positions[i] = r_new velocities[i] = v_new # Plotting 3D trajectory fig = plt.figure(figsize=(10,7)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2], lw=1.5) ax.set_title(\"Charged Particle Trajectory under Lorentz Force\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") ax.grid(True) plt.show()","title":"Python Implementation: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables_1","text":"A Markdown document with Python script or notebook implementing the simulations. Visualizations of particle trajectories for the specified field configurations. A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps. Suggestions for extending the simulation to more complex scenarios, such as non-uniform fields.","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#hints-and-resources_1","text":"Use numerical methods like the Euler or Runge-Kutta method to solve the equations of motion. Employ Python libraries such as NumPy for calculations and Matplotlib for visualizations. Start with simple cases (e.g., uniform magnetic field) and gradually add complexity (e.g., crossed fields).","title":"Hints and Resources"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}