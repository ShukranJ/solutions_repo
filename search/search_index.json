{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Mechanics \u2013 Problem 1 Investigating the Range as a Function of the Angle of Projection \ud83d\udccc Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. \ud83e\udde0 1. Theoretical Foundation Derivation of Equations of Motion Starting from Newton\u2019s second law: Horizontal motion (no acceleration): [ x(t) = v_0 \\cos(\\theta) t ] Vertical motion (constant downward acceleration): [ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : angle of projection - \\( g \\) : gravitational acceleration - \\( x(t), y(t) \\) : position at time \\( t \\) Time of Flight The projectile hits the ground when \\( y(t) = 0 \\) (assuming launch and landing heights are equal): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin(\\theta)}{g} \\] Horizontal Range \\[ R = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Thus, the range depends on : - \\( v_0^2 \\) : quadratic in initial velocity - \\( \\sin(2\\theta) \\) : maximized at \\( \\theta = 45^\\circ \\) - Inversely proportional to \\( g \\) \ud83d\udcca 2. Analysis of the Range Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0 = 20 # m/s # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Range calculation R = (v0**2) * np.sin(2 * angles_rad) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.axvline(45, color='red', linestyle='--', label='Maximum Range at 45\u00b0') plt.legend() plt.show() \ud83d\udcc8 Observations: Maximum range occurs at \\( \\theta = 45^\\circ \\) Symmetry : The range at angle \\( \\theta \\) is the same as at \\( 90^\\circ - \\theta \\) Increasing \\( v_0 \\) increases the entire curve quadratically Increasing \\( g \\) (e.g., on different planets) compresses the range \ud83c\udf0d 3. Practical Applications Sports : Optimizing throw angles in javelin, soccer, basketball Engineering : Launching projectiles in defense or construction Astrophysics : Trajectories of space probes under planetary gravity Education : Classic introductory example of 2D motion \ud83d\udcbb 4. Implementation The included Python script simulates the range as a function of angle and allows for parameter variation: Change v0 to observe effects of initial speed Modify g to simulate other planets (e.g., Moon or Mars) Extend to 3D or add drag force for realism \u26a0\ufe0f 5. Limitations and Extensions Limitations: Neglects air resistance Assumes level ground Assumes constant gravitational field Ignores spin or shape of projectile Possible Extensions: Add quadratic drag : \\( F_{\\text{drag}} \\propto v^2 \\) Model variable terrain : \\( y(t) \\ne 0 \\) at impact Vary initial height : \\( y_0 > 0 \\) \ud83d\udcce Conclusion Projectile motion offers both analytical beauty and practical relevance . The range as a function of angle exhibits a clear, elegant dependence on \\( \\sin(2\\theta) \\) , and this can be extended in many ways to model real-world systems more closely.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1","text":"","title":"Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"\ud83e\udde0 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Starting from Newton\u2019s second law: Horizontal motion (no acceleration): [ x(t) = v_0 \\cos(\\theta) t ] Vertical motion (constant downward acceleration): [ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : angle of projection - \\( g \\) : gravitational acceleration - \\( x(t), y(t) \\) : position at time \\( t \\)","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile hits the ground when \\( y(t) = 0 \\) (assuming launch and landing heights are equal): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\[ R = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Thus, the range depends on : - \\( v_0^2 \\) : quadratic in initial velocity - \\( \\sin(2\\theta) \\) : maximized at \\( \\theta = 45^\\circ \\) - Inversely proportional to \\( g \\)","title":"Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"\ud83d\udcca 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0 = 20 # m/s # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Range calculation R = (v0**2) * np.sin(2 * angles_rad) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.axvline(45, color='red', linestyle='--', label='Maximum Range at 45\u00b0') plt.legend() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"Maximum range occurs at \\( \\theta = 45^\\circ \\) Symmetry : The range at angle \\( \\theta \\) is the same as at \\( 90^\\circ - \\theta \\) Increasing \\( v_0 \\) increases the entire curve quadratically Increasing \\( g \\) (e.g., on different planets) compresses the range","title":"\ud83d\udcc8 Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimizing throw angles in javelin, soccer, basketball Engineering : Launching projectiles in defense or construction Astrophysics : Trajectories of space probes under planetary gravity Education : Classic introductory example of 2D motion","title":"\ud83c\udf0d 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"The included Python script simulates the range as a function of angle and allows for parameter variation: Change v0 to observe effects of initial speed Modify g to simulate other planets (e.g., Moon or Mars) Extend to 3D or add drag force for realism","title":"\ud83d\udcbb 4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"\u26a0\ufe0f 5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Neglects air resistance Assumes level ground Assumes constant gravitational field Ignores spin or shape of projectile","title":"Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#possible-extensions","text":"Add quadratic drag : \\( F_{\\text{drag}} \\propto v^2 \\) Model variable terrain : \\( y(t) \\ne 0 \\) at impact Vary initial height : \\( y_0 > 0 \\)","title":"Possible Extensions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Projectile motion offers both analytical beauty and practical relevance . The range as a function of angle exhibits a clear, elegant dependence on \\( \\sin(2\\theta) \\) , and this can be extended in many ways to model real-world systems more closely.","title":"\ud83d\udcce Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a classic example of a nonlinear dynamical system exhibiting rich and complex behavior. The interplay between damping, restoring forces, and an external periodic driving force leads to phenomena such as resonance, periodic oscillations, quasiperiodicity, and chaos. This makes the forced damped pendulum a fundamental model for understanding real-world systems in physics and engineering, including driven oscillators, suspension bridges, and energy harvesting devices. Introducing forcing adds parameters such as the amplitude and frequency of the external force. By varying these parameters and the damping coefficient, we observe a wide range of behaviors from simple periodic motion to highly irregular, chaotic dynamics. 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency (with gravitational acceleration \\(g\\) and pendulum length \\(l\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega\\) is the driving frequency. For small angles ( \\(\\theta \\approx 0\\) ), the approximation \\(\\sin \\theta \\approx \\theta\\) linearizes the equation, allowing analytical insights into resonance conditions and steady-state solutions. However, the full nonlinear equation must be solved numerically to explore phenomena such as chaos and complex oscillations. 2. Analysis of Dynamics The behavior of the forced damped pendulum depends critically on the parameters: Damping coefficient \\(\\gamma\\) : Controls energy dissipation. Low damping can allow sustained oscillations; high damping suppresses motion. Driving amplitude \\(A\\) : Determines the strength of the external force. Higher amplitudes can induce complex behaviors. Driving frequency \\(\\omega\\) : Resonance occurs when \\(\\omega \\approx \\omega_0\\) , leading to large amplitude oscillations. By varying these parameters, the system transitions from regular periodic motion to quasiperiodic and chaotic dynamics. The pendulum can synchronize with the drive, oscillate erratically, or even settle into complex attractors. 3. Practical Applications The forced damped pendulum model applies to many real-world systems: Engineering: Design of suspension bridges, vibration absorbers, and mechanical oscillators. Energy harvesting: Devices that capture energy from mechanical vibrations often exploit forced oscillations. Electrical circuits: Analogous behavior occurs in driven RLC circuits. Biomechanics: Understanding human gait and oscillatory motion in biological systems. 4. Implementation: Numerical Simulation in Python The following Python script uses numerical integration to simulate the nonlinear forced damped pendulum. The scipy.integrate.solve_ivp function applies a Runge-Kutta method to solve the system of first-order ODEs: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) gamma = 0.5 # damping coefficient A = 1.2 # driving force amplitude omega_drive = 2/3 # driving frequency omega0 = np.sqrt(g / l) # natural frequency # Define the system of equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions: small displacement and zero initial velocity y0 = [0.2, 0.0] # Time span and points for evaluation t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(12, 6)) plt.plot(sol.t, sol.y[0], label='Angular displacement \u03b8 (rad)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() plt.show() 5. Visualization of Phase Space To better understand the system\u2019s behavior, we plot the phase portrait showing angular displacement \\( \\theta \\) versus angular velocity \\( \\omega = \\frac{d\\theta}{dt} \\) : plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], linewidth=0.5) plt.xlabel('\u03b8 (radians)') plt.ylabel('Angular velocity \u03c9 (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.grid(True) plt.show() Extensions and Further Analysis Poincar\u00e9 Sections: Sampling the system state at intervals equal to the driving period reveals discrete points that can classify motion types. Bifurcation Diagrams: Sweeping the driving amplitude or frequency and plotting long-term behavior illustrates transitions to chaos. Nonlinear damping: Including terms dependent on \\( \\omega^2 \\) or velocity cubed can better model real frictional forces. Non-periodic driving: Studying random or quasi-periodic forcing introduces further complexity relevant in natural systems. Limitations The small-angle approximation is insufficient for large oscillations. Real pendulums may experience non-ideal friction, air resistance, and structural flexibility. The model assumes a rigid rod and point mass bob. Numerical solutions may require fine time resolution and careful handling of chaotic sensitivity. Conclusion The forced damped pendulum offers profound insights into nonlinear dynamics, illustrating how simple systems can exhibit complex and unpredictable behavior. Numerical simulations combined with phase space analysis enable exploration beyond analytic solutions, providing a window into resonance, chaos, and real-world oscillatory phenomena.","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic example of a nonlinear dynamical system exhibiting rich and complex behavior. The interplay between damping, restoring forces, and an external periodic driving force leads to phenomena such as resonance, periodic oscillations, quasiperiodicity, and chaos. This makes the forced damped pendulum a fundamental model for understanding real-world systems in physics and engineering, including driven oscillators, suspension bridges, and energy harvesting devices. Introducing forcing adds parameters such as the amplitude and frequency of the external force. By varying these parameters and the damping coefficient, we observe a wide range of behaviors from simple periodic motion to highly irregular, chaotic dynamics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency (with gravitational acceleration \\(g\\) and pendulum length \\(l\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega\\) is the driving frequency. For small angles ( \\(\\theta \\approx 0\\) ), the approximation \\(\\sin \\theta \\approx \\theta\\) linearizes the equation, allowing analytical insights into resonance conditions and steady-state solutions. However, the full nonlinear equation must be solved numerically to explore phenomena such as chaos and complex oscillations.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The behavior of the forced damped pendulum depends critically on the parameters: Damping coefficient \\(\\gamma\\) : Controls energy dissipation. Low damping can allow sustained oscillations; high damping suppresses motion. Driving amplitude \\(A\\) : Determines the strength of the external force. Higher amplitudes can induce complex behaviors. Driving frequency \\(\\omega\\) : Resonance occurs when \\(\\omega \\approx \\omega_0\\) , leading to large amplitude oscillations. By varying these parameters, the system transitions from regular periodic motion to quasiperiodic and chaotic dynamics. The pendulum can synchronize with the drive, oscillate erratically, or even settle into complex attractors.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to many real-world systems: Engineering: Design of suspension bridges, vibration absorbers, and mechanical oscillators. Energy harvesting: Devices that capture energy from mechanical vibrations often exploit forced oscillations. Electrical circuits: Analogous behavior occurs in driven RLC circuits. Biomechanics: Understanding human gait and oscillatory motion in biological systems.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-numerical-simulation-in-python","text":"The following Python script uses numerical integration to simulate the nonlinear forced damped pendulum. The scipy.integrate.solve_ivp function applies a Runge-Kutta method to solve the system of first-order ODEs: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) gamma = 0.5 # damping coefficient A = 1.2 # driving force amplitude omega_drive = 2/3 # driving frequency omega0 = np.sqrt(g / l) # natural frequency # Define the system of equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions: small displacement and zero initial velocity y0 = [0.2, 0.0] # Time span and points for evaluation t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(12, 6)) plt.plot(sol.t, sol.y[0], label='Angular displacement \u03b8 (rad)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() plt.show()","title":"4. Implementation: Numerical Simulation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-visualization-of-phase-space","text":"To better understand the system\u2019s behavior, we plot the phase portrait showing angular displacement \\( \\theta \\) versus angular velocity \\( \\omega = \\frac{d\\theta}{dt} \\) : plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], linewidth=0.5) plt.xlabel('\u03b8 (radians)') plt.ylabel('Angular velocity \u03c9 (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.grid(True) plt.show() Extensions and Further Analysis Poincar\u00e9 Sections: Sampling the system state at intervals equal to the driving period reveals discrete points that can classify motion types. Bifurcation Diagrams: Sweeping the driving amplitude or frequency and plotting long-term behavior illustrates transitions to chaos. Nonlinear damping: Including terms dependent on \\( \\omega^2 \\) or velocity cubed can better model real frictional forces. Non-periodic driving: Studying random or quasi-periodic forcing introduces further complexity relevant in natural systems. Limitations The small-angle approximation is insufficient for large oscillations. Real pendulums may experience non-ideal friction, air resistance, and structural flexibility. The model assumes a rigid rod and point mass bob. Numerical solutions may require fine time resolution and careful handling of chaotic sensitivity. Conclusion The forced damped pendulum offers profound insights into nonlinear dynamics, illustrating how simple systems can exhibit complex and unpredictable behavior. Numerical simulations combined with phase space analysis enable exploration beyond analytic solutions, providing a window into resonance, chaos, and real-world oscillatory phenomena.","title":"5. Visualization of Phase Space"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1: Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law reveals a profound connection between the time it takes a celestial object to complete an orbit and its distance from the object it orbits. It\u2019s a cornerstone in celestial mechanics, useful for estimating distances, predicting motion, and determining masses of astronomical objects. This relationship, when derived from Newtonian gravitation, also helps bridge classical and modern physics. 1. Theoretical Derivation Consider a small object of mass \\( m \\) orbiting a large central mass \\( M \\) in a circular orbit of radius \\( r \\) and period \\( T \\) . Gravitational Force Provides Centripetal Force \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and rearranging: \\[ v^2 = \\frac{G M}{r} \\] Substitute \\( v = \\frac{2\\pi r}{T} \\) : \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 Kepler\u2019s Third Law for Circular Orbits : $$ T^2 \\propto r^3 $$ This shows the square of the orbital period is proportional to the cube of the orbital radius. 2. Astronomical Implications Used to calculate planetary distances when the period is known (and vice versa). Allows estimation of the mass of central objects (e.g., planets, stars). Critical in satellite deployment , planet hunting , and galactic dynamics . 3. Real-World Examples Example 1: The Moon Orbiting Earth Given: - Orbital radius: \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) - Mass of Earth: \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - Gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} \\) Using the orbital period formula: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\approx 2.36 \\times 10^6 \\, \\text{s} \\approx 27.3 \\, \\text{days} \\] This matches the observed sidereal period of the Moon. Example 2: Planetary Orbits in the Solar System When using astronomical units (AU) for distance and years for time, Kepler\u2019s Third Law simplifies to: T\u00b2 = r\u00b3 where - T is the orbital period in years - r is the orbital radius in AU For example: Earth : r = 1 AU \u21d2 T = 1 year Mars : r = 1.52 AU \u21d2 T\u00b2 = (1.52)\u00b3 = 3.51 \u21d2 T = \u221a3.51 \u2248 1.87 years This matches well with the actual orbital period of Mars. 4. Python Simulation and Visualization import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 1.989e30 # Mass of the Sun in kg # Orbital radii (in meters) radii = np.linspace(5e10, 3e12, 100) # From 0.33 AU to ~20 AU # Calculate periods using Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to show the linear relationship plt.figure(figsize=(8, 6)) plt.plot(radii**3, periods**2) plt.xlabel('Orbital Radius Cubed (r\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Kepler\u2019s Third Law: T\u00b2 vs r\u00b3') plt.grid(True) plt.show() 5. Extension: Elliptical Orbits For elliptical orbits, Kepler\u2019s Third Law generalizes to: \\[ T^2 = \\frac{4 \\pi^2}{G M} a^3 \\] where - \\( T \\) is the orbital period, - \\( a \\) is the semi-major axis of the ellipse, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. The relationship still holds true, making Kepler\u2019s Third Law a powerful tool even beyond circular orbit approximations. 6. Conclusion Kepler\u2019s Third Law, derived from Newtonian mechanics, elegantly explains the orbital dynamics of planets and satellites. It allows astronomers to deduce distances and masses from simple observations and remains foundational in both theoretical and applied astrophysics.","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law reveals a profound connection between the time it takes a celestial object to complete an orbit and its distance from the object it orbits. It\u2019s a cornerstone in celestial mechanics, useful for estimating distances, predicting motion, and determining masses of astronomical objects. This relationship, when derived from Newtonian gravitation, also helps bridge classical and modern physics.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"Consider a small object of mass \\( m \\) orbiting a large central mass \\( M \\) in a circular orbit of radius \\( r \\) and period \\( T \\) .","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravitational-force-provides-centripetal-force","text":"\\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and rearranging: \\[ v^2 = \\frac{G M}{r} \\] Substitute \\( v = \\frac{2\\pi r}{T} \\) : \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 Kepler\u2019s Third Law for Circular Orbits : $$ T^2 \\propto r^3 $$ This shows the square of the orbital period is proportional to the cube of the orbital radius.","title":"Gravitational Force Provides Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"Used to calculate planetary distances when the period is known (and vice versa). Allows estimation of the mass of central objects (e.g., planets, stars). Critical in satellite deployment , planet hunting , and galactic dynamics .","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moon-orbiting-earth","text":"Given: - Orbital radius: \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) - Mass of Earth: \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - Gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} \\) Using the orbital period formula: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\approx 2.36 \\times 10^6 \\, \\text{s} \\approx 27.3 \\, \\text{days} \\] This matches the observed sidereal period of the Moon.","title":"Example 1: The Moon Orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planetary-orbits-in-the-solar-system","text":"When using astronomical units (AU) for distance and years for time, Kepler\u2019s Third Law simplifies to: T\u00b2 = r\u00b3 where - T is the orbital period in years - r is the orbital radius in AU For example: Earth : r = 1 AU \u21d2 T = 1 year Mars : r = 1.52 AU \u21d2 T\u00b2 = (1.52)\u00b3 = 3.51 \u21d2 T = \u221a3.51 \u2248 1.87 years This matches well with the actual orbital period of Mars.","title":"Example 2: Planetary Orbits in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 1.989e30 # Mass of the Sun in kg # Orbital radii (in meters) radii = np.linspace(5e10, 3e12, 100) # From 0.33 AU to ~20 AU # Calculate periods using Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to show the linear relationship plt.figure(figsize=(8, 6)) plt.plot(radii**3, periods**2) plt.xlabel('Orbital Radius Cubed (r\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Kepler\u2019s Third Law: T\u00b2 vs r\u00b3') plt.grid(True) plt.show()","title":"4. Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-elliptical-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law generalizes to: \\[ T^2 = \\frac{4 \\pi^2}{G M} a^3 \\] where - \\( T \\) is the orbital period, - \\( a \\) is the semi-major axis of the ellipse, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. The relationship still holds true, making Kepler\u2019s Third Law a powerful tool even beyond circular orbit approximations.","title":"5. Extension: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-conclusion","text":"Kepler\u2019s Third Law, derived from Newtonian mechanics, elegantly explains the orbital dynamics of planets and satellites. It allows astronomers to deduce distances and masses from simple observations and remains foundational in both theoretical and applied astrophysics.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation Understanding escape velocity is fundamental to grasping how spacecraft leave a celestial body's gravitational influence. Beyond escape velocity, the first, second, and third cosmic velocities set thresholds for orbiting a planet, escaping it, and even leaving the star system. These concepts are the foundation of launching satellites, planning interplanetary missions, and envisioning future interstellar travel. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) The minimum velocity an object must have to stay in a stable low circular orbit around a celestial body without falling back to the surface. Physically: It balances gravitational pull with centripetal force to maintain orbit. Second Cosmic Velocity (Escape Velocity) The minimum velocity needed to escape the gravitational field of the celestial body completely without further propulsion. Physically: It allows an object to reach infinite distance with zero kinetic energy left. Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape the gravitational influence of the star system (e.g., the Sun), assuming the object starts from the planet's surface. Physically: It combines escape from the planet plus the additional velocity to overcome the star's gravity. Mathematical Derivations 1. First Cosmic Velocity \\( v_1 \\) For a circular orbit of radius \\( r \\) (usually the planet\u2019s radius plus altitude, but here surface orbit is approximated as radius \\( R \\) ): $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where: \\( G \\) is the universal gravitational constant, approximately $$ G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $$ \\( M \\) is the mass of the celestial body (kg). \\( R \\) is the radius of the celestial body (m). 2. Second Cosmic Velocity \\( v_2 \\) (Escape velocity from the planet) The escape velocity is derived from energy conservation, where the kinetic energy equals the gravitational potential energy required to escape the gravitational field of the planet. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\, v_1 \\] 3. Third Cosmic Velocity \\( v_3 \\) (Escape velocity from the star system) This velocity corresponds to the minimum speed needed to escape the gravitational influence of the star system (e.g., the Sun), assuming the spacecraft is launched from the surface of the planet. The spacecraft must overcome the gravitational potentials of both the planet and the star at the planet\u2019s orbital radius. Let: \\( r_s \\) be the orbital radius of the planet around the star (distance from the star to the planet). \\( M_s \\) be the mass of the star. Then, \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{esc,star}}^2} \\] where \\[ v_{\\text{esc,star}} = \\sqrt{\\frac{2GM_s}{r_s}} \\] and \\( v_2 \\) is the escape velocity from the planet as above. Parameters for Earth, Mars, and Jupiter Body Mass (kg) Radius (m) Orbital Radius from Sun (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^{6}\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.39 \\times 10^{23}\\) \\(3.3895 \\times 10^{6}\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^{7}\\) \\(7.785 \\times 10^{11}\\) Sun mass: \\[ M_s = 1.989 \\times 10^{30} \\, \\text{kg} \\] Python Code to Calculate and Visualize Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Celestial bodies data bodies = { \"Earth\": { \"mass\": 5.972e24, \"radius\": 6.371e6, \"orbit_radius\": 1.496e11 }, \"Mars\": { \"mass\": 6.39e23, \"radius\": 3.3895e6, \"orbit_radius\": 2.279e11 }, \"Jupiter\": { \"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbit_radius\": 7.785e11 } } # Compute velocities results = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] r_s = data[\"orbit_radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity (orbit) v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity (escape planet) v_esc_star = np.sqrt(2 * G * M_sun / r_s) # Escape velocity from Sun at planet orbit v3 = np.sqrt(v2**2 + v_esc_star**2) # Third cosmic velocity (escape star system) results[body] = { \"First Cosmic Velocity (km/s)\": v1 / 1000, \"Second Cosmic Velocity (km/s)\": v2 / 1000, \"Third Cosmic Velocity (km/s)\": v3 / 1000 } # Display results for body, velocities in results.items(): print(f\"{body}:\") for desc, val in velocities.items(): print(f\" {desc}: {val:.2f} km/s\") print() # Visualization labels = list(results.keys()) v1_vals = [results[b][\"First Cosmic Velocity (km/s)\"] for b in labels] v2_vals = [results[b][\"Second Cosmic Velocity (km/s)\"] for b in labels] v3_vals = [results[b][\"Third Cosmic Velocity (km/s)\"] for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True, axis='y') plt.show() Discussion and Importance in Space Exploration The First Cosmic Velocity is essential for satellites. Any satellite must reach at least this velocity to maintain a stable orbit, preventing it from falling back to the planet. For Earth, this velocity is about 7.9 km/s. The Second Cosmic Velocity (Escape Velocity) is critical for spacecraft leaving a planet's gravity without continuous propulsion. Rockets must accelerate beyond this velocity to enter interplanetary trajectories. The Third Cosmic Velocity relates to leaving the star system entirely, enabling potential interstellar missions. It requires combining escape from the planet plus enough velocity to overcome the star's gravity. For Earth, this is around 16.7 km/s. These velocities guide mission planning, fuel requirements, and the design of propulsion systems. Understanding and achieving them are the backbone of satellite launches, interplanetary probes (e.g., Mars rovers), and future interstellar exploration concepts. Summary First cosmic velocity \u2014 orbital velocity around a planet. Second cosmic velocity \u2014 escape velocity from the planet. Third cosmic velocity \u2014 escape velocity from the star system (e.g., the Sun). These velocities vary by celestial body due to differences in mass, radius, and distance from the star, reflecting their unique gravitational environments.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding escape velocity is fundamental to grasping how spacecraft leave a celestial body's gravitational influence. Beyond escape velocity, the first, second, and third cosmic velocities set thresholds for orbiting a planet, escaping it, and even leaving the star system. These concepts are the foundation of launching satellites, planning interplanetary missions, and envisioning future interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity) The minimum velocity an object must have to stay in a stable low circular orbit around a celestial body without falling back to the surface. Physically: It balances gravitational pull with centripetal force to maintain orbit. Second Cosmic Velocity (Escape Velocity) The minimum velocity needed to escape the gravitational field of the celestial body completely without further propulsion. Physically: It allows an object to reach infinite distance with zero kinetic energy left. Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape the gravitational influence of the star system (e.g., the Sun), assuming the object starts from the planet's surface. Physically: It combines escape from the planet plus the additional velocity to overcome the star's gravity.","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"For a circular orbit of radius \\( r \\) (usually the planet\u2019s radius plus altitude, but here surface orbit is approximated as radius \\( R \\) ): $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where: \\( G \\) is the universal gravitational constant, approximately $$ G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $$ \\( M \\) is the mass of the celestial body (kg). \\( R \\) is the radius of the celestial body (m).","title":"1. First Cosmic Velocity \\( v_1 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2-escape-velocity-from-the-planet","text":"The escape velocity is derived from energy conservation, where the kinetic energy equals the gravitational potential energy required to escape the gravitational field of the planet. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\, v_1 \\]","title":"2. Second Cosmic Velocity \\( v_2 \\) (Escape velocity from the planet)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3-escape-velocity-from-the-star-system","text":"This velocity corresponds to the minimum speed needed to escape the gravitational influence of the star system (e.g., the Sun), assuming the spacecraft is launched from the surface of the planet. The spacecraft must overcome the gravitational potentials of both the planet and the star at the planet\u2019s orbital radius. Let: \\( r_s \\) be the orbital radius of the planet around the star (distance from the star to the planet). \\( M_s \\) be the mass of the star. Then, \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{esc,star}}^2} \\] where \\[ v_{\\text{esc,star}} = \\sqrt{\\frac{2GM_s}{r_s}} \\] and \\( v_2 \\) is the escape velocity from the planet as above.","title":"3. Third Cosmic Velocity \\( v_3 \\) (Escape velocity from the star system)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-for-earth-mars-and-jupiter","text":"Body Mass (kg) Radius (m) Orbital Radius from Sun (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^{6}\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.39 \\times 10^{23}\\) \\(3.3895 \\times 10^{6}\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^{7}\\) \\(7.785 \\times 10^{11}\\) Sun mass: \\[ M_s = 1.989 \\times 10^{30} \\, \\text{kg} \\]","title":"Parameters for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-to-calculate-and-visualize-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Celestial bodies data bodies = { \"Earth\": { \"mass\": 5.972e24, \"radius\": 6.371e6, \"orbit_radius\": 1.496e11 }, \"Mars\": { \"mass\": 6.39e23, \"radius\": 3.3895e6, \"orbit_radius\": 2.279e11 }, \"Jupiter\": { \"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbit_radius\": 7.785e11 } } # Compute velocities results = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] r_s = data[\"orbit_radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity (orbit) v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity (escape planet) v_esc_star = np.sqrt(2 * G * M_sun / r_s) # Escape velocity from Sun at planet orbit v3 = np.sqrt(v2**2 + v_esc_star**2) # Third cosmic velocity (escape star system) results[body] = { \"First Cosmic Velocity (km/s)\": v1 / 1000, \"Second Cosmic Velocity (km/s)\": v2 / 1000, \"Third Cosmic Velocity (km/s)\": v3 / 1000 } # Display results for body, velocities in results.items(): print(f\"{body}:\") for desc, val in velocities.items(): print(f\" {desc}: {val:.2f} km/s\") print() # Visualization labels = list(results.keys()) v1_vals = [results[b][\"First Cosmic Velocity (km/s)\"] for b in labels] v2_vals = [results[b][\"Second Cosmic Velocity (km/s)\"] for b in labels] v3_vals = [results[b][\"Third Cosmic Velocity (km/s)\"] for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True, axis='y') plt.show()","title":"Python Code to Calculate and Visualize Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#discussion-and-importance-in-space-exploration","text":"The First Cosmic Velocity is essential for satellites. Any satellite must reach at least this velocity to maintain a stable orbit, preventing it from falling back to the planet. For Earth, this velocity is about 7.9 km/s. The Second Cosmic Velocity (Escape Velocity) is critical for spacecraft leaving a planet's gravity without continuous propulsion. Rockets must accelerate beyond this velocity to enter interplanetary trajectories. The Third Cosmic Velocity relates to leaving the star system entirely, enabling potential interstellar missions. It requires combining escape from the planet plus enough velocity to overcome the star's gravity. For Earth, this is around 16.7 km/s. These velocities guide mission planning, fuel requirements, and the design of propulsion systems. Understanding and achieving them are the backbone of satellite launches, interplanetary probes (e.g., Mars rovers), and future interstellar exploration concepts.","title":"Discussion and Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"First cosmic velocity \u2014 orbital velocity around a planet. Second cosmic velocity \u2014 escape velocity from the planet. Third cosmic velocity \u2014 escape velocity from the star system (e.g., the Sun). These velocities vary by celestial body due to differences in mass, radius, and distance from the star, reflecting their unique gravitational environments.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth 1. Introduction and Theory When a payload is released from a moving rocket near Earth, its motion is influenced primarily by Earth's gravity. The trajectory depends on the initial velocity, position, and altitude. Based on these initial conditions, the path can be one of the following: Elliptical orbit (closed orbit around Earth), Parabolic trajectory (the borderline between bound and unbound orbits), Hyperbolic trajectory (escape trajectory). Governing Physics The gravitational force acting on the payload is described by Newton's Law of Gravitation : \\[ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} \\] where: \\( G \\) is the gravitational constant, \\(6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\mathrm{kg}^{-1} \\mathrm{s}^{-2} \\) , \\( M \\) is the mass of Earth, \\(5.972 \\times 10^{24} \\, \\mathrm{kg} \\) , \\( m \\) is the payload mass (which cancels out in the acceleration), \\( r \\) is the distance from Earth's center to the payload, \\( \\hat{r} \\) is the unit vector pointing from Earth to the payload. The equation of motion under Earth's gravity is: \\[ \\mathbf{\\ddot{r}} = -\\frac{GM}{r^3} \\mathbf{r} \\] where \\(\\mathbf{r}\\) is the position vector of the payload relative to Earth's center. Escape Velocity The escape velocity at distance \\(r\\) from Earth's center is: \\[ v_{\\mathrm{esc}} = \\sqrt{\\frac{2GM}{r}} \\] If the payload's velocity \\(v < v_{\\mathrm{esc}}\\) , it follows an elliptical orbit. If \\(v = v_{\\mathrm{esc}}\\) , it follows a parabolic trajectory. If \\(v > v_{\\mathrm{esc}}\\) , it follows a hyperbolic trajectory and escapes Earth. 2. Numerical Method and Simulation Setup To analyze the trajectory numerically, we solve the second-order differential equation of motion by converting it into a system of first-order ordinary differential equations (ODEs): Define the state vector: \\[ \\mathbf{y} = (x, y, v_x, v_y) \\] where \\((x,y)\\) is the payload position and \\((v_x, v_y)\\) are the velocity components in a 2D plane. The equations become: \\[ \\begin{cases} \\dot{x} = v_x \\\\ \\dot{y} = v_y \\\\ \\dot{v_x} = -\\frac{GM}{r^3} x \\\\ \\dot{v_y} = -\\frac{GM}{r^3} y \\end{cases} \\] with \\[ r = \\sqrt{x^2 + y^2} \\] We use numerical ODE solvers such as Python's scipy.integrate.solve_ivp to simulate the motion over time, given initial conditions for position and velocity. 3. Python Implementation for Trajectory Simulation The following Python script numerically simulates the payload's trajectory under Earth's gravity using the scipy.integrate.solve_ivp solver. It models the 2D motion by solving the system of ordinary differential equations derived in the previous section. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth, kg R_earth = 6371e3 # radius of Earth, meters def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(initial_pos, initial_vel, t_span=[0, 5000], max_step=1): y0 = [initial_pos[0], initial_pos[1], initial_vel[0], initial_vel[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8) return sol def plot_trajectory(sol, title='Payload Trajectory'): x = sol.y[0] / 1e3 # convert meters to kilometers y = sol.y[1] / 1e3 plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') earth = plt.Circle((0, 0), R_earth / 1e3, color='b', alpha=0.3, label='Earth') plt.gca().add_patch(earth) plt.xlabel('X (km)') plt.ylabel('Y (km)') plt.title(title) plt.axis('equal') plt.legend() plt.grid(True) plt.show() # Example initial conditions: altitude = 400e3 # 400 km above Earth's surface r0 = R_earth + altitude # Initial position at (r0, 0) initial_pos = np.array([r0, 0]) # Circular orbital velocity at altitude v_circular = np.sqrt(G * M / r0) # Initial velocities for different trajectories initial_vel_circular = np.array([0, v_circular]) # Circular orbit initial_vel_elliptical = np.array([0, 0.9 * np.sqrt(2) * v_circular]) # Elliptical orbit initial_vel_parabolic = np.array([0, np.sqrt(2) * v_circular]) # Parabolic escape initial_vel_hyperbolic = np.array([0, 1.1 * np.sqrt(2) * v_circular]) # Hyperbolic escape # Run simulations sol_circular = simulate_trajectory(initial_pos, initial_vel_circular) sol_elliptical = simulate_trajectory(initial_pos, initial_vel_elliptical) sol_parabolic = simulate_trajectory(initial_pos, initial_vel_parabolic, t_span=[0, 10000]) sol_hyperbolic = simulate_trajectory(initial_pos, initial_vel_hyperbolic, t_span=[0, 10000]) # Plot the results plot_trajectory(sol_circular, 'Circular Orbit') plot_trajectory(sol_elliptical, 'Elliptical Orbit') plot_trajectory(sol_parabolic, 'Parabolic Escape Trajectory') plot_trajectory(sol_hyperbolic, 'Hyperbolic Escape Trajectory') 4. Discussion Elliptical orbit: Initial velocity is less than the escape velocity; the payload remains gravitationally bound, orbiting Earth. Parabolic trajectory: Payload escapes Earth but with zero excess velocity at infinity \u2014 representing a delicate boundary case between bound and unbound orbits. Hyperbolic trajectory: Payload escapes Earth with positive excess velocity, meaning it will not return. Circular orbit: A special case of an elliptical orbit where the velocity is exactly the circular orbital velocity at the given altitude. 5. Real-World Applications Orbital insertion: Adjusting the payload\u2019s velocity to achieve elliptical or circular orbits around Earth. Reentry scenarios: Payload velocity decreases so the trajectory intersects Earth's atmosphere, enabling controlled return. Escape trajectories: Missions designed to leave Earth orbit entirely (e.g., interplanetary probes and deep space missions).","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction-and-theory","text":"When a payload is released from a moving rocket near Earth, its motion is influenced primarily by Earth's gravity. The trajectory depends on the initial velocity, position, and altitude. Based on these initial conditions, the path can be one of the following: Elliptical orbit (closed orbit around Earth), Parabolic trajectory (the borderline between bound and unbound orbits), Hyperbolic trajectory (escape trajectory).","title":"1. Introduction and Theory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-physics","text":"The gravitational force acting on the payload is described by Newton's Law of Gravitation : \\[ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} \\] where: \\( G \\) is the gravitational constant, \\(6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\mathrm{kg}^{-1} \\mathrm{s}^{-2} \\) , \\( M \\) is the mass of Earth, \\(5.972 \\times 10^{24} \\, \\mathrm{kg} \\) , \\( m \\) is the payload mass (which cancels out in the acceleration), \\( r \\) is the distance from Earth's center to the payload, \\( \\hat{r} \\) is the unit vector pointing from Earth to the payload. The equation of motion under Earth's gravity is: \\[ \\mathbf{\\ddot{r}} = -\\frac{GM}{r^3} \\mathbf{r} \\] where \\(\\mathbf{r}\\) is the position vector of the payload relative to Earth's center.","title":"Governing Physics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity at distance \\(r\\) from Earth's center is: \\[ v_{\\mathrm{esc}} = \\sqrt{\\frac{2GM}{r}} \\] If the payload's velocity \\(v < v_{\\mathrm{esc}}\\) , it follows an elliptical orbit. If \\(v = v_{\\mathrm{esc}}\\) , it follows a parabolic trajectory. If \\(v > v_{\\mathrm{esc}}\\) , it follows a hyperbolic trajectory and escapes Earth.","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-method-and-simulation-setup","text":"To analyze the trajectory numerically, we solve the second-order differential equation of motion by converting it into a system of first-order ordinary differential equations (ODEs): Define the state vector: \\[ \\mathbf{y} = (x, y, v_x, v_y) \\] where \\((x,y)\\) is the payload position and \\((v_x, v_y)\\) are the velocity components in a 2D plane. The equations become: \\[ \\begin{cases} \\dot{x} = v_x \\\\ \\dot{y} = v_y \\\\ \\dot{v_x} = -\\frac{GM}{r^3} x \\\\ \\dot{v_y} = -\\frac{GM}{r^3} y \\end{cases} \\] with \\[ r = \\sqrt{x^2 + y^2} \\] We use numerical ODE solvers such as Python's scipy.integrate.solve_ivp to simulate the motion over time, given initial conditions for position and velocity.","title":"2. Numerical Method and Simulation Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-implementation-for-trajectory-simulation","text":"The following Python script numerically simulates the payload's trajectory under Earth's gravity using the scipy.integrate.solve_ivp solver. It models the 2D motion by solving the system of ordinary differential equations derived in the previous section. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth, kg R_earth = 6371e3 # radius of Earth, meters def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(initial_pos, initial_vel, t_span=[0, 5000], max_step=1): y0 = [initial_pos[0], initial_pos[1], initial_vel[0], initial_vel[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8) return sol def plot_trajectory(sol, title='Payload Trajectory'): x = sol.y[0] / 1e3 # convert meters to kilometers y = sol.y[1] / 1e3 plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') earth = plt.Circle((0, 0), R_earth / 1e3, color='b', alpha=0.3, label='Earth') plt.gca().add_patch(earth) plt.xlabel('X (km)') plt.ylabel('Y (km)') plt.title(title) plt.axis('equal') plt.legend() plt.grid(True) plt.show() # Example initial conditions: altitude = 400e3 # 400 km above Earth's surface r0 = R_earth + altitude # Initial position at (r0, 0) initial_pos = np.array([r0, 0]) # Circular orbital velocity at altitude v_circular = np.sqrt(G * M / r0) # Initial velocities for different trajectories initial_vel_circular = np.array([0, v_circular]) # Circular orbit initial_vel_elliptical = np.array([0, 0.9 * np.sqrt(2) * v_circular]) # Elliptical orbit initial_vel_parabolic = np.array([0, np.sqrt(2) * v_circular]) # Parabolic escape initial_vel_hyperbolic = np.array([0, 1.1 * np.sqrt(2) * v_circular]) # Hyperbolic escape # Run simulations sol_circular = simulate_trajectory(initial_pos, initial_vel_circular) sol_elliptical = simulate_trajectory(initial_pos, initial_vel_elliptical) sol_parabolic = simulate_trajectory(initial_pos, initial_vel_parabolic, t_span=[0, 10000]) sol_hyperbolic = simulate_trajectory(initial_pos, initial_vel_hyperbolic, t_span=[0, 10000]) # Plot the results plot_trajectory(sol_circular, 'Circular Orbit') plot_trajectory(sol_elliptical, 'Elliptical Orbit') plot_trajectory(sol_parabolic, 'Parabolic Escape Trajectory') plot_trajectory(sol_hyperbolic, 'Hyperbolic Escape Trajectory')","title":"3. Python Implementation for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-discussion","text":"Elliptical orbit: Initial velocity is less than the escape velocity; the payload remains gravitationally bound, orbiting Earth. Parabolic trajectory: Payload escapes Earth but with zero excess velocity at infinity \u2014 representing a delicate boundary case between bound and unbound orbits. Hyperbolic trajectory: Payload escapes Earth with positive excess velocity, meaning it will not return. Circular orbit: A special case of an elliptical orbit where the velocity is exactly the circular orbital velocity at the given altitude.","title":"4. Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-real-world-applications","text":"Orbital insertion: Adjusting the payload\u2019s velocity to achieve elliptical or circular orbits around Earth. Reentry scenarios: Payload velocity decreases so the trajectory intersects Earth's atmosphere, enabling controlled return. Escape trajectories: Missions designed to leave Earth orbit entirely (e.g., interplanetary probes and deep space missions).","title":"5. Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Waves \u2014 Interference Patterns on a Water Surface \ud83d\udd0d Problem 1: Interference Patterns on a Water Surface \ud83e\udde0 Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is seen when ripples from different points meet, forming areas where waves reinforce or cancel each other out. This experiment helps us visually understand key concepts in wave physics, such as coherence, phase difference, and constructive/destructive interference. \ud83c\udfaf Task Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon . \ud83d\udee0\ufe0f Steps to Follow 1. Select a Regular Polygon We choose a square with 4 point sources at the vertices. 2. Position the Sources The sources are placed evenly on a circle (radius = 3 units), forming a square. 3. Wave Equation Each wave from a source \\((x_i, y_i)\\) is given by: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: - \\( A \\) : amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number - \\( \\omega = 2\\pi f \\) : angular frequency - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : distance from source to point - \\( \\phi \\) : initial phase (same for all sources) 4. Superposition of Waves \\[ \\psi_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\] 5. Analyze Interference We visualize the total wave field \\(\\psi_{\\text{total}}(x, y, t)\\) to identify constructive and destructive interference regions. \ud83d\udc0d Python Simulation Code import numpy as np import matplotlib.pyplot as plt Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength \u03bb frequency = 1.0 # Frequency f phi = 0 # Initial phase N = 4 # Number of sources (square) radius = 3 # Radius of the polygon Derived parameters k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency Define polygon vertices angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] Create grid x = np.linspace(-6, 6, 500) y = np.linspace(-6, 6, 500) X, Y = np.meshgrid(x, y) t = 0 # Snapshot at t=0 Superposition of waves Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0) 2 + (Y - y0) 2) Z += A * np.cos(k * r - omega * t + phi) Visualization plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.title('Interference Pattern from 4 Point Sources (Square)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"\ud83c\udf0a Waves \u2014 Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#waves-interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Waves \u2014 Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1-interference-patterns-on-a-water-surface","text":"","title":"\ud83d\udd0d Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is seen when ripples from different points meet, forming areas where waves reinforce or cancel each other out. This experiment helps us visually understand key concepts in wave physics, such as coherence, phase difference, and constructive/destructive interference.","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon .","title":"\ud83c\udfaf Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"","title":"\ud83d\udee0\ufe0f Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-select-a-regular-polygon","text":"We choose a square with 4 point sources at the vertices.","title":"1. Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-position-the-sources","text":"The sources are placed evenly on a circle (radius = 3 units), forming a square.","title":"2. Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-wave-equation","text":"Each wave from a source \\((x_i, y_i)\\) is given by: \\[ \\psi_i(x, y, t) = A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: - \\( A \\) : amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number - \\( \\omega = 2\\pi f \\) : angular frequency - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : distance from source to point - \\( \\phi \\) : initial phase (same for all sources)","title":"3. Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-of-waves","text":"\\[ \\psi_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) \\]","title":"4. Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyze-interference","text":"We visualize the total wave field \\(\\psi_{\\text{total}}(x, y, t)\\) to identify constructive and destructive interference regions.","title":"5. Analyze Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udc0d Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-parameters","text":"A = 1.0 # Amplitude wavelength = 1.0 # Wavelength \u03bb frequency = 1.0 # Frequency f phi = 0 # Initial phase N = 4 # Number of sources (square) radius = 3 # Radius of the polygon","title":"Wave parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#derived-parameters","text":"k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency","title":"Derived parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#define-polygon-vertices","text":"angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles]","title":"Define polygon vertices"},{"location":"1%20Physics/3%20Waves/Problem_1/#create-grid","text":"x = np.linspace(-6, 6, 500) y = np.linspace(-6, 6, 500) X, Y = np.meshgrid(x, y) t = 0 # Snapshot at t=0","title":"Create grid"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0) 2 + (Y - y0) 2) Z += A * np.cos(k * r - omega * t + phi)","title":"Superposition of waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization","text":"plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.title('Interference Pattern from 4 Point Sources (Square)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \u26a1 Electromagnetism \u2014 Problem 1: Simulating the Effects of the Lorentz Force \ud83e\udde0 Motivation The Lorentz force , given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] is the fundamental law describing the motion of a charged particle in electric and magnetic fields. It plays a crucial role in many advanced technologies and physical systems, including: Particle Accelerators (e.g., cyclotrons, synchrotrons) Mass Spectrometers Plasma Confinement Devices (e.g., Tokamaks) Astrophysical Plasmas Through simulation, we can visualize how the Lorentz force influences particle trajectories and gain deeper insights into both theory and applications. \ud83d\udd0d 1. Exploration of Applications Systems where the Lorentz Force is Crucial: Particle Accelerators : Charged particles are bent into circular paths using magnetic fields; acceleration occurs via electric fields. Mass Spectrometers : The deflection of ions in a magnetic field depends on their mass-to-charge ratio. Fusion Reactors : Magnetic fields confine hot plasma, exploiting the Lorentz force to keep particles from hitting the reactor walls. Role of Fields: Electric Fields ( \\(\\vec{E}\\) ) accelerate or decelerate particles linearly. Magnetic Fields ( \\(\\vec{B}\\) ) bend the particle's path, causing circular or helical motion, but do not change speed. \ud83e\uddea 2. Simulating Particle Motion We simulate the particle's trajectory by solving Newton's Second Law: \\[ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This system is solved numerically using the Euler method for simplicity. \ud83d\udc0d Python Code for Simulating the Lorentz Force ```python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D Constants q = 1.6e-19 # charge (Coulombs) m = 9.11e-31 # mass (kg) E = np.array([0, 0, 0]) # electric field (V/m) B = np.array([0, 0, 1]) # magnetic field (T) Initial conditions v0 = np.array([1e6, 0, 1e6]) # initial velocity (m/s) r0 = np.array([0, 0, 0]) # initial position (m) Time parameters dt = 1e-11 # time step (s) T = 1e-7 # total time (s) steps = int(T / dt) Initialize arrays r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 Euler method for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt Plotting in 3D fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Particle Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Trajectory of a Charged Particle in a Magnetic Field') ax.legend() plt.tight_layout() plt.show() \u2699\ufe0f 3. Parameter Exploration To better understand how different variables affect the trajectory of a charged particle under the Lorentz force, we explore the effects of changing key parameters: \ud83d\udd27 Parameters to Vary: Magnetic Field Strength and Direction ( \\(\\vec{B}\\) ): Example: Vary from \\( \\vec{B} = [0, 0, 1] \\) to \\( \\vec{B} = [1, 0, 1] \\) Observe change in curvature and spiral tightness Electric Field ( \\(\\vec{E}\\) ): Add a uniform electric field to see drift motion Example: \\( \\vec{E} = [1 \\times 10^5, 0, 0] \\) Initial Velocity ( \\(\\vec{v}_0\\) ): Change magnitude and orientation Observe transition from circular to helical motion Charge ( \\(q\\) ) and Mass ( \\(m\\) ) : Switch from electron to proton (higher mass, same charge magnitude) Observe the effect on Larmor radius and acceleration \ud83e\uddea Observational Goals: How increasing magnetic field strength tightens circular motion. How introducing electric fields leads to E \u00d7 B drift . How heavier particles (e.g., protons) move slower under the same force. \ud83d\udcca 4. Visualization of Trajectories We generate 2D and 3D plots of the particle\u2019s motion using matplotlib . \u2705 Visual Cues: Color-coded or labeled axes Plotting time-dependent trajectories: XY view shows circular motion XZ or 3D view shows helical motion if initial velocity has a component parallel to \\(\\vec{B}\\) \ud83c\udf00 Physical Quantities to Highlight: Larmor Radius (gyroradius): \\[ r_L = \\frac{mv_{\\perp}}{qB} \\] Where \\(v_{\\perp}\\) is the velocity component perpendicular to \\(\\vec{B}\\) . Cyclotron Frequency: \\[ \\omega_c = \\frac{qB}{m} \\] This determines the angular frequency of circular motion in the magnetic field. Drift Velocity (for crossed fields): \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Visible as a net translation over time when both \\(\\vec{E}\\) and \\(\\vec{B}\\) are present and orthogonal. \ud83d\udcac Discussion of Results Key Observations: With only magnetic fields , charged particles move in circular or helical paths depending on velocity orientation. Adding an electric field parallel to velocity increases acceleration. When \\(\\vec{E}\\) and \\(\\vec{B}\\) are perpendicular , the particle exhibits a drift in a direction perpendicular to both fields. The radius of curvature increases with particle mass or decreasing magnetic field strength. Energy remains constant in magnetic-only scenarios since the magnetic field does no work. \ud83c\udf0d Real-World Applications \u2699\ufe0f Practical Systems: Application Role of Lorentz Force Cyclotrons Spiral acceleration using B fields Mass Spectrometers Measure mass/charge via deflection Plasma Traps Use magnetic confinement in fusion Earth\u2019s Magnetosphere Charged particle motion explains auroras In each case, control over \\(\\vec{E}\\) and \\(\\vec{B}\\) is essential for guiding particle motion. \ud83d\ude80 Suggestions for Extensions To expand the simulation: Use a Runge-Kutta (RK4) solver for better accuracy Add non-uniform fields (gradients, dipoles) Model particle collisions or radiation loss Simulate a plasma (many particles with charge interactions) Implement relativistic corrections at high speeds \ud83d\udce6 Deliverables Recap \u2705 Python script simulating Lorentz force dynamics \u2705 2D and 3D plots of trajectories under various field configurations \u2705 Parameter analysis and visualizations of motion types \u2705 Discussion of physical significance and real-world relevance \u2705 Suggestions for future improvements and added complexity","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"\u26a1 Electromagnetism \u2014 Problem 1: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force , given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] is the fundamental law describing the motion of a charged particle in electric and magnetic fields. It plays a crucial role in many advanced technologies and physical systems, including: Particle Accelerators (e.g., cyclotrons, synchrotrons) Mass Spectrometers Plasma Confinement Devices (e.g., Tokamaks) Astrophysical Plasmas Through simulation, we can visualize how the Lorentz force influences particle trajectories and gain deeper insights into both theory and applications.","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"","title":"\ud83d\udd0d 1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#systems-where-the-lorentz-force-is-crucial","text":"Particle Accelerators : Charged particles are bent into circular paths using magnetic fields; acceleration occurs via electric fields. Mass Spectrometers : The deflection of ions in a magnetic field depends on their mass-to-charge ratio. Fusion Reactors : Magnetic fields confine hot plasma, exploiting the Lorentz force to keep particles from hitting the reactor walls.","title":"Systems where the Lorentz Force is Crucial:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#role-of-fields","text":"Electric Fields ( \\(\\vec{E}\\) ) accelerate or decelerate particles linearly. Magnetic Fields ( \\(\\vec{B}\\) ) bend the particle's path, causing circular or helical motion, but do not change speed.","title":"Role of Fields:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We simulate the particle's trajectory by solving Newton's Second Law: \\[ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This system is solved numerically using the Euler method for simplicity.","title":"\ud83e\uddea 2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-for-simulating-the-lorentz-force","text":"```python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D","title":"\ud83d\udc0d Python Code for Simulating the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#constants","text":"q = 1.6e-19 # charge (Coulombs) m = 9.11e-31 # mass (kg) E = np.array([0, 0, 0]) # electric field (V/m) B = np.array([0, 0, 1]) # magnetic field (T)","title":"Constants"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#initial-conditions","text":"v0 = np.array([1e6, 0, 1e6]) # initial velocity (m/s) r0 = np.array([0, 0, 0]) # initial position (m)","title":"Initial conditions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#time-parameters","text":"dt = 1e-11 # time step (s) T = 1e-7 # total time (s) steps = int(T / dt)","title":"Time parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#initialize-arrays","text":"r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0","title":"Initialize arrays"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#euler-method","text":"for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt","title":"Euler method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plotting-in-3d","text":"fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Particle Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Trajectory of a Charged Particle in a Magnetic Field') ax.legend() plt.tight_layout() plt.show()","title":"Plotting in 3D"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"To better understand how different variables affect the trajectory of a charged particle under the Lorentz force, we explore the effects of changing key parameters:","title":"\u2699\ufe0f 3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters-to-vary","text":"Magnetic Field Strength and Direction ( \\(\\vec{B}\\) ): Example: Vary from \\( \\vec{B} = [0, 0, 1] \\) to \\( \\vec{B} = [1, 0, 1] \\) Observe change in curvature and spiral tightness Electric Field ( \\(\\vec{E}\\) ): Add a uniform electric field to see drift motion Example: \\( \\vec{E} = [1 \\times 10^5, 0, 0] \\) Initial Velocity ( \\(\\vec{v}_0\\) ): Change magnitude and orientation Observe transition from circular to helical motion Charge ( \\(q\\) ) and Mass ( \\(m\\) ) : Switch from electron to proton (higher mass, same charge magnitude) Observe the effect on Larmor radius and acceleration","title":"\ud83d\udd27 Parameters to Vary:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observational-goals","text":"How increasing magnetic field strength tightens circular motion. How introducing electric fields leads to E \u00d7 B drift . How heavier particles (e.g., protons) move slower under the same force.","title":"\ud83e\uddea Observational Goals:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization-of-trajectories","text":"We generate 2D and 3D plots of the particle\u2019s motion using matplotlib .","title":"\ud83d\udcca 4. Visualization of Trajectories"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visual-cues","text":"Color-coded or labeled axes Plotting time-dependent trajectories: XY view shows circular motion XZ or 3D view shows helical motion if initial velocity has a component parallel to \\(\\vec{B}\\)","title":"\u2705 Visual Cues:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-quantities-to-highlight","text":"Larmor Radius (gyroradius): \\[ r_L = \\frac{mv_{\\perp}}{qB} \\] Where \\(v_{\\perp}\\) is the velocity component perpendicular to \\(\\vec{B}\\) . Cyclotron Frequency: \\[ \\omega_c = \\frac{qB}{m} \\] This determines the angular frequency of circular motion in the magnetic field. Drift Velocity (for crossed fields): \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Visible as a net translation over time when both \\(\\vec{E}\\) and \\(\\vec{B}\\) are present and orthogonal.","title":"\ud83c\udf00 Physical Quantities to Highlight:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#discussion-of-results","text":"","title":"\ud83d\udcac Discussion of Results"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-observations","text":"With only magnetic fields , charged particles move in circular or helical paths depending on velocity orientation. Adding an electric field parallel to velocity increases acceleration. When \\(\\vec{E}\\) and \\(\\vec{B}\\) are perpendicular , the particle exhibits a drift in a direction perpendicular to both fields. The radius of curvature increases with particle mass or decreasing magnetic field strength. Energy remains constant in magnetic-only scenarios since the magnetic field does no work.","title":"Key Observations:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-applications","text":"","title":"\ud83c\udf0d Real-World Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#practical-systems","text":"Application Role of Lorentz Force Cyclotrons Spiral acceleration using B fields Mass Spectrometers Measure mass/charge via deflection Plasma Traps Use magnetic confinement in fusion Earth\u2019s Magnetosphere Charged particle motion explains auroras In each case, control over \\(\\vec{E}\\) and \\(\\vec{B}\\) is essential for guiding particle motion.","title":"\u2699\ufe0f Practical Systems:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#suggestions-for-extensions","text":"To expand the simulation: Use a Runge-Kutta (RK4) solver for better accuracy Add non-uniform fields (gradients, dipoles) Model particle collisions or radiation loss Simulate a plasma (many particles with charge interactions) Implement relativistic corrections at high speeds","title":"\ud83d\ude80 Suggestions for Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables-recap","text":"\u2705 Python script simulating Lorentz force dynamics \u2705 2D and 3D plots of trajectories under various field configurations \u2705 Parameter analysis and visualizations of motion types \u2705 Discussion of physical significance and real-world relevance \u2705 Suggestions for future improvements and added complexity","title":"\ud83d\udce6 Deliverables Recap"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}