{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Mechanics \u2013 Problem 1 Investigating the Range as a Function of the Angle of Projection \ud83d\udccc Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. \ud83e\udde0 1. Theoretical Foundation Derivation of Equations of Motion Starting from Newton\u2019s second law: Horizontal motion (no acceleration): [ x(t) = v_0 \\cos(\\theta) t ] Vertical motion (constant downward acceleration): [ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : angle of projection - \\( g \\) : gravitational acceleration - \\( x(t), y(t) \\) : position at time \\( t \\) Time of Flight The projectile hits the ground when \\( y(t) = 0 \\) (assuming launch and landing heights are equal): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin(\\theta)}{g} \\] Horizontal Range \\[ R = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Thus, the range depends on : - \\( v_0^2 \\) : quadratic in initial velocity - \\( \\sin(2\\theta) \\) : maximized at \\( \\theta = 45^\\circ \\) - Inversely proportional to \\( g \\) \ud83d\udcca 2. Analysis of the Range Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0 = 20 # m/s # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Range calculation R = (v0**2) * np.sin(2 * angles_rad) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.axvline(45, color='red', linestyle='--', label='Maximum Range at 45\u00b0') plt.legend() plt.show() \ud83d\udcc8 Observations: Maximum range occurs at \\( \\theta = 45^\\circ \\) Symmetry : The range at angle \\( \\theta \\) is the same as at \\( 90^\\circ - \\theta \\) Increasing \\( v_0 \\) increases the entire curve quadratically Increasing \\( g \\) (e.g., on different planets) compresses the range \ud83c\udf0d 3. Practical Applications Sports : Optimizing throw angles in javelin, soccer, basketball Engineering : Launching projectiles in defense or construction Astrophysics : Trajectories of space probes under planetary gravity Education : Classic introductory example of 2D motion \ud83d\udcbb 4. Implementation The included Python script simulates the range as a function of angle and allows for parameter variation: Change v0 to observe effects of initial speed Modify g to simulate other planets (e.g., Moon or Mars) Extend to 3D or add drag force for realism \u26a0\ufe0f 5. Limitations and Extensions Limitations: Neglects air resistance Assumes level ground Assumes constant gravitational field Ignores spin or shape of projectile Possible Extensions: Add quadratic drag : \\( F_{\\text{drag}} \\propto v^2 \\) Model variable terrain : \\( y(t) \\ne 0 \\) at impact Vary initial height : \\( y_0 > 0 \\) \ud83d\udcce Conclusion Projectile motion offers both analytical beauty and practical relevance . The range as a function of angle exhibits a clear, elegant dependence on \\( \\sin(2\\theta) \\) , and this can be extended in many ways to model real-world systems more closely.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1","text":"","title":"Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"\ud83e\udde0 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Starting from Newton\u2019s second law: Horizontal motion (no acceleration): [ x(t) = v_0 \\cos(\\theta) t ] Vertical motion (constant downward acceleration): [ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : angle of projection - \\( g \\) : gravitational acceleration - \\( x(t), y(t) \\) : position at time \\( t \\)","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile hits the ground when \\( y(t) = 0 \\) (assuming launch and landing heights are equal): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\[ R = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Thus, the range depends on : - \\( v_0^2 \\) : quadratic in initial velocity - \\( \\sin(2\\theta) \\) : maximized at \\( \\theta = 45^\\circ \\) - Inversely proportional to \\( g \\)","title":"Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"\ud83d\udcca 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0 = 20 # m/s # Angles from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) # Range calculation R = (v0**2) * np.sin(2 * angles_rad) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.legend() plt.axvline(45, color='red', linestyle='--', label='Maximum Range at 45\u00b0') plt.legend() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"Maximum range occurs at \\( \\theta = 45^\\circ \\) Symmetry : The range at angle \\( \\theta \\) is the same as at \\( 90^\\circ - \\theta \\) Increasing \\( v_0 \\) increases the entire curve quadratically Increasing \\( g \\) (e.g., on different planets) compresses the range","title":"\ud83d\udcc8 Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimizing throw angles in javelin, soccer, basketball Engineering : Launching projectiles in defense or construction Astrophysics : Trajectories of space probes under planetary gravity Education : Classic introductory example of 2D motion","title":"\ud83c\udf0d 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"The included Python script simulates the range as a function of angle and allows for parameter variation: Change v0 to observe effects of initial speed Modify g to simulate other planets (e.g., Moon or Mars) Extend to 3D or add drag force for realism","title":"\ud83d\udcbb 4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"\u26a0\ufe0f 5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Neglects air resistance Assumes level ground Assumes constant gravitational field Ignores spin or shape of projectile","title":"Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#possible-extensions","text":"Add quadratic drag : \\( F_{\\text{drag}} \\propto v^2 \\) Model variable terrain : \\( y(t) \\ne 0 \\) at impact Vary initial height : \\( y_0 > 0 \\)","title":"Possible Extensions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Projectile motion offers both analytical beauty and practical relevance . The range as a function of angle exhibits a clear, elegant dependence on \\( \\sin(2\\theta) \\) , and this can be extended in many ways to model real-world systems more closely.","title":"\ud83d\udcce Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a classic example of a nonlinear dynamical system exhibiting rich and complex behavior. The interplay between damping, restoring forces, and an external periodic driving force leads to phenomena such as resonance, periodic oscillations, quasiperiodicity, and chaos. This makes the forced damped pendulum a fundamental model for understanding real-world systems in physics and engineering, including driven oscillators, suspension bridges, and energy harvesting devices. Introducing forcing adds parameters such as the amplitude and frequency of the external force. By varying these parameters and the damping coefficient, we observe a wide range of behaviors from simple periodic motion to highly irregular, chaotic dynamics. 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency (with gravitational acceleration \\(g\\) and pendulum length \\(l\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega\\) is the driving frequency. For small angles ( \\(\\theta \\approx 0\\) ), the approximation \\(\\sin \\theta \\approx \\theta\\) linearizes the equation, allowing analytical insights into resonance conditions and steady-state solutions. However, the full nonlinear equation must be solved numerically to explore phenomena such as chaos and complex oscillations. 2. Analysis of Dynamics The behavior of the forced damped pendulum depends critically on the parameters: Damping coefficient \\(\\gamma\\) : Controls energy dissipation. Low damping can allow sustained oscillations; high damping suppresses motion. Driving amplitude \\(A\\) : Determines the strength of the external force. Higher amplitudes can induce complex behaviors. Driving frequency \\(\\omega\\) : Resonance occurs when \\(\\omega \\approx \\omega_0\\) , leading to large amplitude oscillations. By varying these parameters, the system transitions from regular periodic motion to quasiperiodic and chaotic dynamics. The pendulum can synchronize with the drive, oscillate erratically, or even settle into complex attractors. 3. Practical Applications The forced damped pendulum model applies to many real-world systems: Engineering: Design of suspension bridges, vibration absorbers, and mechanical oscillators. Energy harvesting: Devices that capture energy from mechanical vibrations often exploit forced oscillations. Electrical circuits: Analogous behavior occurs in driven RLC circuits. Biomechanics: Understanding human gait and oscillatory motion in biological systems. 4. Implementation: Numerical Simulation in Python The following Python script uses numerical integration to simulate the nonlinear forced damped pendulum. The scipy.integrate.solve_ivp function applies a Runge-Kutta method to solve the system of first-order ODEs: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) gamma = 0.5 # damping coefficient A = 1.2 # driving force amplitude omega_drive = 2/3 # driving frequency omega0 = np.sqrt(g / l) # natural frequency # Define the system of equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions: small displacement and zero initial velocity y0 = [0.2, 0.0] # Time span and points for evaluation t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(12, 6)) plt.plot(sol.t, sol.y[0], label='Angular displacement \u03b8 (rad)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() plt.show() 5. Visualization of Phase Space To better understand the system\u2019s behavior, we plot the phase portrait showing angular displacement \\( \\theta \\) versus angular velocity \\( \\omega = \\frac{d\\theta}{dt} \\) : plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], linewidth=0.5) plt.xlabel('\u03b8 (radians)') plt.ylabel('Angular velocity \u03c9 (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.grid(True) plt.show() Extensions and Further Analysis Poincar\u00e9 Sections: Sampling the system state at intervals equal to the driving period reveals discrete points that can classify motion types. Bifurcation Diagrams: Sweeping the driving amplitude or frequency and plotting long-term behavior illustrates transitions to chaos. Nonlinear damping: Including terms dependent on \\( \\omega^2 \\) or velocity cubed can better model real frictional forces. Non-periodic driving: Studying random or quasi-periodic forcing introduces further complexity relevant in natural systems. Limitations The small-angle approximation is insufficient for large oscillations. Real pendulums may experience non-ideal friction, air resistance, and structural flexibility. The model assumes a rigid rod and point mass bob. Numerical solutions may require fine time resolution and careful handling of chaotic sensitivity. Conclusion The forced damped pendulum offers profound insights into nonlinear dynamics, illustrating how simple systems can exhibit complex and unpredictable behavior. Numerical simulations combined with phase space analysis enable exploration beyond analytic solutions, providing a window into resonance, chaos, and real-world oscillatory phenomena.","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic example of a nonlinear dynamical system exhibiting rich and complex behavior. The interplay between damping, restoring forces, and an external periodic driving force leads to phenomena such as resonance, periodic oscillations, quasiperiodicity, and chaos. This makes the forced damped pendulum a fundamental model for understanding real-world systems in physics and engineering, including driven oscillators, suspension bridges, and energy harvesting devices. Introducing forcing adds parameters such as the amplitude and frequency of the external force. By varying these parameters and the damping coefficient, we observe a wide range of behaviors from simple periodic motion to highly irregular, chaotic dynamics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = A \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\gamma\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency (with gravitational acceleration \\(g\\) and pendulum length \\(l\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega\\) is the driving frequency. For small angles ( \\(\\theta \\approx 0\\) ), the approximation \\(\\sin \\theta \\approx \\theta\\) linearizes the equation, allowing analytical insights into resonance conditions and steady-state solutions. However, the full nonlinear equation must be solved numerically to explore phenomena such as chaos and complex oscillations.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The behavior of the forced damped pendulum depends critically on the parameters: Damping coefficient \\(\\gamma\\) : Controls energy dissipation. Low damping can allow sustained oscillations; high damping suppresses motion. Driving amplitude \\(A\\) : Determines the strength of the external force. Higher amplitudes can induce complex behaviors. Driving frequency \\(\\omega\\) : Resonance occurs when \\(\\omega \\approx \\omega_0\\) , leading to large amplitude oscillations. By varying these parameters, the system transitions from regular periodic motion to quasiperiodic and chaotic dynamics. The pendulum can synchronize with the drive, oscillate erratically, or even settle into complex attractors.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to many real-world systems: Engineering: Design of suspension bridges, vibration absorbers, and mechanical oscillators. Energy harvesting: Devices that capture energy from mechanical vibrations often exploit forced oscillations. Electrical circuits: Analogous behavior occurs in driven RLC circuits. Biomechanics: Understanding human gait and oscillatory motion in biological systems.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-numerical-simulation-in-python","text":"The following Python script uses numerical integration to simulate the nonlinear forced damped pendulum. The scipy.integrate.solve_ivp function applies a Runge-Kutta method to solve the system of first-order ODEs: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) gamma = 0.5 # damping coefficient A = 1.2 # driving force amplitude omega_drive = 2/3 # driving frequency omega0 = np.sqrt(g / l) # natural frequency # Define the system of equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions: small displacement and zero initial velocity y0 = [0.2, 0.0] # Time span and points for evaluation t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(12, 6)) plt.plot(sol.t, sol.y[0], label='Angular displacement \u03b8 (rad)') plt.xlabel('Time (s)') plt.ylabel('\u03b8 (radians)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() plt.show()","title":"4. Implementation: Numerical Simulation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-visualization-of-phase-space","text":"To better understand the system\u2019s behavior, we plot the phase portrait showing angular displacement \\( \\theta \\) versus angular velocity \\( \\omega = \\frac{d\\theta}{dt} \\) : plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], linewidth=0.5) plt.xlabel('\u03b8 (radians)') plt.ylabel('Angular velocity \u03c9 (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.grid(True) plt.show() Extensions and Further Analysis Poincar\u00e9 Sections: Sampling the system state at intervals equal to the driving period reveals discrete points that can classify motion types. Bifurcation Diagrams: Sweeping the driving amplitude or frequency and plotting long-term behavior illustrates transitions to chaos. Nonlinear damping: Including terms dependent on \\( \\omega^2 \\) or velocity cubed can better model real frictional forces. Non-periodic driving: Studying random or quasi-periodic forcing introduces further complexity relevant in natural systems. Limitations The small-angle approximation is insufficient for large oscillations. Real pendulums may experience non-ideal friction, air resistance, and structural flexibility. The model assumes a rigid rod and point mass bob. Numerical solutions may require fine time resolution and careful handling of chaotic sensitivity. Conclusion The forced damped pendulum offers profound insights into nonlinear dynamics, illustrating how simple systems can exhibit complex and unpredictable behavior. Numerical simulations combined with phase space analysis enable exploration beyond analytic solutions, providing a window into resonance, chaos, and real-world oscillatory phenomena.","title":"5. Visualization of Phase Space"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1: Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law reveals a profound connection between the time it takes a celestial object to complete an orbit and its distance from the object it orbits. It\u2019s a cornerstone in celestial mechanics, useful for estimating distances, predicting motion, and determining masses of astronomical objects. This relationship, when derived from Newtonian gravitation, also helps bridge classical and modern physics. 1. Theoretical Derivation Consider a small object of mass \\( m \\) orbiting a large central mass \\( M \\) in a circular orbit of radius \\( r \\) and period \\( T \\) . Gravitational Force Provides Centripetal Force \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and rearranging: \\[ v^2 = \\frac{G M}{r} \\] Substitute \\( v = \\frac{2\\pi r}{T} \\) : \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 Kepler\u2019s Third Law for Circular Orbits : $$ T^2 \\propto r^3 $$ This shows the square of the orbital period is proportional to the cube of the orbital radius. 2. Astronomical Implications Used to calculate planetary distances when the period is known (and vice versa). Allows estimation of the mass of central objects (e.g., planets, stars). Critical in satellite deployment , planet hunting , and galactic dynamics . 3. Real-World Examples Example 1: The Moon Orbiting Earth Given: - Orbital radius: \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) - Mass of Earth: \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - Gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} \\) Using the orbital period formula: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\approx 2.36 \\times 10^6 \\, \\text{s} \\approx 27.3 \\, \\text{days} \\] This matches the observed sidereal period of the Moon. Example 2: Planetary Orbits in the Solar System When using astronomical units (AU) for distance and years for time, Kepler\u2019s Third Law simplifies to: T\u00b2 = r\u00b3 where - T is the orbital period in years - r is the orbital radius in AU For example: Earth : r = 1 AU \u21d2 T = 1 year Mars : r = 1.52 AU \u21d2 T\u00b2 = (1.52)\u00b3 = 3.51 \u21d2 T = \u221a3.51 \u2248 1.87 years This matches well with the actual orbital period of Mars. 4. Python Simulation and Visualization import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 1.989e30 # Mass of the Sun in kg # Orbital radii (in meters) radii = np.linspace(5e10, 3e12, 100) # From 0.33 AU to ~20 AU # Calculate periods using Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to show the linear relationship plt.figure(figsize=(8, 6)) plt.plot(radii**3, periods**2) plt.xlabel('Orbital Radius Cubed (r\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Kepler\u2019s Third Law: T\u00b2 vs r\u00b3') plt.grid(True) plt.show() 5. Extension: Elliptical Orbits For elliptical orbits, Kepler\u2019s Third Law generalizes to: \\[ T^2 = \\frac{4 \\pi^2}{G M} a^3 \\] where - \\( T \\) is the orbital period, - \\( a \\) is the semi-major axis of the ellipse, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. The relationship still holds true, making Kepler\u2019s Third Law a powerful tool even beyond circular orbit approximations. 6. Conclusion Kepler\u2019s Third Law, derived from Newtonian mechanics, elegantly explains the orbital dynamics of planets and satellites. It allows astronomers to deduce distances and masses from simple observations and remains foundational in both theoretical and applied astrophysics.","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law reveals a profound connection between the time it takes a celestial object to complete an orbit and its distance from the object it orbits. It\u2019s a cornerstone in celestial mechanics, useful for estimating distances, predicting motion, and determining masses of astronomical objects. This relationship, when derived from Newtonian gravitation, also helps bridge classical and modern physics.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"Consider a small object of mass \\( m \\) orbiting a large central mass \\( M \\) in a circular orbit of radius \\( r \\) and period \\( T \\) .","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravitational-force-provides-centripetal-force","text":"\\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and rearranging: \\[ v^2 = \\frac{G M}{r} \\] Substitute \\( v = \\frac{2\\pi r}{T} \\) : \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 Kepler\u2019s Third Law for Circular Orbits : $$ T^2 \\propto r^3 $$ This shows the square of the orbital period is proportional to the cube of the orbital radius.","title":"Gravitational Force Provides Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"Used to calculate planetary distances when the period is known (and vice versa). Allows estimation of the mass of central objects (e.g., planets, stars). Critical in satellite deployment , planet hunting , and galactic dynamics .","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moon-orbiting-earth","text":"Given: - Orbital radius: \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) - Mass of Earth: \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - Gravitational constant: \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2} \\) Using the orbital period formula: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\approx 2.36 \\times 10^6 \\, \\text{s} \\approx 27.3 \\, \\text{days} \\] This matches the observed sidereal period of the Moon.","title":"Example 1: The Moon Orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planetary-orbits-in-the-solar-system","text":"When using astronomical units (AU) for distance and years for time, Kepler\u2019s Third Law simplifies to: T\u00b2 = r\u00b3 where - T is the orbital period in years - r is the orbital radius in AU For example: Earth : r = 1 AU \u21d2 T = 1 year Mars : r = 1.52 AU \u21d2 T\u00b2 = (1.52)\u00b3 = 3.51 \u21d2 T = \u221a3.51 \u2248 1.87 years This matches well with the actual orbital period of Mars.","title":"Example 2: Planetary Orbits in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 1.989e30 # Mass of the Sun in kg # Orbital radii (in meters) radii = np.linspace(5e10, 3e12, 100) # From 0.33 AU to ~20 AU # Calculate periods using Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot T^2 vs r^3 to show the linear relationship plt.figure(figsize=(8, 6)) plt.plot(radii**3, periods**2) plt.xlabel('Orbital Radius Cubed (r\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Kepler\u2019s Third Law: T\u00b2 vs r\u00b3') plt.grid(True) plt.show()","title":"4. Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-elliptical-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law generalizes to: \\[ T^2 = \\frac{4 \\pi^2}{G M} a^3 \\] where - \\( T \\) is the orbital period, - \\( a \\) is the semi-major axis of the ellipse, - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body. The relationship still holds true, making Kepler\u2019s Third Law a powerful tool even beyond circular orbit approximations.","title":"5. Extension: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-conclusion","text":"Kepler\u2019s Third Law, derived from Newtonian mechanics, elegantly explains the orbital dynamics of planets and satellites. It allows astronomers to deduce distances and masses from simple observations and remains foundational in both theoretical and applied astrophysics.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation Understanding escape velocity is fundamental to grasping how spacecraft leave a celestial body's gravitational influence. Beyond escape velocity, the first, second, and third cosmic velocities set thresholds for orbiting a planet, escaping it, and even leaving the star system. These concepts are the foundation of launching satellites, planning interplanetary missions, and envisioning future interstellar travel. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) The minimum velocity an object must have to stay in a stable low circular orbit around a celestial body without falling back to the surface. Physically: It balances gravitational pull with centripetal force to maintain orbit. Second Cosmic Velocity (Escape Velocity) The minimum velocity needed to escape the gravitational field of the celestial body completely without further propulsion. Physically: It allows an object to reach infinite distance with zero kinetic energy left. Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape the gravitational influence of the star system (e.g., the Sun), assuming the object starts from the planet's surface. Physically: It combines escape from the planet plus the additional velocity to overcome the star's gravity. Mathematical Derivations 1. First Cosmic Velocity \\( v_1 \\) For a circular orbit of radius \\( r \\) (usually the planet\u2019s radius plus altitude, but here surface orbit is approximated as radius \\( R \\) ): $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where: \\( G \\) is the universal gravitational constant, approximately $$ G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $$ \\( M \\) is the mass of the celestial body (kg). \\( R \\) is the radius of the celestial body (m). 2. Second Cosmic Velocity \\( v_2 \\) (Escape velocity from the planet) The escape velocity is derived from energy conservation, where the kinetic energy equals the gravitational potential energy required to escape the gravitational field of the planet. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\, v_1 \\] 3. Third Cosmic Velocity \\( v_3 \\) (Escape velocity from the star system) This velocity corresponds to the minimum speed needed to escape the gravitational influence of the star system (e.g., the Sun), assuming the spacecraft is launched from the surface of the planet. The spacecraft must overcome the gravitational potentials of both the planet and the star at the planet\u2019s orbital radius. Let: \\( r_s \\) be the orbital radius of the planet around the star (distance from the star to the planet). \\( M_s \\) be the mass of the star. Then, \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{esc,star}}^2} \\] where \\[ v_{\\text{esc,star}} = \\sqrt{\\frac{2GM_s}{r_s}} \\] and \\( v_2 \\) is the escape velocity from the planet as above. Parameters for Earth, Mars, and Jupiter Body Mass (kg) Radius (m) Orbital Radius from Sun (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^{6}\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.39 \\times 10^{23}\\) \\(3.3895 \\times 10^{6}\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^{7}\\) \\(7.785 \\times 10^{11}\\) Sun mass: \\[ M_s = 1.989 \\times 10^{30} \\, \\text{kg} \\] Python Code to Calculate and Visualize Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Celestial bodies data bodies = { \"Earth\": { \"mass\": 5.972e24, \"radius\": 6.371e6, \"orbit_radius\": 1.496e11 }, \"Mars\": { \"mass\": 6.39e23, \"radius\": 3.3895e6, \"orbit_radius\": 2.279e11 }, \"Jupiter\": { \"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbit_radius\": 7.785e11 } } # Compute velocities results = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] r_s = data[\"orbit_radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity (orbit) v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity (escape planet) v_esc_star = np.sqrt(2 * G * M_sun / r_s) # Escape velocity from Sun at planet orbit v3 = np.sqrt(v2**2 + v_esc_star**2) # Third cosmic velocity (escape star system) results[body] = { \"First Cosmic Velocity (km/s)\": v1 / 1000, \"Second Cosmic Velocity (km/s)\": v2 / 1000, \"Third Cosmic Velocity (km/s)\": v3 / 1000 } # Display results for body, velocities in results.items(): print(f\"{body}:\") for desc, val in velocities.items(): print(f\" {desc}: {val:.2f} km/s\") print() # Visualization labels = list(results.keys()) v1_vals = [results[b][\"First Cosmic Velocity (km/s)\"] for b in labels] v2_vals = [results[b][\"Second Cosmic Velocity (km/s)\"] for b in labels] v3_vals = [results[b][\"Third Cosmic Velocity (km/s)\"] for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True, axis='y') plt.show() Discussion and Importance in Space Exploration The First Cosmic Velocity is essential for satellites. Any satellite must reach at least this velocity to maintain a stable orbit, preventing it from falling back to the planet. For Earth, this velocity is about 7.9 km/s. The Second Cosmic Velocity (Escape Velocity) is critical for spacecraft leaving a planet's gravity without continuous propulsion. Rockets must accelerate beyond this velocity to enter interplanetary trajectories. The Third Cosmic Velocity relates to leaving the star system entirely, enabling potential interstellar missions. It requires combining escape from the planet plus enough velocity to overcome the star's gravity. For Earth, this is around 16.7 km/s. These velocities guide mission planning, fuel requirements, and the design of propulsion systems. Understanding and achieving them are the backbone of satellite launches, interplanetary probes (e.g., Mars rovers), and future interstellar exploration concepts. Summary First cosmic velocity \u2014 orbital velocity around a planet. Second cosmic velocity \u2014 escape velocity from the planet. Third cosmic velocity \u2014 escape velocity from the star system (e.g., the Sun). These velocities vary by celestial body due to differences in mass, radius, and distance from the star, reflecting their unique gravitational environments.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding escape velocity is fundamental to grasping how spacecraft leave a celestial body's gravitational influence. Beyond escape velocity, the first, second, and third cosmic velocities set thresholds for orbiting a planet, escaping it, and even leaving the star system. These concepts are the foundation of launching satellites, planning interplanetary missions, and envisioning future interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity) The minimum velocity an object must have to stay in a stable low circular orbit around a celestial body without falling back to the surface. Physically: It balances gravitational pull with centripetal force to maintain orbit. Second Cosmic Velocity (Escape Velocity) The minimum velocity needed to escape the gravitational field of the celestial body completely without further propulsion. Physically: It allows an object to reach infinite distance with zero kinetic energy left. Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape the gravitational influence of the star system (e.g., the Sun), assuming the object starts from the planet's surface. Physically: It combines escape from the planet plus the additional velocity to overcome the star's gravity.","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"For a circular orbit of radius \\( r \\) (usually the planet\u2019s radius plus altitude, but here surface orbit is approximated as radius \\( R \\) ): $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Where: \\( G \\) is the universal gravitational constant, approximately $$ G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $$ \\( M \\) is the mass of the celestial body (kg). \\( R \\) is the radius of the celestial body (m).","title":"1. First Cosmic Velocity \\( v_1 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2-escape-velocity-from-the-planet","text":"The escape velocity is derived from energy conservation, where the kinetic energy equals the gravitational potential energy required to escape the gravitational field of the planet. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\, v_1 \\]","title":"2. Second Cosmic Velocity \\( v_2 \\) (Escape velocity from the planet)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3-escape-velocity-from-the-star-system","text":"This velocity corresponds to the minimum speed needed to escape the gravitational influence of the star system (e.g., the Sun), assuming the spacecraft is launched from the surface of the planet. The spacecraft must overcome the gravitational potentials of both the planet and the star at the planet\u2019s orbital radius. Let: \\( r_s \\) be the orbital radius of the planet around the star (distance from the star to the planet). \\( M_s \\) be the mass of the star. Then, \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{esc,star}}^2} \\] where \\[ v_{\\text{esc,star}} = \\sqrt{\\frac{2GM_s}{r_s}} \\] and \\( v_2 \\) is the escape velocity from the planet as above.","title":"3. Third Cosmic Velocity \\( v_3 \\) (Escape velocity from the star system)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-for-earth-mars-and-jupiter","text":"Body Mass (kg) Radius (m) Orbital Radius from Sun (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^{6}\\) \\(1.496 \\times 10^{11}\\) Mars \\(6.39 \\times 10^{23}\\) \\(3.3895 \\times 10^{6}\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^{7}\\) \\(7.785 \\times 10^{11}\\) Sun mass: \\[ M_s = 1.989 \\times 10^{30} \\, \\text{kg} \\]","title":"Parameters for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-to-calculate-and-visualize-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Celestial bodies data bodies = { \"Earth\": { \"mass\": 5.972e24, \"radius\": 6.371e6, \"orbit_radius\": 1.496e11 }, \"Mars\": { \"mass\": 6.39e23, \"radius\": 3.3895e6, \"orbit_radius\": 2.279e11 }, \"Jupiter\": { \"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbit_radius\": 7.785e11 } } # Compute velocities results = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] r_s = data[\"orbit_radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity (orbit) v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity (escape planet) v_esc_star = np.sqrt(2 * G * M_sun / r_s) # Escape velocity from Sun at planet orbit v3 = np.sqrt(v2**2 + v_esc_star**2) # Third cosmic velocity (escape star system) results[body] = { \"First Cosmic Velocity (km/s)\": v1 / 1000, \"Second Cosmic Velocity (km/s)\": v2 / 1000, \"Third Cosmic Velocity (km/s)\": v3 / 1000 } # Display results for body, velocities in results.items(): print(f\"{body}:\") for desc, val in velocities.items(): print(f\" {desc}: {val:.2f} km/s\") print() # Visualization labels = list(results.keys()) v1_vals = [results[b][\"First Cosmic Velocity (km/s)\"] for b in labels] v2_vals = [results[b][\"Second Cosmic Velocity (km/s)\"] for b in labels] v3_vals = [results[b][\"Third Cosmic Velocity (km/s)\"] for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True, axis='y') plt.show()","title":"Python Code to Calculate and Visualize Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#discussion-and-importance-in-space-exploration","text":"The First Cosmic Velocity is essential for satellites. Any satellite must reach at least this velocity to maintain a stable orbit, preventing it from falling back to the planet. For Earth, this velocity is about 7.9 km/s. The Second Cosmic Velocity (Escape Velocity) is critical for spacecraft leaving a planet's gravity without continuous propulsion. Rockets must accelerate beyond this velocity to enter interplanetary trajectories. The Third Cosmic Velocity relates to leaving the star system entirely, enabling potential interstellar missions. It requires combining escape from the planet plus enough velocity to overcome the star's gravity. For Earth, this is around 16.7 km/s. These velocities guide mission planning, fuel requirements, and the design of propulsion systems. Understanding and achieving them are the backbone of satellite launches, interplanetary probes (e.g., Mars rovers), and future interstellar exploration concepts.","title":"Discussion and Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"First cosmic velocity \u2014 orbital velocity around a planet. Second cosmic velocity \u2014 escape velocity from the planet. Third cosmic velocity \u2014 escape velocity from the star system (e.g., the Sun). These velocities vary by celestial body due to differences in mass, radius, and distance from the star, reflecting their unique gravitational environments.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth 1. Introduction and Theory When a payload is released from a moving rocket near Earth, its motion is influenced primarily by Earth's gravity. The trajectory depends on the initial velocity, position, and altitude. Based on these initial conditions, the path can be one of the following: Elliptical orbit (closed orbit around Earth), Parabolic trajectory (the borderline between bound and unbound orbits), Hyperbolic trajectory (escape trajectory). Governing Physics The gravitational force acting on the payload is described by Newton's Law of Gravitation : \\[ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} \\] where: \\( G \\) is the gravitational constant, \\(6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\mathrm{kg}^{-1} \\mathrm{s}^{-2} \\) , \\( M \\) is the mass of Earth, \\(5.972 \\times 10^{24} \\, \\mathrm{kg} \\) , \\( m \\) is the payload mass (which cancels out in the acceleration), \\( r \\) is the distance from Earth's center to the payload, \\( \\hat{r} \\) is the unit vector pointing from Earth to the payload. The equation of motion under Earth's gravity is: \\[ \\mathbf{\\ddot{r}} = -\\frac{GM}{r^3} \\mathbf{r} \\] where \\(\\mathbf{r}\\) is the position vector of the payload relative to Earth's center. Escape Velocity The escape velocity at distance \\(r\\) from Earth's center is: \\[ v_{\\mathrm{esc}} = \\sqrt{\\frac{2GM}{r}} \\] If the payload's velocity \\(v < v_{\\mathrm{esc}}\\) , it follows an elliptical orbit. If \\(v = v_{\\mathrm{esc}}\\) , it follows a parabolic trajectory. If \\(v > v_{\\mathrm{esc}}\\) , it follows a hyperbolic trajectory and escapes Earth. 2. Numerical Method and Simulation Setup To analyze the trajectory numerically, we solve the second-order differential equation of motion by converting it into a system of first-order ordinary differential equations (ODEs): Define the state vector: \\[ \\mathbf{y} = (x, y, v_x, v_y) \\] where \\((x,y)\\) is the payload position and \\((v_x, v_y)\\) are the velocity components in a 2D plane. The equations become: \\[ \\begin{cases} \\dot{x} = v_x \\\\ \\dot{y} = v_y \\\\ \\dot{v_x} = -\\frac{GM}{r^3} x \\\\ \\dot{v_y} = -\\frac{GM}{r^3} y \\end{cases} \\] with \\[ r = \\sqrt{x^2 + y^2} \\] We use numerical ODE solvers such as Python's scipy.integrate.solve_ivp to simulate the motion over time, given initial conditions for position and velocity. 3. Python Implementation for Trajectory Simulation The following Python script numerically simulates the payload's trajectory under Earth's gravity using the scipy.integrate.solve_ivp solver. It models the 2D motion by solving the system of ordinary differential equations derived in the previous section. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth, kg R_earth = 6371e3 # radius of Earth, meters def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(initial_pos, initial_vel, t_span=[0, 5000], max_step=1): y0 = [initial_pos[0], initial_pos[1], initial_vel[0], initial_vel[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8) return sol def plot_trajectory(sol, title='Payload Trajectory'): x = sol.y[0] / 1e3 # convert meters to kilometers y = sol.y[1] / 1e3 plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') earth = plt.Circle((0, 0), R_earth / 1e3, color='b', alpha=0.3, label='Earth') plt.gca().add_patch(earth) plt.xlabel('X (km)') plt.ylabel('Y (km)') plt.title(title) plt.axis('equal') plt.legend() plt.grid(True) plt.show() # Example initial conditions: altitude = 400e3 # 400 km above Earth's surface r0 = R_earth + altitude # Initial position at (r0, 0) initial_pos = np.array([r0, 0]) # Circular orbital velocity at altitude v_circular = np.sqrt(G * M / r0) # Initial velocities for different trajectories initial_vel_circular = np.array([0, v_circular]) # Circular orbit initial_vel_elliptical = np.array([0, 0.9 * np.sqrt(2) * v_circular]) # Elliptical orbit initial_vel_parabolic = np.array([0, np.sqrt(2) * v_circular]) # Parabolic escape initial_vel_hyperbolic = np.array([0, 1.1 * np.sqrt(2) * v_circular]) # Hyperbolic escape # Run simulations sol_circular = simulate_trajectory(initial_pos, initial_vel_circular) sol_elliptical = simulate_trajectory(initial_pos, initial_vel_elliptical) sol_parabolic = simulate_trajectory(initial_pos, initial_vel_parabolic, t_span=[0, 10000]) sol_hyperbolic = simulate_trajectory(initial_pos, initial_vel_hyperbolic, t_span=[0, 10000]) # Plot the results plot_trajectory(sol_circular, 'Circular Orbit') plot_trajectory(sol_elliptical, 'Elliptical Orbit') plot_trajectory(sol_parabolic, 'Parabolic Escape Trajectory') plot_trajectory(sol_hyperbolic, 'Hyperbolic Escape Trajectory') 4. Discussion Elliptical orbit: Initial velocity is less than the escape velocity; the payload remains gravitationally bound, orbiting Earth. Parabolic trajectory: Payload escapes Earth but with zero excess velocity at infinity \u2014 representing a delicate boundary case between bound and unbound orbits. Hyperbolic trajectory: Payload escapes Earth with positive excess velocity, meaning it will not return. Circular orbit: A special case of an elliptical orbit where the velocity is exactly the circular orbital velocity at the given altitude. 5. Real-World Applications Orbital insertion: Adjusting the payload\u2019s velocity to achieve elliptical or circular orbits around Earth. Reentry scenarios: Payload velocity decreases so the trajectory intersects Earth's atmosphere, enabling controlled return. Escape trajectories: Missions designed to leave Earth orbit entirely (e.g., interplanetary probes and deep space missions).","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction-and-theory","text":"When a payload is released from a moving rocket near Earth, its motion is influenced primarily by Earth's gravity. The trajectory depends on the initial velocity, position, and altitude. Based on these initial conditions, the path can be one of the following: Elliptical orbit (closed orbit around Earth), Parabolic trajectory (the borderline between bound and unbound orbits), Hyperbolic trajectory (escape trajectory).","title":"1. Introduction and Theory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-physics","text":"The gravitational force acting on the payload is described by Newton's Law of Gravitation : \\[ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} \\] where: \\( G \\) is the gravitational constant, \\(6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\mathrm{kg}^{-1} \\mathrm{s}^{-2} \\) , \\( M \\) is the mass of Earth, \\(5.972 \\times 10^{24} \\, \\mathrm{kg} \\) , \\( m \\) is the payload mass (which cancels out in the acceleration), \\( r \\) is the distance from Earth's center to the payload, \\( \\hat{r} \\) is the unit vector pointing from Earth to the payload. The equation of motion under Earth's gravity is: \\[ \\mathbf{\\ddot{r}} = -\\frac{GM}{r^3} \\mathbf{r} \\] where \\(\\mathbf{r}\\) is the position vector of the payload relative to Earth's center.","title":"Governing Physics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity at distance \\(r\\) from Earth's center is: \\[ v_{\\mathrm{esc}} = \\sqrt{\\frac{2GM}{r}} \\] If the payload's velocity \\(v < v_{\\mathrm{esc}}\\) , it follows an elliptical orbit. If \\(v = v_{\\mathrm{esc}}\\) , it follows a parabolic trajectory. If \\(v > v_{\\mathrm{esc}}\\) , it follows a hyperbolic trajectory and escapes Earth.","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-method-and-simulation-setup","text":"To analyze the trajectory numerically, we solve the second-order differential equation of motion by converting it into a system of first-order ordinary differential equations (ODEs): Define the state vector: \\[ \\mathbf{y} = (x, y, v_x, v_y) \\] where \\((x,y)\\) is the payload position and \\((v_x, v_y)\\) are the velocity components in a 2D plane. The equations become: \\[ \\begin{cases} \\dot{x} = v_x \\\\ \\dot{y} = v_y \\\\ \\dot{v_x} = -\\frac{GM}{r^3} x \\\\ \\dot{v_y} = -\\frac{GM}{r^3} y \\end{cases} \\] with \\[ r = \\sqrt{x^2 + y^2} \\] We use numerical ODE solvers such as Python's scipy.integrate.solve_ivp to simulate the motion over time, given initial conditions for position and velocity.","title":"2. Numerical Method and Simulation Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-implementation-for-trajectory-simulation","text":"The following Python script numerically simulates the payload's trajectory under Earth's gravity using the scipy.integrate.solve_ivp solver. It models the 2D motion by solving the system of ordinary differential equations derived in the previous section. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth, kg R_earth = 6371e3 # radius of Earth, meters def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(initial_pos, initial_vel, t_span=[0, 5000], max_step=1): y0 = [initial_pos[0], initial_pos[1], initial_vel[0], initial_vel[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8) return sol def plot_trajectory(sol, title='Payload Trajectory'): x = sol.y[0] / 1e3 # convert meters to kilometers y = sol.y[1] / 1e3 plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') earth = plt.Circle((0, 0), R_earth / 1e3, color='b', alpha=0.3, label='Earth') plt.gca().add_patch(earth) plt.xlabel('X (km)') plt.ylabel('Y (km)') plt.title(title) plt.axis('equal') plt.legend() plt.grid(True) plt.show() # Example initial conditions: altitude = 400e3 # 400 km above Earth's surface r0 = R_earth + altitude # Initial position at (r0, 0) initial_pos = np.array([r0, 0]) # Circular orbital velocity at altitude v_circular = np.sqrt(G * M / r0) # Initial velocities for different trajectories initial_vel_circular = np.array([0, v_circular]) # Circular orbit initial_vel_elliptical = np.array([0, 0.9 * np.sqrt(2) * v_circular]) # Elliptical orbit initial_vel_parabolic = np.array([0, np.sqrt(2) * v_circular]) # Parabolic escape initial_vel_hyperbolic = np.array([0, 1.1 * np.sqrt(2) * v_circular]) # Hyperbolic escape # Run simulations sol_circular = simulate_trajectory(initial_pos, initial_vel_circular) sol_elliptical = simulate_trajectory(initial_pos, initial_vel_elliptical) sol_parabolic = simulate_trajectory(initial_pos, initial_vel_parabolic, t_span=[0, 10000]) sol_hyperbolic = simulate_trajectory(initial_pos, initial_vel_hyperbolic, t_span=[0, 10000]) # Plot the results plot_trajectory(sol_circular, 'Circular Orbit') plot_trajectory(sol_elliptical, 'Elliptical Orbit') plot_trajectory(sol_parabolic, 'Parabolic Escape Trajectory') plot_trajectory(sol_hyperbolic, 'Hyperbolic Escape Trajectory')","title":"3. Python Implementation for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-discussion","text":"Elliptical orbit: Initial velocity is less than the escape velocity; the payload remains gravitationally bound, orbiting Earth. Parabolic trajectory: Payload escapes Earth but with zero excess velocity at infinity \u2014 representing a delicate boundary case between bound and unbound orbits. Hyperbolic trajectory: Payload escapes Earth with positive excess velocity, meaning it will not return. Circular orbit: A special case of an elliptical orbit where the velocity is exactly the circular orbital velocity at the given altitude.","title":"4. Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-real-world-applications","text":"Orbital insertion: Adjusting the payload\u2019s velocity to achieve elliptical or circular orbits around Earth. Reentry scenarios: Payload velocity decreases so the trajectory intersects Earth's atmosphere, enabling controlled return. Escape trajectories: Missions designed to leave Earth orbit entirely (e.g., interplanetary probes and deep space missions).","title":"5. Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1: Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this phenomenon can be observed as ripples from different points meet, forming distinctive interference patterns. These patterns visually demonstrate how waves combine\u2014either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns deepens understanding of wave behavior and phase relationships in a simple, intuitive way. This hands-on approach is useful for exploring wave physics and real-world applications such as acoustics, optics, and fluid dynamics. Problem Statement A circular wave on a water surface, emanating from a point source located at \\(\\mathbf{r}_i\\) , can be described by the Single Disturbance equation : \\[ \\eta(\\mathbf{r}, t) = A \\cos(k r - \\omega t + \\phi) \\] where: - \\(\\eta(\\mathbf{r}, t)\\) is the displacement of the water surface at position \\(\\mathbf{r}\\) and time \\(t\\) , - \\(A\\) is the amplitude of the wave, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, with \\(\\lambda\\) the wavelength, - \\(\\omega = 2 \\pi f\\) is the angular frequency, with \\(f\\) the frequency, - \\(r = |\\mathbf{r} - \\mathbf{r}_i|\\) is the distance from the source at \\(\\mathbf{r}_i\\) to the point \\(\\mathbf{r}\\) , - \\(\\phi\\) is the initial phase. Steps to Follow Select a Regular Polygon Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources Place point wave sources at the vertices of the selected polygon, each at position \\(\\mathbf{r}_i\\) . Wave Equations Write the wave equation emitted from each source \\(i\\) : $$ \\eta_i(\\mathbf{r}, t) = A \\cos(k |\\mathbf{r} - \\mathbf{r}_i| - \\omega t + \\phi_i) $$ Assuming all sources have the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , and phase \\(\\phi_i = 0\\) for coherence. Superposition of Waves Apply the principle of superposition by summing the displacements from all \\(N\\) sources: $$ \\eta_{\\mathrm{total}}(\\mathbf{r}, t) = \\sum_{i=1}^N \\eta_i(\\mathbf{r}, t) = \\sum_{i=1}^N A \\cos(k |\\mathbf{r} - \\mathbf{r}_i| - \\omega t) $$ Analyze Interference Patterns Analyze \\(\\eta_{\\mathrm{total}}(\\mathbf{r}, t)\\) as a function of position \\(\\mathbf{r}\\) and time \\(t\\) to identify regions of: Constructive interference: where waves reinforce ( \\(\\eta\\) maxima), Destructive interference: where waves cancel out ( \\(\\eta\\) minima). Visualization Create graphical representations of the interference patterns on the water surface for the chosen polygon. 3. Python Simulation Implementation Below is a Python script that simulates the interference pattern on the water surface due to wave sources placed at the vertices of a regular polygon. It calculates the total displacement of the water surface over a 2D grid at a fixed time, illustrating the constructive and destructive interference regions. import numpy as np import matplotlib.pyplot as plt def polygon_vertices(radius, n_sides): \"\"\" Compute vertices of a regular polygon centered at origin. radius: distance from center to each vertex (meters) n_sides: number of vertices (polygon sides) \"\"\" angles = np.linspace(0, 2 * np.pi, n_sides, endpoint=False) x = radius * np.cos(angles) y = radius * np.sin(angles) return np.vstack((x, y)).T # shape (n_sides, 2) def wave_displacement(points, sources, k, omega, t, A=1.0): \"\"\" Calculate total displacement at grid points due to all sources at time t. points: array of shape (num_points, 2) with (x, y) positions sources: array of shape (num_sources, 2) with (x, y) source positions k: wave number (2pi / wavelength) omega: angular frequency (2pi * frequency) t: time (seconds) A: amplitude \"\"\" displacement = np.zeros(points.shape[0]) for source in sources: r = np.linalg.norm(points - source, axis=1) r[r == 0] = 1e-10 # prevent division by zero displacement += A * np.cos(k * r - omega * t) return displacement # Simulation parameters n_sides = 5 # number of polygon sides, e.g. pentagon radius = 1.0 # distance from center to vertices (meters) wavelength = 0.5 # meters frequency = 1.0 # Hz k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency amplitude = 1.0 time = 0.0 # time instant for snapshot # Generate polygon vertices (sources) sources = polygon_vertices(radius, n_sides) # Create grid points for simulation x = np.linspace(-2, 2, 400) y = np.linspace(-2, 2, 400) X, Y = np.meshgrid(x, y) points = np.vstack([X.ravel(), Y.ravel()]).T # Calculate total wave displacement at each grid point displacement = wave_displacement(points, sources, k, omega, time, amplitude) Z = displacement.reshape(X.shape) # Plotting the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Displacement') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.title(f'Interference Pattern - {n_sides}-sided Polygon Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.axis('equal') plt.show() Considerations All sources emit waves with identical amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . The waves are coherent, maintaining constant phase relationships. Numerical simulation tools such as Python (with NumPy and Matplotlib) are used for modeling and visualization. Deliverables A Markdown document including the Python script or notebook implementing the simulation. A detailed explanation of the interference patterns observed, related to the polygon shape and wave parameters. Graphical representations showing regions of constructive and destructive interference on the water surface.","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1-interference-patterns-on-a-water-surface","text":"","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this phenomenon can be observed as ripples from different points meet, forming distinctive interference patterns. These patterns visually demonstrate how waves combine\u2014either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns deepens understanding of wave behavior and phase relationships in a simple, intuitive way. This hands-on approach is useful for exploring wave physics and real-world applications such as acoustics, optics, and fluid dynamics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"A circular wave on a water surface, emanating from a point source located at \\(\\mathbf{r}_i\\) , can be described by the Single Disturbance equation : \\[ \\eta(\\mathbf{r}, t) = A \\cos(k r - \\omega t + \\phi) \\] where: - \\(\\eta(\\mathbf{r}, t)\\) is the displacement of the water surface at position \\(\\mathbf{r}\\) and time \\(t\\) , - \\(A\\) is the amplitude of the wave, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, with \\(\\lambda\\) the wavelength, - \\(\\omega = 2 \\pi f\\) is the angular frequency, with \\(f\\) the frequency, - \\(r = |\\mathbf{r} - \\mathbf{r}_i|\\) is the distance from the source at \\(\\mathbf{r}_i\\) to the point \\(\\mathbf{r}\\) , - \\(\\phi\\) is the initial phase.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Select a Regular Polygon Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources Place point wave sources at the vertices of the selected polygon, each at position \\(\\mathbf{r}_i\\) . Wave Equations Write the wave equation emitted from each source \\(i\\) : $$ \\eta_i(\\mathbf{r}, t) = A \\cos(k |\\mathbf{r} - \\mathbf{r}_i| - \\omega t + \\phi_i) $$ Assuming all sources have the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , and phase \\(\\phi_i = 0\\) for coherence. Superposition of Waves Apply the principle of superposition by summing the displacements from all \\(N\\) sources: $$ \\eta_{\\mathrm{total}}(\\mathbf{r}, t) = \\sum_{i=1}^N \\eta_i(\\mathbf{r}, t) = \\sum_{i=1}^N A \\cos(k |\\mathbf{r} - \\mathbf{r}_i| - \\omega t) $$ Analyze Interference Patterns Analyze \\(\\eta_{\\mathrm{total}}(\\mathbf{r}, t)\\) as a function of position \\(\\mathbf{r}\\) and time \\(t\\) to identify regions of: Constructive interference: where waves reinforce ( \\(\\eta\\) maxima), Destructive interference: where waves cancel out ( \\(\\eta\\) minima). Visualization Create graphical representations of the interference patterns on the water surface for the chosen polygon.","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-python-simulation-implementation","text":"Below is a Python script that simulates the interference pattern on the water surface due to wave sources placed at the vertices of a regular polygon. It calculates the total displacement of the water surface over a 2D grid at a fixed time, illustrating the constructive and destructive interference regions. import numpy as np import matplotlib.pyplot as plt def polygon_vertices(radius, n_sides): \"\"\" Compute vertices of a regular polygon centered at origin. radius: distance from center to each vertex (meters) n_sides: number of vertices (polygon sides) \"\"\" angles = np.linspace(0, 2 * np.pi, n_sides, endpoint=False) x = radius * np.cos(angles) y = radius * np.sin(angles) return np.vstack((x, y)).T # shape (n_sides, 2) def wave_displacement(points, sources, k, omega, t, A=1.0): \"\"\" Calculate total displacement at grid points due to all sources at time t. points: array of shape (num_points, 2) with (x, y) positions sources: array of shape (num_sources, 2) with (x, y) source positions k: wave number (2pi / wavelength) omega: angular frequency (2pi * frequency) t: time (seconds) A: amplitude \"\"\" displacement = np.zeros(points.shape[0]) for source in sources: r = np.linalg.norm(points - source, axis=1) r[r == 0] = 1e-10 # prevent division by zero displacement += A * np.cos(k * r - omega * t) return displacement # Simulation parameters n_sides = 5 # number of polygon sides, e.g. pentagon radius = 1.0 # distance from center to vertices (meters) wavelength = 0.5 # meters frequency = 1.0 # Hz k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency amplitude = 1.0 time = 0.0 # time instant for snapshot # Generate polygon vertices (sources) sources = polygon_vertices(radius, n_sides) # Create grid points for simulation x = np.linspace(-2, 2, 400) y = np.linspace(-2, 2, 400) X, Y = np.meshgrid(x, y) points = np.vstack([X.ravel(), Y.ravel()]).T # Calculate total wave displacement at each grid point displacement = wave_displacement(points, sources, k, omega, time, amplitude) Z = displacement.reshape(X.shape) # Plotting the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Displacement') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.title(f'Interference Pattern - {n_sides}-sided Polygon Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.axis('equal') plt.show()","title":"3. Python Simulation Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#considerations","text":"All sources emit waves with identical amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . The waves are coherent, maintaining constant phase relationships. Numerical simulation tools such as Python (with NumPy and Matplotlib) are used for modeling and visualization.","title":"Considerations"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"A Markdown document including the Python script or notebook implementing the simulation. A detailed explanation of the interference patterns observed, related to the polygon shape and wave parameters. Graphical representations showing regions of constructive and destructive interference on the water surface.","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Electromagnetism Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force, expressed as $$ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) $$ governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories that arise due to this force. Task Exploration of Applications: Identify systems where the Lorentz force plays a key role (e.g., particle accelerators, mass spectrometers, plasma confinement). Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling the motion of charged particles. Simulating Particle Motion: Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate the particle\u2019s circular, helical, or drift motion based on initial conditions and field configurations. Parameter Exploration: Allow variations in: Field strengths ( \\(\\mathbf{E}\\) , \\(\\mathbf{B}\\) ). Initial particle velocity ( \\(\\mathbf{v}_0\\) ). Charge and mass of the particle ( \\(q\\) , \\(m\\) ). Observe how these parameters influence the trajectory. Visualization: Create clear, labeled plots showing the particle\u2019s path in 2D and 3D for different scenarios. Highlight physical phenomena such as the Larmor radius and drift velocity. Deliverables A Markdown document with Python script or notebook implementing the simulations. Visualizations of particle trajectories for the specified field configurations. A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps. Suggestions for extending the simulation to more complex scenarios, such as non-uniform fields. Hints and Resources Use numerical methods like the Euler or Runge-Kutta method to solve the equations of motion. Employ Python libraries such as NumPy for calculations and Matplotlib for visualizations. Start with simple cases (e.g., uniform magnetic field) and gradually add complexity (e.g., crossed fields). Python Implementation: Lorentz Force Simulation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # charge (C) m = 9.11e-31 # mass (kg) # Fields (can modify) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) # initial position (m) v0 = np.array([1e5, 0.0, 0.0]) # initial velocity (m/s) # Time parameters dt = 1e-11 # time step (s) t_max = 5e-7 # total time (s) steps = int(t_max / dt) def lorentz_acceleration(v, E, B, q, m): \"\"\"Calculate acceleration due to Lorentz force.\"\"\" return (q / m) * (E + np.cross(v, B)) def rk4_step(r, v, dt, E, B, q, m): \"\"\"Perform one RK4 step for position and velocity.\"\"\" # k1 a1 = lorentz_acceleration(v, E, B, q, m) k1v = a1 * dt k1r = v * dt # k2 a2 = lorentz_acceleration(v + 0.5 * k1v, E, B, q, m) k2v = a2 * dt k2r = (v + 0.5 * k1v) * dt # k3 a3 = lorentz_acceleration(v + 0.5 * k2v, E, B, q, m) k3v = a3 * dt k3r = (v + 0.5 * k2v) * dt # k4 a4 = lorentz_acceleration(v + k3v, E, B, q, m) k4v = a4 * dt k4r = (v + k3v) * dt # Update velocity and position v_next = v + (k1v + 2*k2v + 2*k3v + k4v) / 6 r_next = r + (k1r + 2*k2r + 2*k3r + k4r) / 6 return r_next, v_next # Initialize arrays to store trajectory positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Time evolution for i in range(1, steps): r_new, v_new = rk4_step(positions[i-1], velocities[i-1], dt, E, B, q, m) positions[i] = r_new velocities[i] = v_new # Plotting 3D trajectory fig = plt.figure(figsize=(10,7)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2], lw=1.5) ax.set_title(\"Charged Particle Trajectory under Lorentz Force\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") ax.grid(True) plt.show() Deliverables A Markdown document with Python script or notebook implementing the simulations. Visualizations of particle trajectories for the specified field configurations. A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps. Suggestions for extending the simulation to more complex scenarios, such as non-uniform fields. Hints and Resources Use numerical methods like the Euler or Runge-Kutta method to solve the equations of motion. Employ Python libraries such as NumPy for calculations and Matplotlib for visualizations. Start with simple cases (e.g., uniform magnetic field) and gradually add complexity (e.g., crossed fields).","title":"Electromagnetism"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism","text":"","title":"Electromagnetism"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as $$ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) $$ governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore practical applications and visualize the complex trajectories that arise due to this force.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task","text":"Exploration of Applications: Identify systems where the Lorentz force plays a key role (e.g., particle accelerators, mass spectrometers, plasma confinement). Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling the motion of charged particles. Simulating Particle Motion: Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate the particle\u2019s circular, helical, or drift motion based on initial conditions and field configurations. Parameter Exploration: Allow variations in: Field strengths ( \\(\\mathbf{E}\\) , \\(\\mathbf{B}\\) ). Initial particle velocity ( \\(\\mathbf{v}_0\\) ). Charge and mass of the particle ( \\(q\\) , \\(m\\) ). Observe how these parameters influence the trajectory. Visualization: Create clear, labeled plots showing the particle\u2019s path in 2D and 3D for different scenarios. Highlight physical phenomena such as the Larmor radius and drift velocity.","title":"Task"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. Visualizations of particle trajectories for the specified field configurations. A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps. Suggestions for extending the simulation to more complex scenarios, such as non-uniform fields.","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#hints-and-resources","text":"Use numerical methods like the Euler or Runge-Kutta method to solve the equations of motion. Employ Python libraries such as NumPy for calculations and Matplotlib for visualizations. Start with simple cases (e.g., uniform magnetic field) and gradually add complexity (e.g., crossed fields).","title":"Hints and Resources"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-implementation-lorentz-force-simulation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # charge (C) m = 9.11e-31 # mass (kg) # Fields (can modify) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) # initial position (m) v0 = np.array([1e5, 0.0, 0.0]) # initial velocity (m/s) # Time parameters dt = 1e-11 # time step (s) t_max = 5e-7 # total time (s) steps = int(t_max / dt) def lorentz_acceleration(v, E, B, q, m): \"\"\"Calculate acceleration due to Lorentz force.\"\"\" return (q / m) * (E + np.cross(v, B)) def rk4_step(r, v, dt, E, B, q, m): \"\"\"Perform one RK4 step for position and velocity.\"\"\" # k1 a1 = lorentz_acceleration(v, E, B, q, m) k1v = a1 * dt k1r = v * dt # k2 a2 = lorentz_acceleration(v + 0.5 * k1v, E, B, q, m) k2v = a2 * dt k2r = (v + 0.5 * k1v) * dt # k3 a3 = lorentz_acceleration(v + 0.5 * k2v, E, B, q, m) k3v = a3 * dt k3r = (v + 0.5 * k2v) * dt # k4 a4 = lorentz_acceleration(v + k3v, E, B, q, m) k4v = a4 * dt k4r = (v + k3v) * dt # Update velocity and position v_next = v + (k1v + 2*k2v + 2*k3v + k4v) / 6 r_next = r + (k1r + 2*k2r + 2*k3r + k4r) / 6 return r_next, v_next # Initialize arrays to store trajectory positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Time evolution for i in range(1, steps): r_new, v_new = rk4_step(positions[i-1], velocities[i-1], dt, E, B, q, m) positions[i] = r_new velocities[i] = v_new # Plotting 3D trajectory fig = plt.figure(figsize=(10,7)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2], lw=1.5) ax.set_title(\"Charged Particle Trajectory under Lorentz Force\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") ax.grid(True) plt.show()","title":"Python Implementation: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables_1","text":"A Markdown document with Python script or notebook implementing the simulations. Visualizations of particle trajectories for the specified field configurations. A discussion on how the results relate to practical systems, such as cyclotrons or magnetic traps. Suggestions for extending the simulation to more complex scenarios, such as non-uniform fields.","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#hints-and-resources_1","text":"Use numerical methods like the Euler or Runge-Kutta method to solve the equations of motion. Employ Python libraries such as NumPy for calculations and Matplotlib for visualizations. Start with simple cases (e.g., uniform magnetic field) and gradually add complexity (e.g., crossed fields).","title":"Hints and Resources"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Problem 1: Equivalent Resistance Using Graph Theory \ud83c\udfaf Motivation Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative by representing a circuit as a graph\u2014where: Nodes represent junctions. Edges represent resistors, with weights equal to resistance values. This approach: - Streamlines calculations. - Enables automated analysis and circuit simulation. - Highlights the connection between electrical engineering and computer science. \u2705 Task Overview We aim to calculate the equivalent resistance between two nodes in a circuit represented as a graph. Option 2: \ud83d\udd01 Advanced Task \u2013 Full Implementation \ud83e\udde0 Algorithm Description Key Ideas: Parallel Reduction : If multiple resistors exist between two nodes, replace them with their parallel equivalent: $$ \\frac{1}{R_{eq}} = \\sum_{i} \\frac{1}{R_i} $$ Series Reduction : If a node connects to exactly two other nodes via single resistors, replace the three-node chain with a single resistor: $$ R_{eq} = R_1 + R_2 $$ ### \ud83d\udcc4 Pseudocode function calculate_equivalent_resistance(graph, start_node, end_node): while graph has more than one edge: for each pair of nodes (u, v) in graph: if multiple edges exist between u and v: // Parallel reduction R_eq = 1 / sum(1 / R_i for each R_i between u and v) remove all edges between u and v add a new edge with weight R_eq elif node v is connected to exactly two other nodes (u and w) and only one resistor each: // Series reduction R1 = resistance(u, v) R2 = resistance(v, w) R_eq = R1 + R2 remove nodes u-v-w add edge u-w with weight R_eq return resistance between start_node and end_node \ud83d\udc0d Python Code (Using networkx ) import networkx as nx def simplify_circuit(G, start, end): changed = True while changed: changed = False # Handle parallel connections for u, v in list(G.edges()): edges = list(G.get_edge_data(u, v).values()) if len(edges) > 1: req = 1 / sum(1 / d['resistance'] for d in edges) G.remove_edges_from([(u, v)] * len(edges)) G.add_edge(u, v, resistance=req) changed = True # Handle series connections for node in list(G.nodes()): if node in (start, end): continue neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if (G.number_of_edges(node, u) == 1 and G.number_of_edges(node, v) == 1 and len(list(G.edges(node))) == 2): r1 = list(G.get_edge_data(node, u).values())[0]['resistance'] r2 = list(G.get_edge_data(node, v).values())[0]['resistance'] req = r1 + r2 G.remove_node(node) G.add_edge(u, v, resistance=req) changed = True break return list(G.get_edge_data(start, end).values())[0]['resistance'] # Example 1: A - B - C in series with resistances 3\u03a9 and 2\u03a9 G = nx.MultiGraph() G.add_edge('A', 'B', resistance=3) G.add_edge('B', 'C', resistance=2) result = simplify_circuit(G, 'A', 'C') print(\"Equivalent resistance:\", result) # Output: 5 # Example 2: Nested configuration with a parallel path G2 = nx.MultiGraph() G2.add_edge('A', 'B', resistance=3) G2.add_edge('B', 'C', resistance=2) G2.add_edge('C', 'D', resistance=6) G2.add_edge('A', 'D', resistance=3) # Parallel to the path A-B-C-D print(\"Example 2 Equivalent Resistance:\", simplify_circuit(G2, 'A', 'D')) # Output: ~2.25 Example 1 Example 2 Explanation of Results In Example 1 , the two resistors of 3\u03a9 and 6\u03a9 are connected in parallel between nodes A and B. The algorithm computes the equivalent resistance as 2\u03a9, which matches the theoretical calculation using the parallel resistor formula: \\[ R_{eq} = \\frac{1}{\\frac{1}{3} + \\frac{1}{6}} = 2 \\Omega \\] In Example 2 , there is a more complex configuration where the series path A-B-C-D has resistances of 3\u03a9, 2\u03a9, and 6\u03a9, summing to 11\u03a9, which is in parallel with a direct 3\u03a9 resistor between A and D. The resulting equivalent resistance is approximately 2.25\u03a9, consistent with the parallel combination of 3\u03a9 and 11\u03a9 resistors. Discussion on Algorithm Behavior The algorithm identifies and reduces parallel resistors by combining all edges between two nodes into a single equivalent resistor using the reciprocal sum formula. It detects series connections as nodes connected to exactly two other nodes by single resistors and replaces the chain of three nodes with a single resistor whose resistance is the sum of the two. These reductions repeat iteratively until the graph is simplified to a single equivalent resistor between the specified start and end nodes. Complexity and Limitations The simplification algorithm iteratively processes the graph, so its time complexity depends on the number of nodes and edges. For typical circuit graphs, this is efficient, but the complexity can increase for very large or dense networks. The algorithm works well for circuits reducible by series and parallel combinations but may require enhancements to handle more complex topologies such as bridge circuits or networks requiring star-delta (Y-\u0394) transformations. Potential improvements include incorporating these advanced transformations and optimizing graph traversal for faster reduction. Conclusion Applying graph theory to calculate equivalent resistance provides a structured and programmable approach to circuit analysis. It simplifies complex resistor networks step-by-step, enabling automated analysis that is beneficial in engineering applications and educational contexts. This method effectively connects electrical engineering concepts with graph algorithms and data structures.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative by representing a circuit as a graph\u2014where: Nodes represent junctions. Edges represent resistors, with weights equal to resistance values. This approach: - Streamlines calculations. - Enables automated analysis and circuit simulation. - Highlights the connection between electrical engineering and computer science.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-overview","text":"We aim to calculate the equivalent resistance between two nodes in a circuit represented as a graph.","title":"\u2705 Task Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-2-advanced-task-full-implementation","text":"","title":"Option 2: \ud83d\udd01 Advanced Task \u2013 Full Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"","title":"\ud83e\udde0 Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-ideas","text":"Parallel Reduction : If multiple resistors exist between two nodes, replace them with their parallel equivalent: $$ \\frac{1}{R_{eq}} = \\sum_{i} \\frac{1}{R_i} $$ Series Reduction : If a node connects to exactly two other nodes via single resistors, replace the three-node chain with a single resistor: $$ R_{eq} = R_1 + R_2 $$ ### \ud83d\udcc4 Pseudocode function calculate_equivalent_resistance(graph, start_node, end_node): while graph has more than one edge: for each pair of nodes (u, v) in graph: if multiple edges exist between u and v: // Parallel reduction R_eq = 1 / sum(1 / R_i for each R_i between u and v) remove all edges between u and v add a new edge with weight R_eq elif node v is connected to exactly two other nodes (u and w) and only one resistor each: // Series reduction R1 = resistance(u, v) R2 = resistance(v, w) R_eq = R1 + R2 remove nodes u-v-w add edge u-w with weight R_eq return resistance between start_node and end_node","title":"Key Ideas:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-code-using-networkx","text":"import networkx as nx def simplify_circuit(G, start, end): changed = True while changed: changed = False # Handle parallel connections for u, v in list(G.edges()): edges = list(G.get_edge_data(u, v).values()) if len(edges) > 1: req = 1 / sum(1 / d['resistance'] for d in edges) G.remove_edges_from([(u, v)] * len(edges)) G.add_edge(u, v, resistance=req) changed = True # Handle series connections for node in list(G.nodes()): if node in (start, end): continue neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if (G.number_of_edges(node, u) == 1 and G.number_of_edges(node, v) == 1 and len(list(G.edges(node))) == 2): r1 = list(G.get_edge_data(node, u).values())[0]['resistance'] r2 = list(G.get_edge_data(node, v).values())[0]['resistance'] req = r1 + r2 G.remove_node(node) G.add_edge(u, v, resistance=req) changed = True break return list(G.get_edge_data(start, end).values())[0]['resistance'] # Example 1: A - B - C in series with resistances 3\u03a9 and 2\u03a9 G = nx.MultiGraph() G.add_edge('A', 'B', resistance=3) G.add_edge('B', 'C', resistance=2) result = simplify_circuit(G, 'A', 'C') print(\"Equivalent resistance:\", result) # Output: 5 # Example 2: Nested configuration with a parallel path G2 = nx.MultiGraph() G2.add_edge('A', 'B', resistance=3) G2.add_edge('B', 'C', resistance=2) G2.add_edge('C', 'D', resistance=6) G2.add_edge('A', 'D', resistance=3) # Parallel to the path A-B-C-D print(\"Example 2 Equivalent Resistance:\", simplify_circuit(G2, 'A', 'D')) # Output: ~2.25 Example 1 Example 2","title":"\ud83d\udc0d Python Code (Using networkx)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#explanation-of-results","text":"In Example 1 , the two resistors of 3\u03a9 and 6\u03a9 are connected in parallel between nodes A and B. The algorithm computes the equivalent resistance as 2\u03a9, which matches the theoretical calculation using the parallel resistor formula: \\[ R_{eq} = \\frac{1}{\\frac{1}{3} + \\frac{1}{6}} = 2 \\Omega \\] In Example 2 , there is a more complex configuration where the series path A-B-C-D has resistances of 3\u03a9, 2\u03a9, and 6\u03a9, summing to 11\u03a9, which is in parallel with a direct 3\u03a9 resistor between A and D. The resulting equivalent resistance is approximately 2.25\u03a9, consistent with the parallel combination of 3\u03a9 and 11\u03a9 resistors.","title":"Explanation of Results"},{"location":"1%20Physics/5%20Circuits/Problem_1/#discussion-on-algorithm-behavior","text":"The algorithm identifies and reduces parallel resistors by combining all edges between two nodes into a single equivalent resistor using the reciprocal sum formula. It detects series connections as nodes connected to exactly two other nodes by single resistors and replaces the chain of three nodes with a single resistor whose resistance is the sum of the two. These reductions repeat iteratively until the graph is simplified to a single equivalent resistor between the specified start and end nodes.","title":"Discussion on Algorithm Behavior"},{"location":"1%20Physics/5%20Circuits/Problem_1/#complexity-and-limitations","text":"The simplification algorithm iteratively processes the graph, so its time complexity depends on the number of nodes and edges. For typical circuit graphs, this is efficient, but the complexity can increase for very large or dense networks. The algorithm works well for circuits reducible by series and parallel combinations but may require enhancements to handle more complex topologies such as bridge circuits or networks requiring star-delta (Y-\u0394) transformations. Potential improvements include incorporating these advanced transformations and optimizing graph traversal for faster reduction.","title":"Complexity and Limitations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Applying graph theory to calculate equivalent resistance provides a structured and programmable approach to circuit analysis. It simplifies complex resistor networks step-by-step, enabling automated analysis that is beneficial in engineering applications and educational contexts. This method effectively connects electrical engineering concepts with graph algorithms and data structures.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1: Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution (as long as the variance is finite). Simulations provide an intuitive and hands-on way to observe this phenomenon in action. Task 1: Simulating Sampling Distributions We consider the following population distributions: Uniform distribution: U(0, 1) Exponential distribution: Exp(\u03bb=1) Binomial distribution: Bin(n=10, p=0.5) Each distribution is used to generate a large dataset of 100,000 data points to simulate the full population. import numpy as np # Set seed for reproducibility np.random.seed(42) # Population size N = 100000 # Generate populations uniform_pop = np.random.uniform(0, 1, N) exponential_pop = np.random.exponential(1, N) binomial_pop = np.random.binomial(10, 0.5, N) Task 2: Sampling and Visualization For each population distribution (Uniform, Exponential, Binomial), we perform the following steps to visualize the Central Limit Theorem in action: Randomly sample data from the population using various sample sizes: Sample sizes used: 5, 10, 30, and 50 Repeat the sampling process : Each sampling experiment is repeated 1000 times to create a distribution of sample means. Compute the sample mean for each of the 1000 samples. Plot the sampling distribution : A histogram of the 1000 sample means is created for each sample size. Kernel Density Estimation (KDE) is optionally applied to better visualize the shape of the distribution. These plots help demonstrate how the distribution of sample means converges toward a normal distribution as the sample size increases, even when the underlying population is non-normal. import matplotlib.pyplot as plt import seaborn as sns # Sample sizes sample_sizes = [5, 10, 30, 50] # Function to simulate sample means def simulate_sample_means(population, sample_size, num_samples=1000): return [np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(num_samples)] # Plotting function def plot_sampling_distributions(population, name): fig, axes = plt.subplots(1, len(sample_sizes), figsize=(20, 4)) for i, size in enumerate(sample_sizes): sample_means = simulate_sample_means(population, size) sns.histplot(sample_means, kde=True, ax=axes[i], stat=\"density\", bins=30) axes[i].set_title(f\"{name} Dist\\nSample Size = {size}\") plt.suptitle(f\"Sampling Distribution of Sample Means - {name} Population\", fontsize=16) plt.tight_layout() plt.show() # Generate plots plot_sampling_distributions(uniform_pop, \"Uniform\") plot_sampling_distributions(exponential_pop, \"Exponential\") plot_sampling_distributions(binomial_pop, \"Binomial\") Task 3: Parameter Exploration Effect of Population Shape on Convergence Different population distributions influence how quickly the sampling distribution of the mean approaches normality: Uniform Distribution : Symmetric and bounded; the sample means converge quickly to a normal distribution, even for small sample sizes. Exponential Distribution : Highly skewed; requires larger sample sizes for the sampling distribution to resemble a normal distribution. Binomial Distribution : Discrete but symmetric (when p = 0.5); converges quickly, especially with moderate or large sample sizes. Impact of Sample Size The Central Limit Theorem shows that increasing the sample size improves the approximation of the sampling distribution to a normal curve. \\[ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} \\] As sample size n increases: - The standard deviation of the sample mean (standard error) decreases. - The histogram of sample means becomes more concentrated and bell-shaped. Observations from Simulations Smaller sample sizes (e.g., 5) result in a sampling distribution that still resembles the shape of the original distribution. Larger sample sizes (e.g., 30, 50) show clear convergence to a normal distribution regardless of the original population shape. Populations with high variance (e.g., exponential) produce wider sampling distributions. Task 4: Practical Applications of the Central Limit Theorem The CLT has wide-ranging applications in both theoretical and applied fields: 1. Estimating Population Parameters Allows statisticians to construct confidence intervals around sample means. Justifies the use of normal approximations when calculating probabilities. 2. Quality Control in Manufacturing Sample means from production lines are used to detect defects or shifts in process performance. CLT ensures that control charts based on sample averages follow predictable behavior. 3. Financial Modeling and Risk Assessment Aggregated returns on investment portfolios often use CLT to justify normality assumptions. Facilitates the computation of risk metrics like Value at Risk (VaR). Conclusion Through simulation, we have observed the Central Limit Theorem in action. The key takeaways are: Regardless of the original distribution (uniform, exponential, or binomial), the distribution of sample means becomes approximately normal as the sample size increases. The rate of convergence depends on the population\u2019s shape and variance. Larger sample sizes lead to smaller variance in the sampling distribution and faster convergence. The CLT underpins many real-world statistical applications, from parameter estimation to process control and financial forecasting. Simulations confirm the power and utility of the CLT, providing both intuitive and empirical evidence for one of statistics' most foundational theorems.","title":"Problem 1: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-through-simulations","text":"","title":"Problem 1: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of probability and statistics. It states that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the population\u2019s original distribution (as long as the variance is finite). Simulations provide an intuitive and hands-on way to observe this phenomenon in action.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-1-simulating-sampling-distributions","text":"We consider the following population distributions: Uniform distribution: U(0, 1) Exponential distribution: Exp(\u03bb=1) Binomial distribution: Bin(n=10, p=0.5) Each distribution is used to generate a large dataset of 100,000 data points to simulate the full population. import numpy as np # Set seed for reproducibility np.random.seed(42) # Population size N = 100000 # Generate populations uniform_pop = np.random.uniform(0, 1, N) exponential_pop = np.random.exponential(1, N) binomial_pop = np.random.binomial(10, 0.5, N)","title":"Task 1: Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-2-sampling-and-visualization","text":"For each population distribution (Uniform, Exponential, Binomial), we perform the following steps to visualize the Central Limit Theorem in action: Randomly sample data from the population using various sample sizes: Sample sizes used: 5, 10, 30, and 50 Repeat the sampling process : Each sampling experiment is repeated 1000 times to create a distribution of sample means. Compute the sample mean for each of the 1000 samples. Plot the sampling distribution : A histogram of the 1000 sample means is created for each sample size. Kernel Density Estimation (KDE) is optionally applied to better visualize the shape of the distribution. These plots help demonstrate how the distribution of sample means converges toward a normal distribution as the sample size increases, even when the underlying population is non-normal. import matplotlib.pyplot as plt import seaborn as sns # Sample sizes sample_sizes = [5, 10, 30, 50] # Function to simulate sample means def simulate_sample_means(population, sample_size, num_samples=1000): return [np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(num_samples)] # Plotting function def plot_sampling_distributions(population, name): fig, axes = plt.subplots(1, len(sample_sizes), figsize=(20, 4)) for i, size in enumerate(sample_sizes): sample_means = simulate_sample_means(population, size) sns.histplot(sample_means, kde=True, ax=axes[i], stat=\"density\", bins=30) axes[i].set_title(f\"{name} Dist\\nSample Size = {size}\") plt.suptitle(f\"Sampling Distribution of Sample Means - {name} Population\", fontsize=16) plt.tight_layout() plt.show() # Generate plots plot_sampling_distributions(uniform_pop, \"Uniform\") plot_sampling_distributions(exponential_pop, \"Exponential\") plot_sampling_distributions(binomial_pop, \"Binomial\")","title":"Task 2: Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-3-parameter-exploration","text":"","title":"Task 3: Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#effect-of-population-shape-on-convergence","text":"Different population distributions influence how quickly the sampling distribution of the mean approaches normality: Uniform Distribution : Symmetric and bounded; the sample means converge quickly to a normal distribution, even for small sample sizes. Exponential Distribution : Highly skewed; requires larger sample sizes for the sampling distribution to resemble a normal distribution. Binomial Distribution : Discrete but symmetric (when p = 0.5); converges quickly, especially with moderate or large sample sizes.","title":"Effect of Population Shape on Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_1/#impact-of-sample-size","text":"The Central Limit Theorem shows that increasing the sample size improves the approximation of the sampling distribution to a normal curve. \\[ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} \\] As sample size n increases: - The standard deviation of the sample mean (standard error) decreases. - The histogram of sample means becomes more concentrated and bell-shaped.","title":"Impact of Sample Size"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations-from-simulations","text":"Smaller sample sizes (e.g., 5) result in a sampling distribution that still resembles the shape of the original distribution. Larger sample sizes (e.g., 30, 50) show clear convergence to a normal distribution regardless of the original population shape. Populations with high variance (e.g., exponential) produce wider sampling distributions.","title":"Observations from Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-4-practical-applications-of-the-central-limit-theorem","text":"The CLT has wide-ranging applications in both theoretical and applied fields:","title":"Task 4: Practical Applications of the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-estimating-population-parameters","text":"Allows statisticians to construct confidence intervals around sample means. Justifies the use of normal approximations when calculating probabilities.","title":"1. Estimating Population Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-quality-control-in-manufacturing","text":"Sample means from production lines are used to detect defects or shifts in process performance. CLT ensures that control charts based on sample averages follow predictable behavior.","title":"2. Quality Control in Manufacturing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-financial-modeling-and-risk-assessment","text":"Aggregated returns on investment portfolios often use CLT to justify normality assumptions. Facilitates the computation of risk metrics like Value at Risk (VaR).","title":"3. Financial Modeling and Risk Assessment"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"Through simulation, we have observed the Central Limit Theorem in action. The key takeaways are: Regardless of the original distribution (uniform, exponential, or binomial), the distribution of sample means becomes approximately normal as the sample size increases. The rate of convergence depends on the population\u2019s shape and variance. Larger sample sizes lead to smaller variance in the sampling distribution and faster convergence. The CLT underpins many real-world statistical applications, from parameter estimation to process control and financial forecasting. Simulations confirm the power and utility of the CLT, providing both intuitive and empirical evidence for one of statistics' most foundational theorems.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods Motivation Monte Carlo simulations use randomness to estimate values and solve complex problems. Estimating \u03c0 is one of the most intuitive examples, showing how probability, geometry, and computational techniques can come together. We'll explore two methods: Estimating \u03c0 using random points in a square and circle. Estimating \u03c0 using Buffon\u2019s Needle experiment. Part 1: Estimating \u03c0 Using a Circle 1. Theoretical Foundation We generate random points in a square bounding a unit circle. The ratio of the number of points that fall inside the circle to the total number of points approximates: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] Hence, \\[ \\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}} \\] 2. Simulation Code import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / n_points # Visualization plt.figure(figsize=(6, 6)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False) plt.gca().add_artist(circle) plt.title(f\"Circle Method: \u03c0 \u2248 {pi_estimate:.5f} (n = {n_points})\") plt.axis('equal') plt.legend() plt.show() return pi_estimate # Example usage: estimate_pi_circle(10000) 3. Visualization Blue dots represent points inside the circle. Red dots are outside the circle. As the number of points increases, the estimate converges to \u03c0 . 4. Analysis Larger sample sizes yield more accurate estimates. Fast convergence with increasing number of points. Very intuitive and efficient for parallel computation. Part 2: Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Foundation Buffon\u2019s Needle experiment drops a needle on a surface with equally spaced parallel lines. The probability \\( P \\) that a needle crosses a line is given by: \\[ P = \\frac{2l}{\\pi d} \\] Rearranging the formula to solve for \u03c0: \\[ \\pi \\approx \\frac{2l \\cdot N}{d \\cdot H} \\] Where: \\( l \\) = length of the needle \\( d \\) = distance between the lines \\( N \\) = total number of needle drops \\( H \\) = number of times the needle crosses a line 2. Simulation Code import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(n_drops, needle_length=1.0, line_spacing=1.5): hits = 0 x_centers = [] angles = [] crosses = [] for _ in range(n_drops): x_center = np.random.uniform(0, line_spacing / 2) theta = np.random.uniform(0, np.pi / 2) if (needle_length / 2) * np.sin(theta) >= x_center: hits += 1 crosses.append(True) else: crosses.append(False) x_centers.append(x_center) angles.append(theta) if hits == 0: return None # Avoid division by zero pi_estimate = (2 * needle_length * n_drops) / (hits * line_spacing) # Visualization plt.figure(figsize=(8, 6)) for i in range(n_drops): x = np.random.uniform(0, 10) y = np.random.uniform(0, 10) angle = angles[i] dx = (needle_length / 2) * np.cos(angle) dy = (needle_length / 2) * np.sin(angle) x1, x2 = x - dx, x + dx y1, y2 = y - dy, y + dy color = 'green' if crosses[i] else 'gray' plt.plot([x1, x2], [y1, y2], color=color, alpha=0.6) for i in range(11): plt.axhline(i * line_spacing, color='black', linewidth=0.5) plt.title(f\"Buffon\u2019s Needle: \u03c0 \u2248 {pi_estimate:.5f} (n = {n_drops})\") plt.xlim(0, 10) plt.ylim(0, 10) plt.gca().set_aspect('equal') plt.show() return pi_estimate # Example usage: estimate_pi_buffon(1000) 3. Visualization Each needle is drawn over horizontal lines. Green: crosses a line Gray: does not cross More drops lead to better approximation. 4. Analysis Estimates \u03c0 probabilistically using trigonometry. Convergence is slower than the circle method. More complex logic and geometry, but historically significant. Final Analysis and Comparison Method Code Complexity Convergence Speed Accuracy Visual Appeal Circle Method Simple Fast High High Buffon\u2019s Needle Medium Slower Medium Medium The circle method is recommended for fast, accurate results. Buffon\u2019s needle is a beautiful illustration of how geometry and probability can reveal deep mathematical truths. Summary Both methods estimate \u03c0 using randomness. The circle-based method is more efficient and easier to implement. Buffon\u2019s needle connects to classical probability and is valuable for educational purposes.","title":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2-estimating-using-monte-carlo-methods","text":"","title":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations use randomness to estimate values and solve complex problems. Estimating \u03c0 is one of the most intuitive examples, showing how probability, geometry, and computational techniques can come together. We'll explore two methods: Estimating \u03c0 using random points in a square and circle. Estimating \u03c0 using Buffon\u2019s Needle experiment.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"We generate random points in a square bounding a unit circle. The ratio of the number of points that fall inside the circle to the total number of points approximates: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] Hence, \\[ \\pi \\approx 4 \\times \\frac{\\text{Points inside circle}}{\\text{Total points}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / n_points # Visualization plt.figure(figsize=(6, 6)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False) plt.gca().add_artist(circle) plt.title(f\"Circle Method: \u03c0 \u2248 {pi_estimate:.5f} (n = {n_points})\") plt.axis('equal') plt.legend() plt.show() return pi_estimate # Example usage: estimate_pi_circle(10000)","title":"2. Simulation Code"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Blue dots represent points inside the circle. Red dots are outside the circle. As the number of points increases, the estimate converges to \u03c0 .","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"Larger sample sizes yield more accurate estimates. Fast convergence with increasing number of points. Very intuitive and efficient for parallel computation.","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Buffon\u2019s Needle experiment drops a needle on a surface with equally spaced parallel lines. The probability \\( P \\) that a needle crosses a line is given by: \\[ P = \\frac{2l}{\\pi d} \\] Rearranging the formula to solve for \u03c0: \\[ \\pi \\approx \\frac{2l \\cdot N}{d \\cdot H} \\] Where: \\( l \\) = length of the needle \\( d \\) = distance between the lines \\( N \\) = total number of needle drops \\( H \\) = number of times the needle crosses a line","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-code_1","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(n_drops, needle_length=1.0, line_spacing=1.5): hits = 0 x_centers = [] angles = [] crosses = [] for _ in range(n_drops): x_center = np.random.uniform(0, line_spacing / 2) theta = np.random.uniform(0, np.pi / 2) if (needle_length / 2) * np.sin(theta) >= x_center: hits += 1 crosses.append(True) else: crosses.append(False) x_centers.append(x_center) angles.append(theta) if hits == 0: return None # Avoid division by zero pi_estimate = (2 * needle_length * n_drops) / (hits * line_spacing) # Visualization plt.figure(figsize=(8, 6)) for i in range(n_drops): x = np.random.uniform(0, 10) y = np.random.uniform(0, 10) angle = angles[i] dx = (needle_length / 2) * np.cos(angle) dy = (needle_length / 2) * np.sin(angle) x1, x2 = x - dx, x + dx y1, y2 = y - dy, y + dy color = 'green' if crosses[i] else 'gray' plt.plot([x1, x2], [y1, y2], color=color, alpha=0.6) for i in range(11): plt.axhline(i * line_spacing, color='black', linewidth=0.5) plt.title(f\"Buffon\u2019s Needle: \u03c0 \u2248 {pi_estimate:.5f} (n = {n_drops})\") plt.xlim(0, 10) plt.ylim(0, 10) plt.gca().set_aspect('equal') plt.show() return pi_estimate # Example usage: estimate_pi_buffon(1000)","title":"2. Simulation Code"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"Each needle is drawn over horizontal lines. Green: crosses a line Gray: does not cross More drops lead to better approximation.","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Estimates \u03c0 probabilistically using trigonometry. Convergence is slower than the circle method. More complex logic and geometry, but historically significant.","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#final-analysis-and-comparison","text":"Method Code Complexity Convergence Speed Accuracy Visual Appeal Circle Method Simple Fast High High Buffon\u2019s Needle Medium Slower Medium Medium The circle method is recommended for fast, accurate results. Buffon\u2019s needle is a beautiful illustration of how geometry and probability can reveal deep mathematical truths.","title":"Final Analysis and Comparison"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary","text":"Both methods estimate \u03c0 using randomness. The circle-based method is more efficient and easier to implement. Buffon\u2019s needle connects to classical probability and is valuable for educational purposes.","title":"Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration \\(g\\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. Measuring \\(g\\) accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining \\(g\\) is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field. Task Measure the acceleration \\(g\\) due to gravity using a pendulum and analyze in detail the uncertainties in the measurements. This exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics. Procedure 1. Materials: A string (1 or 1.5 meters long) A small weight (e.g., bag of coins, bag of sugar, key chain) mounted on the string Stopwatch (or smartphone timer) Ruler or measuring tape 2. Setup: Attach the weight to the string and fix the other end to a sturdy support. Measure the length of the pendulum, \\(L\\) , from the suspension point to the center of the weight using a ruler or measuring tape. Record the resolution of the measuring tool and calculate the uncertainty as half the resolution, \\(u_L = \\frac{\\text{resolution}}{2}\\) . 3. Data Collection: Displace the pendulum slightly (<15\u00b0) and release it. Measure the time for 10 full oscillations ( \\(T_{10}\\) ) and repeat this process 10 times. Record all 10 measurements. Calculate the mean time for 10 oscillations ( \\(\\bar{T}_{10}\\) ) and the standard deviation ( \\(s\\) ). Determine the uncertainty in the mean time as: $$ u_{\\bar{T}_{10}} = \\frac{s}{\\sqrt{10}} $$ Calculations 1. Calculate the period \\(T\\) : \\[ T = \\frac{\\bar{T}_{10}}{10} \\quad,\\quad u_T = \\frac{u_{\\bar{T}_{10}}}{10} \\] 2. Determine \\(g\\) : \\[ g = \\frac{4\\pi^2 L}{T^2} \\] 3. Propagate uncertainties: \\[ u_g = g \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\frac{u_T}{T}\\right)^2} \\] Sample Data Trial # \\(T_{10}\\) (s) 1 20.15 2 20.20 3 20.10 4 20.18 5 20.22 6 20.25 7 20.17 8 20.19 9 20.13 10 20.21 Example Calculations Mean time for 10 oscillations: $$ \\bar{T} {10} = \\frac{1}{10} \\sum {i=1}^{10} T_{10,i} = 20.18 \\text{ s} $$ Standard deviation: $$ s = \\sqrt{\\frac{1}{9} \\sum_{i=1}^{10} (T_{10,i} - \\bar{T}_{10})^2} = 0.05 \\text{ s} $$ Uncertainty in mean time: $$ u_{\\bar{T}_{10}} = \\frac{s}{\\sqrt{10}} = \\frac{0.05}{3.16} \\approx 0.016 \\text{ s} $$ Period and uncertainty: \\(T = \\frac{\\bar{T}_{10}}{10} = 2.018\\) s, and \\(u_T = \\frac{u_{\\bar{T}_{10}}}{10} = 0.0016\\) s Pendulum length and uncertainty: \\(L = 1.00\\) m, \\(u_L = \\frac{0.01}{2} = 0.005\\) m Calculate \\(g\\) : $$ g = \\frac{4\\pi^2 L}{T^2} = \\frac{4 \\times (3.1416)^2 \\times 1.00}{(2.018)^2} \\approx 9.70 \\, m/s^2 $$ Propagate uncertainty: $$ u_g = g \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\frac{u_T}{T}\\right)^2} = 9.70 \\times \\sqrt{(0.005)^2 + \\left(2 \\times \\frac{0.0016}{2.018}\\right)^2} \\approx 0.05 \\, m/s^2 $$ Discussion The measured value \\(g = 9.70 \\pm 0.05 \\, m/s^2\\) is close to the standard \\(9.81 \\, m/s^2\\) , with slight deviations likely due to experimental uncertainties. Measurement resolution for length ( \\(\\pm 0.005\\) m) contributes less uncertainty compared to timing. Timing variability significantly impacts the uncertainty in \\(g\\) , as timing uncertainty enters the formula squared. Assumptions include small oscillation angles (<15\u00b0) and neglecting air resistance and friction. Limitations include manual stopwatch reaction times and difficulty precisely measuring the pendulum length to the center of mass.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration \\(g\\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. Measuring \\(g\\) accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining \\(g\\) is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Measure the acceleration \\(g\\) due to gravity using a pendulum and analyze in detail the uncertainties in the measurements. This exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics.","title":"Task"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"A string (1 or 1.5 meters long) A small weight (e.g., bag of coins, bag of sugar, key chain) mounted on the string Stopwatch (or smartphone timer) Ruler or measuring tape","title":"1. Materials:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-setup","text":"Attach the weight to the string and fix the other end to a sturdy support. Measure the length of the pendulum, \\(L\\) , from the suspension point to the center of the weight using a ruler or measuring tape. Record the resolution of the measuring tool and calculate the uncertainty as half the resolution, \\(u_L = \\frac{\\text{resolution}}{2}\\) .","title":"2. Setup:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-data-collection","text":"Displace the pendulum slightly (<15\u00b0) and release it. Measure the time for 10 full oscillations ( \\(T_{10}\\) ) and repeat this process 10 times. Record all 10 measurements. Calculate the mean time for 10 oscillations ( \\(\\bar{T}_{10}\\) ) and the standard deviation ( \\(s\\) ). Determine the uncertainty in the mean time as: $$ u_{\\bar{T}_{10}} = \\frac{s}{\\sqrt{10}} $$","title":"3. Data Collection:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period-t","text":"\\[ T = \\frac{\\bar{T}_{10}}{10} \\quad,\\quad u_T = \\frac{u_{\\bar{T}_{10}}}{10} \\]","title":"1. Calculate the period \\(T\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"2. Determine \\(g\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"\\[ u_g = g \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\frac{u_T}{T}\\right)^2} \\]","title":"3. Propagate uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#sample-data","text":"Trial # \\(T_{10}\\) (s) 1 20.15 2 20.20 3 20.10 4 20.18 5 20.22 6 20.25 7 20.17 8 20.19 9 20.13 10 20.21","title":"Sample Data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#example-calculations","text":"Mean time for 10 oscillations: $$ \\bar{T} {10} = \\frac{1}{10} \\sum {i=1}^{10} T_{10,i} = 20.18 \\text{ s} $$ Standard deviation: $$ s = \\sqrt{\\frac{1}{9} \\sum_{i=1}^{10} (T_{10,i} - \\bar{T}_{10})^2} = 0.05 \\text{ s} $$ Uncertainty in mean time: $$ u_{\\bar{T}_{10}} = \\frac{s}{\\sqrt{10}} = \\frac{0.05}{3.16} \\approx 0.016 \\text{ s} $$ Period and uncertainty: \\(T = \\frac{\\bar{T}_{10}}{10} = 2.018\\) s, and \\(u_T = \\frac{u_{\\bar{T}_{10}}}{10} = 0.0016\\) s Pendulum length and uncertainty: \\(L = 1.00\\) m, \\(u_L = \\frac{0.01}{2} = 0.005\\) m Calculate \\(g\\) : $$ g = \\frac{4\\pi^2 L}{T^2} = \\frac{4 \\times (3.1416)^2 \\times 1.00}{(2.018)^2} \\approx 9.70 \\, m/s^2 $$ Propagate uncertainty: $$ u_g = g \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\frac{u_T}{T}\\right)^2} = 9.70 \\times \\sqrt{(0.005)^2 + \\left(2 \\times \\frac{0.0016}{2.018}\\right)^2} \\approx 0.05 \\, m/s^2 $$","title":"Example Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"The measured value \\(g = 9.70 \\pm 0.05 \\, m/s^2\\) is close to the standard \\(9.81 \\, m/s^2\\) , with slight deviations likely due to experimental uncertainties. Measurement resolution for length ( \\(\\pm 0.005\\) m) contributes less uncertainty compared to timing. Timing variability significantly impacts the uncertainty in \\(g\\) , as timing uncertainty enters the formula squared. Assumptions include small oscillation angles (<15\u00b0) and neglecting air resistance and friction. Limitations include manual stopwatch reaction times and difficulty precisely measuring the pendulum length to the center of mass.","title":"Discussion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}